{
  "version": 3,
  "sources": ["../../@multiformats/multiaddr-matcher/src/index.ts"],
  "sourcesContent": ["/**\n * @packageDocumentation\n *\n * This module exports various matchers that can be used to infer the type of a\n * passed multiaddr.\n *\n * @example\n *\n * ```ts\n * import { multiaddr } from '@multiformats/multiaddr'\n * import { DNS } from '@multiformats/multiaddr-matcher'\n *\n * const ma = multiaddr('/dnsaddr/example.org')\n *\n * DNS.matches(ma) // true - this is a multiaddr with a DNS address at the start\n * ```\n *\n * @example\n *\n * The default matching behaviour ignores any subsequent tuples in the multiaddr.\n * If you want stricter matching you can use `.exactMatch`:\n *\n * ```ts\n * import { multiaddr } from '@multiformats/multiaddr'\n * import { DNS, Circuit } from '@multiformats/multiaddr-matcher'\n *\n * const ma = multiaddr('/dnsaddr/example.org/p2p/QmFoo/p2p-circuit/p2p/QmBar')\n *\n * DNS.exactMatch(ma) // false - this address has extra tuples after the DNS component\n * Circuit.matches(ma) // true\n * Circuit.exactMatch(ma) // true - the extra tuples are circuit relay related\n * ```\n */\n\nimport { isIPv4, isIPv6 } from '@chainsafe/is-ip'\nimport { type Multiaddr } from '@multiformats/multiaddr'\nimport { base58btc } from 'multiformats/bases/base58'\nimport { base64url } from 'multiformats/bases/base64'\n\n/**\n * Split a multiaddr into path components\n */\nconst toParts = (ma: Multiaddr): string[] => {\n  return ma.toString().split('/').slice(1)\n}\n\n/**\n * A matcher accepts multiaddr components and either fails to match and returns\n * false or returns a sublist of unmatched components\n */\ninterface Matcher {\n  match(parts: string[]): string[] | false\n  pattern: string\n}\n\nconst func = (fn: (val: string) => boolean): Matcher => {\n  return {\n    match: (vals) => {\n      if (vals.length < 1) {\n        return false\n      }\n\n      if (fn(vals[0])) {\n        return vals.slice(1)\n      }\n\n      return false\n    },\n    pattern: 'fn'\n  }\n}\n\nconst literal = (str: string): Matcher => {\n  return {\n    match: (vals) => func((val) => val === str).match(vals),\n    pattern: str\n  }\n}\n\nconst string = (): Matcher => {\n  return {\n    match: (vals) => func((val) => typeof val === 'string').match(vals),\n    pattern: '{string}'\n  }\n}\n\nconst number = (): Matcher => {\n  return {\n    match: (vals) => func((val) => !isNaN(parseInt(val))).match(vals),\n    pattern: '{number}'\n  }\n}\n\nconst peerId = (): Matcher => {\n  return {\n    match: (vals) => {\n      if (vals.length < 2) {\n        return false\n      }\n\n      if (vals[0] !== 'p2p' && vals[0] !== 'ipfs') {\n        return false\n      }\n\n      // Q is RSA, 1 is Ed25519 or Secp256k1\n      if (vals[1].startsWith('Q') || vals[1].startsWith('1')) {\n        try {\n          base58btc.decode(`z${vals[1]}`)\n        } catch (err) {\n          return false\n        }\n      } else {\n        return false\n      }\n\n      return vals.slice(2)\n    },\n    pattern: '/p2p/{peerid}'\n  }\n}\n\nconst certhash = (): Matcher => {\n  return {\n    match: (vals) => {\n      if (vals.length < 2) {\n        return false\n      }\n\n      if (vals[0] !== 'certhash') {\n        return false\n      }\n\n      try {\n        base64url.decode(vals[1])\n      } catch {\n        return false\n      }\n\n      return vals.slice(2)\n    },\n    pattern: '/certhash/{certhash}'\n  }\n}\n\nconst optional = (matcher: Matcher): Matcher => {\n  return {\n    match: (vals) => {\n      const result = matcher.match(vals)\n\n      if (result === false) {\n        return vals\n      }\n\n      return result\n    },\n    pattern: `optional(${matcher.pattern})`\n  }\n}\n\nconst or = (...matchers: Matcher[]): Matcher => {\n  return {\n    match: (vals) => {\n      let matches: string[] | undefined\n\n      for (const matcher of matchers) {\n        const result = matcher.match(vals)\n\n        // no match\n        if (result === false) {\n          continue\n        }\n\n        // choose greediest matcher\n        if (matches == null || result.length < matches.length) {\n          matches = result\n        }\n      }\n\n      if (matches == null) {\n        return false\n      }\n\n      return matches\n    },\n    pattern: `or(${matchers.map(m => m.pattern).join(', ')})`\n  }\n}\n\nconst and = (...matchers: Matcher[]): Matcher => {\n  return {\n    match: (vals) => {\n      for (const matcher of matchers) {\n        // pass what's left of the array\n        const result = matcher.match(vals)\n\n        // no match\n        if (result === false) {\n          return false\n        }\n\n        vals = result\n      }\n\n      return vals\n    },\n    pattern: `and(${matchers.map(m => m.pattern).join(', ')})`\n  }\n}\n\nfunction fmt (...matchers: Matcher[]): MultiaddrMatcher {\n  function match (ma: Multiaddr): string[] | false {\n    let parts = toParts(ma)\n\n    for (const matcher of matchers) {\n      const result = matcher.match(parts)\n\n      if (result === false) {\n        return false\n      }\n\n      parts = result\n    }\n\n    return parts\n  }\n\n  function matches (ma: Multiaddr): boolean {\n    const result = match(ma)\n\n    return result !== false\n  }\n\n  function exactMatch (ma: Multiaddr): boolean {\n    const result = match(ma)\n\n    if (result === false) {\n      return false\n    }\n\n    return result.length === 0\n  }\n\n  return {\n    matches,\n    exactMatch\n  }\n}\n\n/**\n * A MultiaddrMatcher allows interpreting a multiaddr as a certain type of\n * multiaddr\n */\nexport interface MultiaddrMatcher {\n  /**\n   * Returns true if the passed multiaddr can be treated as this type of\n   * multiaddr\n   */\n  matches(ma: Multiaddr): boolean\n\n  /**\n   * Returns true if the passed multiaddr terminates as this type of\n   * multiaddr\n   */\n  exactMatch(ma: Multiaddr): boolean\n}\n\n/**\n * DNS matchers\n */\nconst _DNS4 = and(literal('dns4'), string())\nconst _DNS6 = and(literal('dns6'), string())\nconst _DNSADDR = and(literal('dnsaddr'), string())\nconst _DNS = and(literal('dns'), string())\n\n/**\n * Matches dns4 addresses.\n *\n * Use {@link DNS DNS} instead to match any type of DNS address.\n *\n * @example\n *\n * ```ts\n * import { multiaddr } from '@multiformats/multiaddr'\n * import { DNS4 } from '@multiformats/multiaddr-matcher'\n *\n * DNS4.matches(multiaddr('/dns4/example.org')) // true\n * ```\n */\nexport const DNS4 = fmt(_DNS4)\n\n/**\n * Matches dns6 addresses.\n *\n * Use {@link DNS DNS} instead to match any type of DNS address.\n *\n * @example\n *\n * ```ts\n * import { multiaddr } from '@multiformats/multiaddr'\n * import { DNS6 } from '@multiformats/multiaddr-matcher'\n *\n * DNS6.matches(multiaddr('/dns6/example.org')) // true\n * ```\n */\nexport const DNS6 = fmt(_DNS6)\n\n/**\n * Matches dnsaddr addresses.\n *\n * Use {@link DNS DNS} instead to match any type of DNS address.\n *\n * @example\n *\n * ```ts\n * import { multiaddr } from '@multiformats/multiaddr'\n * import { DNSADDR } from '@multiformats/multiaddr-matcher'\n *\n * DNSADDR.matches(multiaddr('/dnsaddr/example.org')) // true\n * ```\n */\nexport const DNSADDR = fmt(_DNSADDR)\n\n/**\n * Matches any dns address.\n *\n * @example\n *\n * ```ts\n * import { multiaddr } from '@multiformats/multiaddr'\n * import { DNS } from '@multiformats/multiaddr-matcher'\n *\n * DNS.matches(multiaddr('/dnsaddr/example.org')) // true\n * DNS.matches(multiaddr('/dns4/example.org')) // true\n * DNS.matches(multiaddr('/dns6/example.org')) // true\n * ```\n */\nexport const DNS = fmt(or(\n  _DNS,\n  _DNSADDR,\n  _DNS4,\n  _DNS6\n))\n\nconst _IP4 = and(literal('ip4'), func(isIPv4))\nconst _IP6 = and(literal('ip6'), func(isIPv6))\nconst _IP = or(\n  _IP4,\n  _IP6\n)\n\nconst _IP_OR_DOMAIN = or(_IP, _DNS, _DNS4, _DNS6, _DNSADDR)\n\n/**\n * A matcher for addresses that start with IP or DNS tuples.\n *\n * @example\n *\n * ```ts\n * import { multiaddr } from '@multiformats/multiaddr'\n * import { IP_OR_DOMAIN } from '@multiformats/multiaddr-matcher'\n *\n * IP_OR_DOMAIN.matches(multiaddr('/ip4/123.123.123.123/p2p/QmFoo')) // true\n * IP_OR_DOMAIN.matches(multiaddr('/dns/example.com/p2p/QmFoo')) // true\n * IP_OR_DOMAIN.matches(multiaddr('/p2p/QmFoo')) // false\n * ```\n */\nexport const IP_OR_DOMAIN = fmt(_IP_OR_DOMAIN)\n\n/**\n * Matches ip4 addresses.\n *\n * Use {@link IP IP} instead to match any ip4/ip6 address.\n *\n * @example\n *\n * ```ts\n * import { multiaddr } from '@multiformats/multiaddr'\n * import { IP4 } from '@multiformats/multiaddr-matcher'\n *\n * const ma = multiaddr('/ip4/123.123.123.123')\n *\n * IP4.matches(ma) // true\n * ```\n */\nexport const IP4 = fmt(_IP4)\n\n/**\n * Matches ip6 addresses.\n *\n * Use {@link IP IP} instead to match any ip4/ip6 address.\n *\n * @example\n *\n * ```ts\n * import { multiaddr } from '@multiformats/multiaddr'\n * import { IP6 } from '@multiformats/multiaddr-matcher'\n *\n * const ma = multiaddr('/ip6/fe80::1cc1:a3b8:322f:cf22')\n *\n * IP6.matches(ma) // true\n * ```\n */\nexport const IP6 = fmt(_IP6)\n\n/**\n * Matches ip4 or ip6 addresses.\n *\n * @example\n *\n * ```ts\n * import { multiaddr } from '@multiformats/multiaddr'\n * import { IP } from '@multiformats/multiaddr-matcher'\n *\n * IP.matches(multiaddr('/ip4/123.123.123.123')) // true\n * IP.matches(multiaddr('/ip6/fe80::1cc1:a3b8:322f:cf22')) // true\n * ```\n */\nexport const IP = fmt(_IP)\n\nconst _TCP = and(_IP_OR_DOMAIN, literal('tcp'), number())\nconst _UDP = and(_IP_OR_DOMAIN, literal('udp'), number())\n\nconst TCP_OR_UDP = or(_TCP, _UDP)\n\n/**\n * Matches TCP addresses.\n *\n * @example\n *\n * ```ts\n * import { multiaddr } from '@multiformats/multiaddr'\n * import { TCP } from '@multiformats/multiaddr-matcher'\n *\n * TCP.matches(multiaddr('/ip4/123.123.123.123/tcp/1234')) // true\n * ```\n */\nexport const TCP = fmt(_TCP)\n\n/**\n * Matches UDP addresses.\n *\n * @example\n *\n * ```ts\n * import { multiaddr } from '@multiformats/multiaddr'\n * import { UDP } from '@multiformats/multiaddr-matcher'\n *\n * UDP.matches(multiaddr('/ip4/123.123.123.123/udp/1234')) // true\n * ```\n */\nexport const UDP = fmt(_UDP)\n\nconst _QUIC = and(_UDP, literal('quic'))\nconst _QUICV1 = and(_UDP, literal('quic-v1'))\n\nconst QUIC_V0_OR_V1 = or(_QUIC, _QUICV1)\n\n/**\n * Matches QUIC addresses.\n *\n * @example\n *\n * ```ts\n * import { multiaddr } from '@multiformats/multiaddr'\n * import { QUIC } from '@multiformats/multiaddr-matcher'\n *\n * QUIC.matches(multiaddr('/ip4/123.123.123.123/udp/1234/quic')) // true\n * ```\n */\nexport const QUIC = fmt(_QUIC)\n\n/**\n * Matches QUICv1 addresses.\n *\n * @example\n *\n * ```ts\n * import { multiaddr } from '@multiformats/multiaddr'\n * import { QUICV1 } from '@multiformats/multiaddr-matcher'\n *\n * QUICV1.matches(multiaddr('/ip4/123.123.123.123/udp/1234/quic-v1')) // true\n * ```\n */\nexport const QUICV1 = fmt(_QUICV1)\n\nconst _WEB = or(\n  _IP_OR_DOMAIN,\n  _TCP,\n  _UDP,\n  _QUIC,\n  _QUICV1\n)\n\nconst _WebSockets = or(\n  and(_WEB, literal('ws'), optional(peerId()))\n)\n\n/**\n * Matches WebSocket addresses.\n *\n * @example\n *\n * ```ts\n * import { multiaddr } from '@multiformats/multiaddr'\n * import { WebSockets } from '@multiformats/multiaddr-matcher'\n *\n * WebSockets.matches(multiaddr('/ip4/123.123.123.123/tcp/1234/ws')) // true\n * ```\n */\nexport const WebSockets = fmt(_WebSockets)\n\nconst _WebSocketsSecure = or(\n  and(_WEB, literal('wss'), optional(peerId())),\n  and(_WEB, literal('tls'), literal('ws'), optional(peerId()))\n)\n\n/**\n * Matches secure WebSocket addresses.\n *\n * @example\n *\n * ```ts\n * import { multiaddr } from '@multiformats/multiaddr'\n * import { WebSocketsSecure } from '@multiformats/multiaddr-matcher'\n *\n * WebSocketsSecure.matches(multiaddr('/ip4/123.123.123.123/tcp/1234/wss')) // true\n * ```\n */\nexport const WebSocketsSecure = fmt(_WebSocketsSecure)\n\nconst _WebRTCDirect = and(TCP_OR_UDP, literal('webrtc-direct'), certhash(), optional(certhash()), optional(peerId()))\n\n/**\n * Matches WebRTC-direct addresses.\n *\n * @example\n *\n * ```ts\n * import { multiaddr } from '@multiformats/multiaddr'\n * import { WebRTCDirect } from '@multiformats/multiaddr-matcher'\n *\n * WebRTCDirect.matches(multiaddr('/ip4/123.123.123.123/tcp/1234/p2p/QmFoo/webrtc-direct/certhash/u....')) // true\n * ```\n */\nexport const WebRTCDirect = fmt(_WebRTCDirect)\n\nconst _WebTransport = and(_QUICV1, literal('webtransport'), optional(certhash()), optional(certhash()), optional(peerId()))\n\n/**\n * Matches WebTransport addresses.\n *\n * @example\n *\n * ```ts\n * import { multiaddr } from '@multiformats/multiaddr'\n * import { WebRTCDirect } from '@multiformats/multiaddr-matcher'\n *\n * WebRTCDirect.matches(multiaddr('/ip4/123.123.123.123/udp/1234/quic-v1/webtransport/certhash/u..../certhash/u..../p2p/QmFoo')) // true\n * ```\n */\nexport const WebTransport = fmt(_WebTransport)\n\nconst _P2P = or(\n  _WebSockets,\n  _WebSocketsSecure,\n  and(_TCP, optional(peerId())),\n  and(QUIC_V0_OR_V1, optional(peerId())),\n  and(_IP_OR_DOMAIN, optional(peerId())),\n  _WebRTCDirect,\n  _WebTransport,\n  peerId()\n)\n\n/**\n * Matches peer addresses\n *\n * @example\n *\n * ```ts\n * import { multiaddr } from '@multiformats/multiaddr'\n * import { P2P } from '@multiformats/multiaddr-matcher'\n *\n * P2P.matches(multiaddr('/ip4/123.123.123.123/tcp/1234/p2p/QmFoo')) // true\n * ```\n */\nexport const P2P = fmt(_P2P)\n\nconst _Circuit = and(_P2P, literal('p2p-circuit'), peerId())\n\n/**\n * Matches circuit relay addresses\n *\n * @example\n *\n * ```ts\n * import { multiaddr } from '@multiformats/multiaddr'\n * import { Circuit } from '@multiformats/multiaddr-matcher'\n *\n * Circuit.matches(multiaddr('/ip4/123.123.123.123/tcp/1234/p2p/QmRelay/p2p-circuit/p2p/QmTarget')) // true\n * ```\n */\nexport const Circuit = fmt(_Circuit)\n\nconst _WebRTC = or(\n  and(_P2P, literal('p2p-circuit'), literal('webrtc'), peerId()),\n  and(_P2P, literal('webrtc'), optional(peerId())),\n  literal('webrtc')\n)\n\n/**\n * Matches WebRTC addresses\n *\n * @example\n *\n * ```ts\n * import { multiaddr } from '@multiformats/multiaddr'\n * import { WebRTC } from '@multiformats/multiaddr-matcher'\n *\n * WebRTC.matches(multiaddr('/ip4/123.123.123.123/tcp/1234/p2p/QmRelay/p2p-circuit/webrtc/p2p/QmTarget')) // true\n * ```\n */\nexport const WebRTC = fmt(_WebRTC)\n\nconst _HTTP = or(\n  and(_IP_OR_DOMAIN, literal('tcp'), number(), literal('http'), optional(peerId())),\n  and(_IP_OR_DOMAIN, literal('http'), optional(peerId()))\n)\n\n/**\n * Matches HTTP addresses\n *\n * @example\n *\n * ```ts\n * import { multiaddr } from '@multiformats/multiaddr'\n * import { HTTP } from '@multiformats/multiaddr-matcher'\n *\n * HTTP.matches(multiaddr('/dns/example.org/http')) // true\n * ```\n */\nexport const HTTP = fmt(_HTTP)\n\nconst _HTTPS = or(\n  and(_IP_OR_DOMAIN, literal('tcp'), or(\n    and(literal('443'), literal('http')),\n    and(number(), literal('https'))\n  ), optional(peerId())),\n  and(_IP_OR_DOMAIN, literal('tls'), literal('http'), optional(peerId())),\n  and(_IP_OR_DOMAIN, literal('https'), optional(peerId()))\n)\n\n/**\n * Matches HTTPS addresses\n *\n * @example\n *\n * ```ts\n * import { multiaddr } from '@multiformats/multiaddr'\n * import { HTTP } from '@multiformats/multiaddr-matcher'\n *\n * HTTP.matches(multiaddr('/dns/example.org/tls/http')) // true\n * ```\n */\nexport const HTTPS = fmt(_HTTPS)\n"],
  "mappings": "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",
  "names": []
}
