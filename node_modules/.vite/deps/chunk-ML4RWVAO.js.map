{
  "version": 3,
  "sources": ["../../@libp2p/peer-record/src/errors.ts", "../../@libp2p/peer-record/src/envelope/envelope.ts", "../../@libp2p/peer-record/src/envelope/index.ts", "../../@libp2p/utils/src/array-equals.ts", "../../@libp2p/peer-record/src/peer-record/consts.ts", "../../@libp2p/peer-record/src/peer-record/peer-record.ts", "../../@libp2p/peer-record/src/peer-record/index.ts"],
  "sourcesContent": ["export const codes = {\n  ERR_SIGNATURE_NOT_VALID: 'ERR_SIGNATURE_NOT_VALID'\n}\n", "/* eslint-disable import/export */\n/* eslint-disable complexity */\n/* eslint-disable @typescript-eslint/no-namespace */\n/* eslint-disable @typescript-eslint/no-unnecessary-boolean-literal-compare */\n/* eslint-disable @typescript-eslint/no-empty-interface */\n\nimport { encodeMessage, decodeMessage, message } from 'protons-runtime'\nimport type { Codec } from 'protons-runtime'\nimport type { Uint8ArrayList } from 'uint8arraylist'\n\nexport interface Envelope {\n  publicKey: Uint8Array\n  payloadType: Uint8Array\n  payload: Uint8Array\n  signature: Uint8Array\n}\n\nexport namespace Envelope {\n  let _codec: Codec<Envelope>\n\n  export const codec = (): Codec<Envelope> => {\n    if (_codec == null) {\n      _codec = message<Envelope>((obj, w, opts = {}) => {\n        if (opts.lengthDelimited !== false) {\n          w.fork()\n        }\n\n        if ((obj.publicKey != null && obj.publicKey.byteLength > 0)) {\n          w.uint32(10)\n          w.bytes(obj.publicKey)\n        }\n\n        if ((obj.payloadType != null && obj.payloadType.byteLength > 0)) {\n          w.uint32(18)\n          w.bytes(obj.payloadType)\n        }\n\n        if ((obj.payload != null && obj.payload.byteLength > 0)) {\n          w.uint32(26)\n          w.bytes(obj.payload)\n        }\n\n        if ((obj.signature != null && obj.signature.byteLength > 0)) {\n          w.uint32(42)\n          w.bytes(obj.signature)\n        }\n\n        if (opts.lengthDelimited !== false) {\n          w.ldelim()\n        }\n      }, (reader, length) => {\n        const obj: any = {\n          publicKey: new Uint8Array(0),\n          payloadType: new Uint8Array(0),\n          payload: new Uint8Array(0),\n          signature: new Uint8Array(0)\n        }\n\n        const end = length == null ? reader.len : reader.pos + length\n\n        while (reader.pos < end) {\n          const tag = reader.uint32()\n\n          switch (tag >>> 3) {\n            case 1:\n              obj.publicKey = reader.bytes()\n              break\n            case 2:\n              obj.payloadType = reader.bytes()\n              break\n            case 3:\n              obj.payload = reader.bytes()\n              break\n            case 5:\n              obj.signature = reader.bytes()\n              break\n            default:\n              reader.skipType(tag & 7)\n              break\n          }\n        }\n\n        return obj\n      })\n    }\n\n    return _codec\n  }\n\n  export const encode = (obj: Partial<Envelope>): Uint8Array => {\n    return encodeMessage(obj, Envelope.codec())\n  }\n\n  export const decode = (buf: Uint8Array | Uint8ArrayList): Envelope => {\n    return decodeMessage(buf, Envelope.codec())\n  }\n}\n", "import { unmarshalPrivateKey, unmarshalPublicKey } from '@libp2p/crypto/keys'\nimport { CodeError } from '@libp2p/interface'\nimport { peerIdFromKeys } from '@libp2p/peer-id'\nimport * as varint from 'uint8-varint'\nimport { Uint8ArrayList } from 'uint8arraylist'\nimport { equals as uint8ArrayEquals } from 'uint8arrays/equals'\nimport { fromString as uint8arraysFromString } from 'uint8arrays/from-string'\nimport { codes } from '../errors.js'\nimport { Envelope as Protobuf } from './envelope.js'\nimport type { PeerId, Record, Envelope } from '@libp2p/interface'\n\nexport interface RecordEnvelopeInit {\n  peerId: PeerId\n  payloadType: Uint8Array\n  payload: Uint8Array\n  signature: Uint8Array\n}\n\nexport class RecordEnvelope implements Envelope {\n  /**\n   * Unmarshal a serialized Envelope protobuf message\n   */\n  static createFromProtobuf = async (data: Uint8Array | Uint8ArrayList): Promise<RecordEnvelope> => {\n    const envelopeData = Protobuf.decode(data)\n    const peerId = await peerIdFromKeys(envelopeData.publicKey)\n\n    return new RecordEnvelope({\n      peerId,\n      payloadType: envelopeData.payloadType,\n      payload: envelopeData.payload,\n      signature: envelopeData.signature\n    })\n  }\n\n  /**\n   * Seal marshals the given Record, places the marshaled bytes inside an Envelope\n   * and signs it with the given peerId's private key\n   */\n  static seal = async (record: Record, peerId: PeerId): Promise<RecordEnvelope> => {\n    if (peerId.privateKey == null) {\n      throw new Error('Missing private key')\n    }\n\n    const domain = record.domain\n    const payloadType = record.codec\n    const payload = record.marshal()\n    const signData = formatSignaturePayload(domain, payloadType, payload)\n    const key = await unmarshalPrivateKey(peerId.privateKey)\n    const signature = await key.sign(signData.subarray())\n\n    return new RecordEnvelope({\n      peerId,\n      payloadType,\n      payload,\n      signature\n    })\n  }\n\n  /**\n   * Open and certify a given marshalled envelope.\n   * Data is unmarshalled and the signature validated for the given domain.\n   */\n  static openAndCertify = async (data: Uint8Array | Uint8ArrayList, domain: string): Promise<RecordEnvelope> => {\n    const envelope = await RecordEnvelope.createFromProtobuf(data)\n    const valid = await envelope.validate(domain)\n\n    if (!valid) {\n      throw new CodeError('envelope signature is not valid for the given domain', codes.ERR_SIGNATURE_NOT_VALID)\n    }\n\n    return envelope\n  }\n\n  public peerId: PeerId\n  public payloadType: Uint8Array\n  public payload: Uint8Array\n  public signature: Uint8Array\n  public marshaled?: Uint8Array\n\n  /**\n   * The Envelope is responsible for keeping an arbitrary signed record\n   * by a libp2p peer.\n   */\n  constructor (init: RecordEnvelopeInit) {\n    const { peerId, payloadType, payload, signature } = init\n\n    this.peerId = peerId\n    this.payloadType = payloadType\n    this.payload = payload\n    this.signature = signature\n  }\n\n  /**\n   * Marshal the envelope content\n   */\n  marshal (): Uint8Array {\n    if (this.peerId.publicKey == null) {\n      throw new Error('Missing public key')\n    }\n\n    if (this.marshaled == null) {\n      this.marshaled = Protobuf.encode({\n        publicKey: this.peerId.publicKey,\n        payloadType: this.payloadType,\n        payload: this.payload.subarray(),\n        signature: this.signature\n      })\n    }\n\n    return this.marshaled\n  }\n\n  /**\n   * Verifies if the other Envelope is identical to this one\n   */\n  equals (other: Envelope): boolean {\n    return uint8ArrayEquals(this.marshal(), other.marshal())\n  }\n\n  /**\n   * Validate envelope data signature for the given domain\n   */\n  async validate (domain: string): Promise<boolean> {\n    const signData = formatSignaturePayload(domain, this.payloadType, this.payload)\n\n    if (this.peerId.publicKey == null) {\n      throw new Error('Missing public key')\n    }\n\n    const key = unmarshalPublicKey(this.peerId.publicKey)\n\n    return key.verify(signData.subarray(), this.signature)\n  }\n}\n\n/**\n * Helper function that prepares a Uint8Array to sign or verify a signature\n */\nconst formatSignaturePayload = (domain: string, payloadType: Uint8Array, payload: Uint8Array | Uint8ArrayList): Uint8ArrayList => {\n  // When signing, a peer will prepare a Uint8Array by concatenating the following:\n  // - The length of the domain separation string string in bytes\n  // - The domain separation string, encoded as UTF-8\n  // - The length of the payload_type field in bytes\n  // - The value of the payload_type field\n  // - The length of the payload field in bytes\n  // - The value of the payload field\n\n  const domainUint8Array = uint8arraysFromString(domain)\n  const domainLength = varint.encode(domainUint8Array.byteLength)\n  const payloadTypeLength = varint.encode(payloadType.length)\n  const payloadLength = varint.encode(payload.length)\n\n  return new Uint8ArrayList(\n    domainLength,\n    domainUint8Array,\n    payloadTypeLength,\n    payloadType,\n    payloadLength,\n    payload\n  )\n}\n", "/**\n * @packageDocumentation\n *\n * Provides strategies ensure arrays are equivalent.\n *\n * @example\n *\n * ```typescript\n * import { arrayEquals } from '@libp2p/utils/array-equals'\n * import { multiaddr } from '@multformats/multiaddr'\n *\n * const ma1 = multiaddr('/ip4/127.0.0.1/tcp/9000'),\n * const ma2 = multiaddr('/ip4/82.41.53.1/tcp/9000')\n *\n * console.info(arrayEquals([ma1], [ma1])) // true\n * console.info(arrayEquals([ma1], [ma2])) // false\n * ```\n */\n\n/**\n * Verify if two arrays of non primitive types with the \"equals\" function are equal.\n * Compatible with multiaddr, peer-id and others.\n */\nexport function arrayEquals (a: any[], b: any[]): boolean {\n  const sort = (a: any, b: any): number => a.toString().localeCompare(b.toString())\n\n  if (a.length !== b.length) {\n    return false\n  }\n\n  b.sort(sort)\n\n  return a.sort(sort).every((item, index) => b[index].equals(item))\n}\n", "// The domain string used for peer records contained in a Envelope.\nexport const ENVELOPE_DOMAIN_PEER_RECORD = 'libp2p-peer-record'\n\n// The type hint used to identify peer records in a Envelope.\n// Defined in https://github.com/multiformats/multicodec/blob/master/table.csv\n// with name \"libp2p-peer-record\"\nexport const ENVELOPE_PAYLOAD_TYPE_PEER_RECORD = Uint8Array.from([3, 1])\n", "/* eslint-disable import/export */\n/* eslint-disable complexity */\n/* eslint-disable @typescript-eslint/no-namespace */\n/* eslint-disable @typescript-eslint/no-unnecessary-boolean-literal-compare */\n/* eslint-disable @typescript-eslint/no-empty-interface */\n\nimport { encodeMessage, decodeMessage, message } from 'protons-runtime'\nimport type { Codec } from 'protons-runtime'\nimport type { Uint8ArrayList } from 'uint8arraylist'\n\nexport interface PeerRecord {\n  peerId: Uint8Array\n  seq: bigint\n  addresses: PeerRecord.AddressInfo[]\n}\n\nexport namespace PeerRecord {\n  export interface AddressInfo {\n    multiaddr: Uint8Array\n  }\n\n  export namespace AddressInfo {\n    let _codec: Codec<AddressInfo>\n\n    export const codec = (): Codec<AddressInfo> => {\n      if (_codec == null) {\n        _codec = message<AddressInfo>((obj, w, opts = {}) => {\n          if (opts.lengthDelimited !== false) {\n            w.fork()\n          }\n\n          if ((obj.multiaddr != null && obj.multiaddr.byteLength > 0)) {\n            w.uint32(10)\n            w.bytes(obj.multiaddr)\n          }\n\n          if (opts.lengthDelimited !== false) {\n            w.ldelim()\n          }\n        }, (reader, length) => {\n          const obj: any = {\n            multiaddr: new Uint8Array(0)\n          }\n\n          const end = length == null ? reader.len : reader.pos + length\n\n          while (reader.pos < end) {\n            const tag = reader.uint32()\n\n            switch (tag >>> 3) {\n              case 1:\n                obj.multiaddr = reader.bytes()\n                break\n              default:\n                reader.skipType(tag & 7)\n                break\n            }\n          }\n\n          return obj\n        })\n      }\n\n      return _codec\n    }\n\n    export const encode = (obj: Partial<AddressInfo>): Uint8Array => {\n      return encodeMessage(obj, AddressInfo.codec())\n    }\n\n    export const decode = (buf: Uint8Array | Uint8ArrayList): AddressInfo => {\n      return decodeMessage(buf, AddressInfo.codec())\n    }\n  }\n\n  let _codec: Codec<PeerRecord>\n\n  export const codec = (): Codec<PeerRecord> => {\n    if (_codec == null) {\n      _codec = message<PeerRecord>((obj, w, opts = {}) => {\n        if (opts.lengthDelimited !== false) {\n          w.fork()\n        }\n\n        if ((obj.peerId != null && obj.peerId.byteLength > 0)) {\n          w.uint32(10)\n          w.bytes(obj.peerId)\n        }\n\n        if ((obj.seq != null && obj.seq !== 0n)) {\n          w.uint32(16)\n          w.uint64(obj.seq)\n        }\n\n        if (obj.addresses != null) {\n          for (const value of obj.addresses) {\n            w.uint32(26)\n            PeerRecord.AddressInfo.codec().encode(value, w)\n          }\n        }\n\n        if (opts.lengthDelimited !== false) {\n          w.ldelim()\n        }\n      }, (reader, length) => {\n        const obj: any = {\n          peerId: new Uint8Array(0),\n          seq: 0n,\n          addresses: []\n        }\n\n        const end = length == null ? reader.len : reader.pos + length\n\n        while (reader.pos < end) {\n          const tag = reader.uint32()\n\n          switch (tag >>> 3) {\n            case 1:\n              obj.peerId = reader.bytes()\n              break\n            case 2:\n              obj.seq = reader.uint64()\n              break\n            case 3:\n              obj.addresses.push(PeerRecord.AddressInfo.codec().decode(reader, reader.uint32()))\n              break\n            default:\n              reader.skipType(tag & 7)\n              break\n          }\n        }\n\n        return obj\n      })\n    }\n\n    return _codec\n  }\n\n  export const encode = (obj: Partial<PeerRecord>): Uint8Array => {\n    return encodeMessage(obj, PeerRecord.codec())\n  }\n\n  export const decode = (buf: Uint8Array | Uint8ArrayList): PeerRecord => {\n    return decodeMessage(buf, PeerRecord.codec())\n  }\n}\n", "import { peerIdFromBytes } from '@libp2p/peer-id'\nimport { arrayEquals } from '@libp2p/utils/array-equals'\nimport { multiaddr } from '@multiformats/multiaddr'\nimport {\n  ENVELOPE_DOMAIN_PEER_RECORD,\n  ENVELOPE_PAYLOAD_TYPE_PEER_RECORD\n} from './consts.js'\nimport { PeerRecord as Protobuf } from './peer-record.js'\nimport type { PeerId } from '@libp2p/interface'\nimport type { Multiaddr } from '@multiformats/multiaddr'\nimport type { Uint8ArrayList } from 'uint8arraylist'\n\nexport interface PeerRecordInit {\n  peerId: PeerId\n\n  /**\n   * Addresses of the associated peer.\n   */\n  multiaddrs?: Multiaddr[]\n\n  /**\n   * Monotonically-increasing sequence counter that's used to order PeerRecords in time.\n   */\n  seqNumber?: bigint\n}\n\n/**\n * The PeerRecord is used for distributing peer routing records across the network.\n * It contains the peer's reachable listen addresses.\n */\nexport class PeerRecord {\n  /**\n   * Unmarshal Peer Record Protobuf\n   */\n  static createFromProtobuf = (buf: Uint8Array | Uint8ArrayList): PeerRecord => {\n    const peerRecord = Protobuf.decode(buf)\n    const peerId = peerIdFromBytes(peerRecord.peerId)\n    const multiaddrs = (peerRecord.addresses ?? []).map((a) => multiaddr(a.multiaddr))\n    const seqNumber = peerRecord.seq\n\n    return new PeerRecord({ peerId, multiaddrs, seqNumber })\n  }\n\n  static DOMAIN = ENVELOPE_DOMAIN_PEER_RECORD\n  static CODEC = ENVELOPE_PAYLOAD_TYPE_PEER_RECORD\n\n  public peerId: PeerId\n  public multiaddrs: Multiaddr[]\n  public seqNumber: bigint\n  public domain = PeerRecord.DOMAIN\n  public codec = PeerRecord.CODEC\n  private marshaled?: Uint8Array\n\n  constructor (init: PeerRecordInit) {\n    const { peerId, multiaddrs, seqNumber } = init\n\n    this.peerId = peerId\n    this.multiaddrs = multiaddrs ?? []\n    this.seqNumber = seqNumber ?? BigInt(Date.now())\n  }\n\n  /**\n   * Marshal a record to be used in an envelope\n   */\n  marshal (): Uint8Array {\n    if (this.marshaled == null) {\n      this.marshaled = Protobuf.encode({\n        peerId: this.peerId.toBytes(),\n        seq: BigInt(this.seqNumber),\n        addresses: this.multiaddrs.map((m) => ({\n          multiaddr: m.bytes\n        }))\n      })\n    }\n\n    return this.marshaled\n  }\n\n  /**\n   * Returns true if `this` record equals the `other`\n   */\n  equals (other: unknown): boolean {\n    if (!(other instanceof PeerRecord)) {\n      return false\n    }\n\n    // Validate PeerId\n    if (!this.peerId.equals(other.peerId)) {\n      return false\n    }\n\n    // Validate seqNumber\n    if (this.seqNumber !== other.seqNumber) {\n      return false\n    }\n\n    // Validate multiaddrs\n    if (!arrayEquals(this.multiaddrs, other.multiaddrs)) {\n      return false\n    }\n\n    return true\n  }\n}\n"],
  "mappings": "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",
  "names": ["Envelope", "a", "b", "PeerRecord", "AddressInfo", "_codec", "PeerRecord"]
}
