{
  "version": 3,
  "sources": ["../../ms/index.js", "../../debug/src/common.js", "../../debug/src/browser.js", "../../eventemitter3/index.js", "../../hashlru/index.js", "../../is-plain-obj/index.js", "../../merge-options/index.js", "../../@libp2p/logger/src/index.ts", "../../@libp2p/peer-id-factory/src/proto.ts", "../../@libp2p/peer-id-factory/src/index.ts", "../../it-all/src/index.ts", "../../eventemitter3/index.mjs", "../../p-queue/dist/lower-bound.js", "../../p-queue/dist/priority-queue.js", "../../p-queue/dist/index.js", "../../observable-webworkers/src/index.ts", "../../mortice/src/constants.ts", "../../mortice/src/utils.ts", "../../mortice/src/browser.ts", "../../mortice/src/index.ts", "../../@libp2p/peer-store/src/errors.ts", "../../@libp2p/peer-store/src/pb/peer.ts", "../../@libp2p/peer-store/src/utils/bytes-to-peer.ts", "../../interface-datastore/src/key.ts", "../../@libp2p/peer-store/src/utils/peer-id-to-datastore-key.ts", "../../@libp2p/peer-store/src/utils/dedupe-addresses.ts", "../../@libp2p/peer-store/src/utils/to-peer-pb.ts", "../../@libp2p/peer-store/src/store.ts", "../../@libp2p/peer-store/src/index.ts", "../../it-drain/src/index.ts", "../../it-filter/src/index.ts", "../../it-sort/src/index.ts", "../../it-take/src/index.ts", "../../datastore-core/src/base.ts", "../../datastore-core/src/errors.ts", "../../datastore-core/src/memory.ts", "../../libp2p/src/address-manager/utils.ts", "../../libp2p/src/address-manager/index.ts", "../../libp2p/src/components.ts", "../../libp2p/src/config/connection-gater.browser.ts", "../../@libp2p/utils/src/multiaddr/is-private.ts", "../../@libp2p/utils/src/address-sort.ts", "../../progress-events/src/index.ts", "../../@multiformats/dns/src/utils/get-types.ts", "../../@multiformats/dns/src/utils/to-dns-response.ts", "../../@multiformats/dns/src/resolvers/dns-json-over-https.ts", "../../@multiformats/dns/src/resolvers/default.browser.ts", "../../@multiformats/dns/src/utils/cache.ts", "../../@multiformats/dns/src/dns.ts", "../../@multiformats/dns/src/index.ts", "../../@multiformats/multiaddr/src/resolvers/dnsaddr.ts", "../../merge-options/index.mjs", "../../libp2p/src/errors.ts", "../../libp2p/src/config.ts", "../../@libp2p/utils/src/rate-limiter.ts", "../../libp2p/src/get-peer.ts", "../../libp2p/src/connection-manager/constants.defaults.ts", "../../libp2p/src/connection-manager/constants.browser.ts", "../../libp2p/src/connection-manager/auto-dial.ts", "../../libp2p/src/connection-manager/connection-pruner.ts", "../../libp2p/src/connection-manager/utils.ts", "../../libp2p/src/connection-manager/dial-queue.ts", "../../libp2p/src/connection-manager/index.ts", "../../libp2p/src/content-routing.ts", "../../it-parallel/src/index.ts", "../../libp2p/src/peer-routing.ts", "../../libp2p/src/random-walk.ts", "../../libp2p/src/registrar.ts", "../../@libp2p/utils/src/tracked-map.ts", "../../libp2p/src/transport-manager.ts", "../../@libp2p/multistream-select/src/constants.ts", "../../@libp2p/multistream-select/src/multistream.ts", "../../@libp2p/multistream-select/src/select.ts", "../../@libp2p/multistream-select/src/handle.ts", "../../libp2p/src/connection/index.ts", "../../libp2p/src/upgrader.ts", "../../libp2p/src/version.ts", "../../libp2p/src/libp2p.ts", "../../libp2p/src/index.ts"],
  "sourcesContent": ["/**\n * Helpers.\n */\n\nvar s = 1000;\nvar m = s * 60;\nvar h = m * 60;\nvar d = h * 24;\nvar w = d * 7;\nvar y = d * 365.25;\n\n/**\n * Parse or format the given `val`.\n *\n * Options:\n *\n *  - `long` verbose formatting [false]\n *\n * @param {String|Number} val\n * @param {Object} [options]\n * @throws {Error} throw an error if val is not a non-empty string or a number\n * @return {String|Number}\n * @api public\n */\n\nmodule.exports = function(val, options) {\n  options = options || {};\n  var type = typeof val;\n  if (type === 'string' && val.length > 0) {\n    return parse(val);\n  } else if (type === 'number' && isFinite(val)) {\n    return options.long ? fmtLong(val) : fmtShort(val);\n  }\n  throw new Error(\n    'val is not a non-empty string or a valid number. val=' +\n      JSON.stringify(val)\n  );\n};\n\n/**\n * Parse the given `str` and return milliseconds.\n *\n * @param {String} str\n * @return {Number}\n * @api private\n */\n\nfunction parse(str) {\n  str = String(str);\n  if (str.length > 100) {\n    return;\n  }\n  var match = /^(-?(?:\\d+)?\\.?\\d+) *(milliseconds?|msecs?|ms|seconds?|secs?|s|minutes?|mins?|m|hours?|hrs?|h|days?|d|weeks?|w|years?|yrs?|y)?$/i.exec(\n    str\n  );\n  if (!match) {\n    return;\n  }\n  var n = parseFloat(match[1]);\n  var type = (match[2] || 'ms').toLowerCase();\n  switch (type) {\n    case 'years':\n    case 'year':\n    case 'yrs':\n    case 'yr':\n    case 'y':\n      return n * y;\n    case 'weeks':\n    case 'week':\n    case 'w':\n      return n * w;\n    case 'days':\n    case 'day':\n    case 'd':\n      return n * d;\n    case 'hours':\n    case 'hour':\n    case 'hrs':\n    case 'hr':\n    case 'h':\n      return n * h;\n    case 'minutes':\n    case 'minute':\n    case 'mins':\n    case 'min':\n    case 'm':\n      return n * m;\n    case 'seconds':\n    case 'second':\n    case 'secs':\n    case 'sec':\n    case 's':\n      return n * s;\n    case 'milliseconds':\n    case 'millisecond':\n    case 'msecs':\n    case 'msec':\n    case 'ms':\n      return n;\n    default:\n      return undefined;\n  }\n}\n\n/**\n * Short format for `ms`.\n *\n * @param {Number} ms\n * @return {String}\n * @api private\n */\n\nfunction fmtShort(ms) {\n  var msAbs = Math.abs(ms);\n  if (msAbs >= d) {\n    return Math.round(ms / d) + 'd';\n  }\n  if (msAbs >= h) {\n    return Math.round(ms / h) + 'h';\n  }\n  if (msAbs >= m) {\n    return Math.round(ms / m) + 'm';\n  }\n  if (msAbs >= s) {\n    return Math.round(ms / s) + 's';\n  }\n  return ms + 'ms';\n}\n\n/**\n * Long format for `ms`.\n *\n * @param {Number} ms\n * @return {String}\n * @api private\n */\n\nfunction fmtLong(ms) {\n  var msAbs = Math.abs(ms);\n  if (msAbs >= d) {\n    return plural(ms, msAbs, d, 'day');\n  }\n  if (msAbs >= h) {\n    return plural(ms, msAbs, h, 'hour');\n  }\n  if (msAbs >= m) {\n    return plural(ms, msAbs, m, 'minute');\n  }\n  if (msAbs >= s) {\n    return plural(ms, msAbs, s, 'second');\n  }\n  return ms + ' ms';\n}\n\n/**\n * Pluralization helper.\n */\n\nfunction plural(ms, msAbs, n, name) {\n  var isPlural = msAbs >= n * 1.5;\n  return Math.round(ms / n) + ' ' + name + (isPlural ? 's' : '');\n}\n", "\n/**\n * This is the common logic for both the Node.js and web browser\n * implementations of `debug()`.\n */\n\nfunction setup(env) {\n\tcreateDebug.debug = createDebug;\n\tcreateDebug.default = createDebug;\n\tcreateDebug.coerce = coerce;\n\tcreateDebug.disable = disable;\n\tcreateDebug.enable = enable;\n\tcreateDebug.enabled = enabled;\n\tcreateDebug.humanize = require('ms');\n\tcreateDebug.destroy = destroy;\n\n\tObject.keys(env).forEach(key => {\n\t\tcreateDebug[key] = env[key];\n\t});\n\n\t/**\n\t* The currently active debug mode names, and names to skip.\n\t*/\n\n\tcreateDebug.names = [];\n\tcreateDebug.skips = [];\n\n\t/**\n\t* Map of special \"%n\" handling functions, for the debug \"format\" argument.\n\t*\n\t* Valid key names are a single, lower or upper-case letter, i.e. \"n\" and \"N\".\n\t*/\n\tcreateDebug.formatters = {};\n\n\t/**\n\t* Selects a color for a debug namespace\n\t* @param {String} namespace The namespace string for the debug instance to be colored\n\t* @return {Number|String} An ANSI color code for the given namespace\n\t* @api private\n\t*/\n\tfunction selectColor(namespace) {\n\t\tlet hash = 0;\n\n\t\tfor (let i = 0; i < namespace.length; i++) {\n\t\t\thash = ((hash << 5) - hash) + namespace.charCodeAt(i);\n\t\t\thash |= 0; // Convert to 32bit integer\n\t\t}\n\n\t\treturn createDebug.colors[Math.abs(hash) % createDebug.colors.length];\n\t}\n\tcreateDebug.selectColor = selectColor;\n\n\t/**\n\t* Create a debugger with the given `namespace`.\n\t*\n\t* @param {String} namespace\n\t* @return {Function}\n\t* @api public\n\t*/\n\tfunction createDebug(namespace) {\n\t\tlet prevTime;\n\t\tlet enableOverride = null;\n\t\tlet namespacesCache;\n\t\tlet enabledCache;\n\n\t\tfunction debug(...args) {\n\t\t\t// Disabled?\n\t\t\tif (!debug.enabled) {\n\t\t\t\treturn;\n\t\t\t}\n\n\t\t\tconst self = debug;\n\n\t\t\t// Set `diff` timestamp\n\t\t\tconst curr = Number(new Date());\n\t\t\tconst ms = curr - (prevTime || curr);\n\t\t\tself.diff = ms;\n\t\t\tself.prev = prevTime;\n\t\t\tself.curr = curr;\n\t\t\tprevTime = curr;\n\n\t\t\targs[0] = createDebug.coerce(args[0]);\n\n\t\t\tif (typeof args[0] !== 'string') {\n\t\t\t\t// Anything else let's inspect with %O\n\t\t\t\targs.unshift('%O');\n\t\t\t}\n\n\t\t\t// Apply any `formatters` transformations\n\t\t\tlet index = 0;\n\t\t\targs[0] = args[0].replace(/%([a-zA-Z%])/g, (match, format) => {\n\t\t\t\t// If we encounter an escaped % then don't increase the array index\n\t\t\t\tif (match === '%%') {\n\t\t\t\t\treturn '%';\n\t\t\t\t}\n\t\t\t\tindex++;\n\t\t\t\tconst formatter = createDebug.formatters[format];\n\t\t\t\tif (typeof formatter === 'function') {\n\t\t\t\t\tconst val = args[index];\n\t\t\t\t\tmatch = formatter.call(self, val);\n\n\t\t\t\t\t// Now we need to remove `args[index]` since it's inlined in the `format`\n\t\t\t\t\targs.splice(index, 1);\n\t\t\t\t\tindex--;\n\t\t\t\t}\n\t\t\t\treturn match;\n\t\t\t});\n\n\t\t\t// Apply env-specific formatting (colors, etc.)\n\t\t\tcreateDebug.formatArgs.call(self, args);\n\n\t\t\tconst logFn = self.log || createDebug.log;\n\t\t\tlogFn.apply(self, args);\n\t\t}\n\n\t\tdebug.namespace = namespace;\n\t\tdebug.useColors = createDebug.useColors();\n\t\tdebug.color = createDebug.selectColor(namespace);\n\t\tdebug.extend = extend;\n\t\tdebug.destroy = createDebug.destroy; // XXX Temporary. Will be removed in the next major release.\n\n\t\tObject.defineProperty(debug, 'enabled', {\n\t\t\tenumerable: true,\n\t\t\tconfigurable: false,\n\t\t\tget: () => {\n\t\t\t\tif (enableOverride !== null) {\n\t\t\t\t\treturn enableOverride;\n\t\t\t\t}\n\t\t\t\tif (namespacesCache !== createDebug.namespaces) {\n\t\t\t\t\tnamespacesCache = createDebug.namespaces;\n\t\t\t\t\tenabledCache = createDebug.enabled(namespace);\n\t\t\t\t}\n\n\t\t\t\treturn enabledCache;\n\t\t\t},\n\t\t\tset: v => {\n\t\t\t\tenableOverride = v;\n\t\t\t}\n\t\t});\n\n\t\t// Env-specific initialization logic for debug instances\n\t\tif (typeof createDebug.init === 'function') {\n\t\t\tcreateDebug.init(debug);\n\t\t}\n\n\t\treturn debug;\n\t}\n\n\tfunction extend(namespace, delimiter) {\n\t\tconst newDebug = createDebug(this.namespace + (typeof delimiter === 'undefined' ? ':' : delimiter) + namespace);\n\t\tnewDebug.log = this.log;\n\t\treturn newDebug;\n\t}\n\n\t/**\n\t* Enables a debug mode by namespaces. This can include modes\n\t* separated by a colon and wildcards.\n\t*\n\t* @param {String} namespaces\n\t* @api public\n\t*/\n\tfunction enable(namespaces) {\n\t\tcreateDebug.save(namespaces);\n\t\tcreateDebug.namespaces = namespaces;\n\n\t\tcreateDebug.names = [];\n\t\tcreateDebug.skips = [];\n\n\t\tlet i;\n\t\tconst split = (typeof namespaces === 'string' ? namespaces : '').split(/[\\s,]+/);\n\t\tconst len = split.length;\n\n\t\tfor (i = 0; i < len; i++) {\n\t\t\tif (!split[i]) {\n\t\t\t\t// ignore empty strings\n\t\t\t\tcontinue;\n\t\t\t}\n\n\t\t\tnamespaces = split[i].replace(/\\*/g, '.*?');\n\n\t\t\tif (namespaces[0] === '-') {\n\t\t\t\tcreateDebug.skips.push(new RegExp('^' + namespaces.slice(1) + '$'));\n\t\t\t} else {\n\t\t\t\tcreateDebug.names.push(new RegExp('^' + namespaces + '$'));\n\t\t\t}\n\t\t}\n\t}\n\n\t/**\n\t* Disable debug output.\n\t*\n\t* @return {String} namespaces\n\t* @api public\n\t*/\n\tfunction disable() {\n\t\tconst namespaces = [\n\t\t\t...createDebug.names.map(toNamespace),\n\t\t\t...createDebug.skips.map(toNamespace).map(namespace => '-' + namespace)\n\t\t].join(',');\n\t\tcreateDebug.enable('');\n\t\treturn namespaces;\n\t}\n\n\t/**\n\t* Returns true if the given mode name is enabled, false otherwise.\n\t*\n\t* @param {String} name\n\t* @return {Boolean}\n\t* @api public\n\t*/\n\tfunction enabled(name) {\n\t\tif (name[name.length - 1] === '*') {\n\t\t\treturn true;\n\t\t}\n\n\t\tlet i;\n\t\tlet len;\n\n\t\tfor (i = 0, len = createDebug.skips.length; i < len; i++) {\n\t\t\tif (createDebug.skips[i].test(name)) {\n\t\t\t\treturn false;\n\t\t\t}\n\t\t}\n\n\t\tfor (i = 0, len = createDebug.names.length; i < len; i++) {\n\t\t\tif (createDebug.names[i].test(name)) {\n\t\t\t\treturn true;\n\t\t\t}\n\t\t}\n\n\t\treturn false;\n\t}\n\n\t/**\n\t* Convert regexp to namespace\n\t*\n\t* @param {RegExp} regxep\n\t* @return {String} namespace\n\t* @api private\n\t*/\n\tfunction toNamespace(regexp) {\n\t\treturn regexp.toString()\n\t\t\t.substring(2, regexp.toString().length - 2)\n\t\t\t.replace(/\\.\\*\\?$/, '*');\n\t}\n\n\t/**\n\t* Coerce `val`.\n\t*\n\t* @param {Mixed} val\n\t* @return {Mixed}\n\t* @api private\n\t*/\n\tfunction coerce(val) {\n\t\tif (val instanceof Error) {\n\t\t\treturn val.stack || val.message;\n\t\t}\n\t\treturn val;\n\t}\n\n\t/**\n\t* XXX DO NOT USE. This is a temporary stub function.\n\t* XXX It WILL be removed in the next major release.\n\t*/\n\tfunction destroy() {\n\t\tconsole.warn('Instance method `debug.destroy()` is deprecated and no longer does anything. It will be removed in the next major version of `debug`.');\n\t}\n\n\tcreateDebug.enable(createDebug.load());\n\n\treturn createDebug;\n}\n\nmodule.exports = setup;\n", "/* eslint-env browser */\n\n/**\n * This is the web browser implementation of `debug()`.\n */\n\nexports.formatArgs = formatArgs;\nexports.save = save;\nexports.load = load;\nexports.useColors = useColors;\nexports.storage = localstorage();\nexports.destroy = (() => {\n\tlet warned = false;\n\n\treturn () => {\n\t\tif (!warned) {\n\t\t\twarned = true;\n\t\t\tconsole.warn('Instance method `debug.destroy()` is deprecated and no longer does anything. It will be removed in the next major version of `debug`.');\n\t\t}\n\t};\n})();\n\n/**\n * Colors.\n */\n\nexports.colors = [\n\t'#0000CC',\n\t'#0000FF',\n\t'#0033CC',\n\t'#0033FF',\n\t'#0066CC',\n\t'#0066FF',\n\t'#0099CC',\n\t'#0099FF',\n\t'#00CC00',\n\t'#00CC33',\n\t'#00CC66',\n\t'#00CC99',\n\t'#00CCCC',\n\t'#00CCFF',\n\t'#3300CC',\n\t'#3300FF',\n\t'#3333CC',\n\t'#3333FF',\n\t'#3366CC',\n\t'#3366FF',\n\t'#3399CC',\n\t'#3399FF',\n\t'#33CC00',\n\t'#33CC33',\n\t'#33CC66',\n\t'#33CC99',\n\t'#33CCCC',\n\t'#33CCFF',\n\t'#6600CC',\n\t'#6600FF',\n\t'#6633CC',\n\t'#6633FF',\n\t'#66CC00',\n\t'#66CC33',\n\t'#9900CC',\n\t'#9900FF',\n\t'#9933CC',\n\t'#9933FF',\n\t'#99CC00',\n\t'#99CC33',\n\t'#CC0000',\n\t'#CC0033',\n\t'#CC0066',\n\t'#CC0099',\n\t'#CC00CC',\n\t'#CC00FF',\n\t'#CC3300',\n\t'#CC3333',\n\t'#CC3366',\n\t'#CC3399',\n\t'#CC33CC',\n\t'#CC33FF',\n\t'#CC6600',\n\t'#CC6633',\n\t'#CC9900',\n\t'#CC9933',\n\t'#CCCC00',\n\t'#CCCC33',\n\t'#FF0000',\n\t'#FF0033',\n\t'#FF0066',\n\t'#FF0099',\n\t'#FF00CC',\n\t'#FF00FF',\n\t'#FF3300',\n\t'#FF3333',\n\t'#FF3366',\n\t'#FF3399',\n\t'#FF33CC',\n\t'#FF33FF',\n\t'#FF6600',\n\t'#FF6633',\n\t'#FF9900',\n\t'#FF9933',\n\t'#FFCC00',\n\t'#FFCC33'\n];\n\n/**\n * Currently only WebKit-based Web Inspectors, Firefox >= v31,\n * and the Firebug extension (any Firefox version) are known\n * to support \"%c\" CSS customizations.\n *\n * TODO: add a `localStorage` variable to explicitly enable/disable colors\n */\n\n// eslint-disable-next-line complexity\nfunction useColors() {\n\t// NB: In an Electron preload script, document will be defined but not fully\n\t// initialized. Since we know we're in Chrome, we'll just detect this case\n\t// explicitly\n\tif (typeof window !== 'undefined' && window.process && (window.process.type === 'renderer' || window.process.__nwjs)) {\n\t\treturn true;\n\t}\n\n\t// Internet Explorer and Edge do not support colors.\n\tif (typeof navigator !== 'undefined' && navigator.userAgent && navigator.userAgent.toLowerCase().match(/(edge|trident)\\/(\\d+)/)) {\n\t\treturn false;\n\t}\n\n\t// Is webkit? http://stackoverflow.com/a/16459606/376773\n\t// document is undefined in react-native: https://github.com/facebook/react-native/pull/1632\n\treturn (typeof document !== 'undefined' && document.documentElement && document.documentElement.style && document.documentElement.style.WebkitAppearance) ||\n\t\t// Is firebug? http://stackoverflow.com/a/398120/376773\n\t\t(typeof window !== 'undefined' && window.console && (window.console.firebug || (window.console.exception && window.console.table))) ||\n\t\t// Is firefox >= v31?\n\t\t// https://developer.mozilla.org/en-US/docs/Tools/Web_Console#Styling_messages\n\t\t(typeof navigator !== 'undefined' && navigator.userAgent && navigator.userAgent.toLowerCase().match(/firefox\\/(\\d+)/) && parseInt(RegExp.$1, 10) >= 31) ||\n\t\t// Double check webkit in userAgent just in case we are in a worker\n\t\t(typeof navigator !== 'undefined' && navigator.userAgent && navigator.userAgent.toLowerCase().match(/applewebkit\\/(\\d+)/));\n}\n\n/**\n * Colorize log arguments if enabled.\n *\n * @api public\n */\n\nfunction formatArgs(args) {\n\targs[0] = (this.useColors ? '%c' : '') +\n\t\tthis.namespace +\n\t\t(this.useColors ? ' %c' : ' ') +\n\t\targs[0] +\n\t\t(this.useColors ? '%c ' : ' ') +\n\t\t'+' + module.exports.humanize(this.diff);\n\n\tif (!this.useColors) {\n\t\treturn;\n\t}\n\n\tconst c = 'color: ' + this.color;\n\targs.splice(1, 0, c, 'color: inherit');\n\n\t// The final \"%c\" is somewhat tricky, because there could be other\n\t// arguments passed either before or after the %c, so we need to\n\t// figure out the correct index to insert the CSS into\n\tlet index = 0;\n\tlet lastC = 0;\n\targs[0].replace(/%[a-zA-Z%]/g, match => {\n\t\tif (match === '%%') {\n\t\t\treturn;\n\t\t}\n\t\tindex++;\n\t\tif (match === '%c') {\n\t\t\t// We only are interested in the *last* %c\n\t\t\t// (the user may have provided their own)\n\t\t\tlastC = index;\n\t\t}\n\t});\n\n\targs.splice(lastC, 0, c);\n}\n\n/**\n * Invokes `console.debug()` when available.\n * No-op when `console.debug` is not a \"function\".\n * If `console.debug` is not available, falls back\n * to `console.log`.\n *\n * @api public\n */\nexports.log = console.debug || console.log || (() => {});\n\n/**\n * Save `namespaces`.\n *\n * @param {String} namespaces\n * @api private\n */\nfunction save(namespaces) {\n\ttry {\n\t\tif (namespaces) {\n\t\t\texports.storage.setItem('debug', namespaces);\n\t\t} else {\n\t\t\texports.storage.removeItem('debug');\n\t\t}\n\t} catch (error) {\n\t\t// Swallow\n\t\t// XXX (@Qix-) should we be logging these?\n\t}\n}\n\n/**\n * Load `namespaces`.\n *\n * @return {String} returns the previously persisted debug modes\n * @api private\n */\nfunction load() {\n\tlet r;\n\ttry {\n\t\tr = exports.storage.getItem('debug');\n\t} catch (error) {\n\t\t// Swallow\n\t\t// XXX (@Qix-) should we be logging these?\n\t}\n\n\t// If debug isn't set in LS, and we're in Electron, try to load $DEBUG\n\tif (!r && typeof process !== 'undefined' && 'env' in process) {\n\t\tr = process.env.DEBUG;\n\t}\n\n\treturn r;\n}\n\n/**\n * Localstorage attempts to return the localstorage.\n *\n * This is necessary because safari throws\n * when a user disables cookies/localstorage\n * and you attempt to access it.\n *\n * @return {LocalStorage}\n * @api private\n */\n\nfunction localstorage() {\n\ttry {\n\t\t// TVMLKit (Apple TV JS Runtime) does not have a window object, just localStorage in the global context\n\t\t// The Browser also has localStorage in the global context.\n\t\treturn localStorage;\n\t} catch (error) {\n\t\t// Swallow\n\t\t// XXX (@Qix-) should we be logging these?\n\t}\n}\n\nmodule.exports = require('./common')(exports);\n\nconst {formatters} = module.exports;\n\n/**\n * Map %j to `JSON.stringify()`, since no Web Inspectors do that by default.\n */\n\nformatters.j = function (v) {\n\ttry {\n\t\treturn JSON.stringify(v);\n\t} catch (error) {\n\t\treturn '[UnexpectedJSONParseError]: ' + error.message;\n\t}\n};\n", "'use strict';\n\nvar has = Object.prototype.hasOwnProperty\n  , prefix = '~';\n\n/**\n * Constructor to create a storage for our `EE` objects.\n * An `Events` instance is a plain object whose properties are event names.\n *\n * @constructor\n * @private\n */\nfunction Events() {}\n\n//\n// We try to not inherit from `Object.prototype`. In some engines creating an\n// instance in this way is faster than calling `Object.create(null)` directly.\n// If `Object.create(null)` is not supported we prefix the event names with a\n// character to make sure that the built-in object properties are not\n// overridden or used as an attack vector.\n//\nif (Object.create) {\n  Events.prototype = Object.create(null);\n\n  //\n  // This hack is needed because the `__proto__` property is still inherited in\n  // some old browsers like Android 4, iPhone 5.1, Opera 11 and Safari 5.\n  //\n  if (!new Events().__proto__) prefix = false;\n}\n\n/**\n * Representation of a single event listener.\n *\n * @param {Function} fn The listener function.\n * @param {*} context The context to invoke the listener with.\n * @param {Boolean} [once=false] Specify if the listener is a one-time listener.\n * @constructor\n * @private\n */\nfunction EE(fn, context, once) {\n  this.fn = fn;\n  this.context = context;\n  this.once = once || false;\n}\n\n/**\n * Add a listener for a given event.\n *\n * @param {EventEmitter} emitter Reference to the `EventEmitter` instance.\n * @param {(String|Symbol)} event The event name.\n * @param {Function} fn The listener function.\n * @param {*} context The context to invoke the listener with.\n * @param {Boolean} once Specify if the listener is a one-time listener.\n * @returns {EventEmitter}\n * @private\n */\nfunction addListener(emitter, event, fn, context, once) {\n  if (typeof fn !== 'function') {\n    throw new TypeError('The listener must be a function');\n  }\n\n  var listener = new EE(fn, context || emitter, once)\n    , evt = prefix ? prefix + event : event;\n\n  if (!emitter._events[evt]) emitter._events[evt] = listener, emitter._eventsCount++;\n  else if (!emitter._events[evt].fn) emitter._events[evt].push(listener);\n  else emitter._events[evt] = [emitter._events[evt], listener];\n\n  return emitter;\n}\n\n/**\n * Clear event by name.\n *\n * @param {EventEmitter} emitter Reference to the `EventEmitter` instance.\n * @param {(String|Symbol)} evt The Event name.\n * @private\n */\nfunction clearEvent(emitter, evt) {\n  if (--emitter._eventsCount === 0) emitter._events = new Events();\n  else delete emitter._events[evt];\n}\n\n/**\n * Minimal `EventEmitter` interface that is molded against the Node.js\n * `EventEmitter` interface.\n *\n * @constructor\n * @public\n */\nfunction EventEmitter() {\n  this._events = new Events();\n  this._eventsCount = 0;\n}\n\n/**\n * Return an array listing the events for which the emitter has registered\n * listeners.\n *\n * @returns {Array}\n * @public\n */\nEventEmitter.prototype.eventNames = function eventNames() {\n  var names = []\n    , events\n    , name;\n\n  if (this._eventsCount === 0) return names;\n\n  for (name in (events = this._events)) {\n    if (has.call(events, name)) names.push(prefix ? name.slice(1) : name);\n  }\n\n  if (Object.getOwnPropertySymbols) {\n    return names.concat(Object.getOwnPropertySymbols(events));\n  }\n\n  return names;\n};\n\n/**\n * Return the listeners registered for a given event.\n *\n * @param {(String|Symbol)} event The event name.\n * @returns {Array} The registered listeners.\n * @public\n */\nEventEmitter.prototype.listeners = function listeners(event) {\n  var evt = prefix ? prefix + event : event\n    , handlers = this._events[evt];\n\n  if (!handlers) return [];\n  if (handlers.fn) return [handlers.fn];\n\n  for (var i = 0, l = handlers.length, ee = new Array(l); i < l; i++) {\n    ee[i] = handlers[i].fn;\n  }\n\n  return ee;\n};\n\n/**\n * Return the number of listeners listening to a given event.\n *\n * @param {(String|Symbol)} event The event name.\n * @returns {Number} The number of listeners.\n * @public\n */\nEventEmitter.prototype.listenerCount = function listenerCount(event) {\n  var evt = prefix ? prefix + event : event\n    , listeners = this._events[evt];\n\n  if (!listeners) return 0;\n  if (listeners.fn) return 1;\n  return listeners.length;\n};\n\n/**\n * Calls each of the listeners registered for a given event.\n *\n * @param {(String|Symbol)} event The event name.\n * @returns {Boolean} `true` if the event had listeners, else `false`.\n * @public\n */\nEventEmitter.prototype.emit = function emit(event, a1, a2, a3, a4, a5) {\n  var evt = prefix ? prefix + event : event;\n\n  if (!this._events[evt]) return false;\n\n  var listeners = this._events[evt]\n    , len = arguments.length\n    , args\n    , i;\n\n  if (listeners.fn) {\n    if (listeners.once) this.removeListener(event, listeners.fn, undefined, true);\n\n    switch (len) {\n      case 1: return listeners.fn.call(listeners.context), true;\n      case 2: return listeners.fn.call(listeners.context, a1), true;\n      case 3: return listeners.fn.call(listeners.context, a1, a2), true;\n      case 4: return listeners.fn.call(listeners.context, a1, a2, a3), true;\n      case 5: return listeners.fn.call(listeners.context, a1, a2, a3, a4), true;\n      case 6: return listeners.fn.call(listeners.context, a1, a2, a3, a4, a5), true;\n    }\n\n    for (i = 1, args = new Array(len -1); i < len; i++) {\n      args[i - 1] = arguments[i];\n    }\n\n    listeners.fn.apply(listeners.context, args);\n  } else {\n    var length = listeners.length\n      , j;\n\n    for (i = 0; i < length; i++) {\n      if (listeners[i].once) this.removeListener(event, listeners[i].fn, undefined, true);\n\n      switch (len) {\n        case 1: listeners[i].fn.call(listeners[i].context); break;\n        case 2: listeners[i].fn.call(listeners[i].context, a1); break;\n        case 3: listeners[i].fn.call(listeners[i].context, a1, a2); break;\n        case 4: listeners[i].fn.call(listeners[i].context, a1, a2, a3); break;\n        default:\n          if (!args) for (j = 1, args = new Array(len -1); j < len; j++) {\n            args[j - 1] = arguments[j];\n          }\n\n          listeners[i].fn.apply(listeners[i].context, args);\n      }\n    }\n  }\n\n  return true;\n};\n\n/**\n * Add a listener for a given event.\n *\n * @param {(String|Symbol)} event The event name.\n * @param {Function} fn The listener function.\n * @param {*} [context=this] The context to invoke the listener with.\n * @returns {EventEmitter} `this`.\n * @public\n */\nEventEmitter.prototype.on = function on(event, fn, context) {\n  return addListener(this, event, fn, context, false);\n};\n\n/**\n * Add a one-time listener for a given event.\n *\n * @param {(String|Symbol)} event The event name.\n * @param {Function} fn The listener function.\n * @param {*} [context=this] The context to invoke the listener with.\n * @returns {EventEmitter} `this`.\n * @public\n */\nEventEmitter.prototype.once = function once(event, fn, context) {\n  return addListener(this, event, fn, context, true);\n};\n\n/**\n * Remove the listeners of a given event.\n *\n * @param {(String|Symbol)} event The event name.\n * @param {Function} fn Only remove the listeners that match this function.\n * @param {*} context Only remove the listeners that have this context.\n * @param {Boolean} once Only remove one-time listeners.\n * @returns {EventEmitter} `this`.\n * @public\n */\nEventEmitter.prototype.removeListener = function removeListener(event, fn, context, once) {\n  var evt = prefix ? prefix + event : event;\n\n  if (!this._events[evt]) return this;\n  if (!fn) {\n    clearEvent(this, evt);\n    return this;\n  }\n\n  var listeners = this._events[evt];\n\n  if (listeners.fn) {\n    if (\n      listeners.fn === fn &&\n      (!once || listeners.once) &&\n      (!context || listeners.context === context)\n    ) {\n      clearEvent(this, evt);\n    }\n  } else {\n    for (var i = 0, events = [], length = listeners.length; i < length; i++) {\n      if (\n        listeners[i].fn !== fn ||\n        (once && !listeners[i].once) ||\n        (context && listeners[i].context !== context)\n      ) {\n        events.push(listeners[i]);\n      }\n    }\n\n    //\n    // Reset the array, or remove it completely if we have no more listeners.\n    //\n    if (events.length) this._events[evt] = events.length === 1 ? events[0] : events;\n    else clearEvent(this, evt);\n  }\n\n  return this;\n};\n\n/**\n * Remove all listeners, or those of the specified event.\n *\n * @param {(String|Symbol)} [event] The event name.\n * @returns {EventEmitter} `this`.\n * @public\n */\nEventEmitter.prototype.removeAllListeners = function removeAllListeners(event) {\n  var evt;\n\n  if (event) {\n    evt = prefix ? prefix + event : event;\n    if (this._events[evt]) clearEvent(this, evt);\n  } else {\n    this._events = new Events();\n    this._eventsCount = 0;\n  }\n\n  return this;\n};\n\n//\n// Alias methods names because people roll like that.\n//\nEventEmitter.prototype.off = EventEmitter.prototype.removeListener;\nEventEmitter.prototype.addListener = EventEmitter.prototype.on;\n\n//\n// Expose the prefix.\n//\nEventEmitter.prefixed = prefix;\n\n//\n// Allow `EventEmitter` to be imported as module namespace.\n//\nEventEmitter.EventEmitter = EventEmitter;\n\n//\n// Expose the module.\n//\nif ('undefined' !== typeof module) {\n  module.exports = EventEmitter;\n}\n", "module.exports = function (max) {\n\n  if (!max) throw Error('hashlru must have a max value, of type number, greater than 0')\n\n  var size = 0, cache = Object.create(null), _cache = Object.create(null)\n\n  function update (key, value) {\n    cache[key] = value\n    size ++\n    if(size >= max) {\n      size = 0\n      _cache = cache\n      cache = Object.create(null)\n    }\n  }\n\n  return {\n    has: function (key) {\n      return cache[key] !== undefined || _cache[key] !== undefined\n    },\n    remove: function (key) {\n      if(cache[key] !== undefined)\n        cache[key] = undefined\n      if(_cache[key] !== undefined)\n        _cache[key] = undefined\n    },\n    get: function (key) {\n      var v = cache[key]\n      if(v !== undefined) return v\n      if((v = _cache[key]) !== undefined) {\n        update(key, v)\n        return v\n      }\n    },\n    set: function (key, value) {\n      if(cache[key] !== undefined) cache[key] = value\n      else update(key, value)\n    },\n    clear: function () {\n      cache = Object.create(null)\n      _cache = Object.create(null)\n    }\n  }\n}\n\n\n\n\n\n\n\n", "'use strict';\n\nmodule.exports = value => {\n\tif (Object.prototype.toString.call(value) !== '[object Object]') {\n\t\treturn false;\n\t}\n\n\tconst prototype = Object.getPrototypeOf(value);\n\treturn prototype === null || prototype === Object.prototype;\n};\n", "'use strict';\nconst isOptionObject = require('is-plain-obj');\n\nconst {hasOwnProperty} = Object.prototype;\nconst {propertyIsEnumerable} = Object;\nconst defineProperty = (object, name, value) => Object.defineProperty(object, name, {\n\tvalue,\n\twritable: true,\n\tenumerable: true,\n\tconfigurable: true\n});\n\nconst globalThis = this;\nconst defaultMergeOptions = {\n\tconcatArrays: false,\n\tignoreUndefined: false\n};\n\nconst getEnumerableOwnPropertyKeys = value => {\n\tconst keys = [];\n\n\tfor (const key in value) {\n\t\tif (hasOwnProperty.call(value, key)) {\n\t\t\tkeys.push(key);\n\t\t}\n\t}\n\n\t/* istanbul ignore else  */\n\tif (Object.getOwnPropertySymbols) {\n\t\tconst symbols = Object.getOwnPropertySymbols(value);\n\n\t\tfor (const symbol of symbols) {\n\t\t\tif (propertyIsEnumerable.call(value, symbol)) {\n\t\t\t\tkeys.push(symbol);\n\t\t\t}\n\t\t}\n\t}\n\n\treturn keys;\n};\n\nfunction clone(value) {\n\tif (Array.isArray(value)) {\n\t\treturn cloneArray(value);\n\t}\n\n\tif (isOptionObject(value)) {\n\t\treturn cloneOptionObject(value);\n\t}\n\n\treturn value;\n}\n\nfunction cloneArray(array) {\n\tconst result = array.slice(0, 0);\n\n\tgetEnumerableOwnPropertyKeys(array).forEach(key => {\n\t\tdefineProperty(result, key, clone(array[key]));\n\t});\n\n\treturn result;\n}\n\nfunction cloneOptionObject(object) {\n\tconst result = Object.getPrototypeOf(object) === null ? Object.create(null) : {};\n\n\tgetEnumerableOwnPropertyKeys(object).forEach(key => {\n\t\tdefineProperty(result, key, clone(object[key]));\n\t});\n\n\treturn result;\n}\n\n/**\n * @param {*} merged already cloned\n * @param {*} source something to merge\n * @param {string[]} keys keys to merge\n * @param {Object} config Config Object\n * @returns {*} cloned Object\n */\nconst mergeKeys = (merged, source, keys, config) => {\n\tkeys.forEach(key => {\n\t\tif (typeof source[key] === 'undefined' && config.ignoreUndefined) {\n\t\t\treturn;\n\t\t}\n\n\t\t// Do not recurse into prototype chain of merged\n\t\tif (key in merged && merged[key] !== Object.getPrototypeOf(merged)) {\n\t\t\tdefineProperty(merged, key, merge(merged[key], source[key], config));\n\t\t} else {\n\t\t\tdefineProperty(merged, key, clone(source[key]));\n\t\t}\n\t});\n\n\treturn merged;\n};\n\n/**\n * @param {*} merged already cloned\n * @param {*} source something to merge\n * @param {Object} config Config Object\n * @returns {*} cloned Object\n *\n * see [Array.prototype.concat ( ...arguments )](http://www.ecma-international.org/ecma-262/6.0/#sec-array.prototype.concat)\n */\nconst concatArrays = (merged, source, config) => {\n\tlet result = merged.slice(0, 0);\n\tlet resultIndex = 0;\n\n\t[merged, source].forEach(array => {\n\t\tconst indices = [];\n\n\t\t// `result.concat(array)` with cloning\n\t\tfor (let k = 0; k < array.length; k++) {\n\t\t\tif (!hasOwnProperty.call(array, k)) {\n\t\t\t\tcontinue;\n\t\t\t}\n\n\t\t\tindices.push(String(k));\n\n\t\t\tif (array === merged) {\n\t\t\t\t// Already cloned\n\t\t\t\tdefineProperty(result, resultIndex++, array[k]);\n\t\t\t} else {\n\t\t\t\tdefineProperty(result, resultIndex++, clone(array[k]));\n\t\t\t}\n\t\t}\n\n\t\t// Merge non-index keys\n\t\tresult = mergeKeys(result, array, getEnumerableOwnPropertyKeys(array).filter(key => !indices.includes(key)), config);\n\t});\n\n\treturn result;\n};\n\n/**\n * @param {*} merged already cloned\n * @param {*} source something to merge\n * @param {Object} config Config Object\n * @returns {*} cloned Object\n */\nfunction merge(merged, source, config) {\n\tif (config.concatArrays && Array.isArray(merged) && Array.isArray(source)) {\n\t\treturn concatArrays(merged, source, config);\n\t}\n\n\tif (!isOptionObject(source) || !isOptionObject(merged)) {\n\t\treturn clone(source);\n\t}\n\n\treturn mergeKeys(merged, source, getEnumerableOwnPropertyKeys(source), config);\n}\n\nmodule.exports = function (...options) {\n\tconst config = merge(clone(defaultMergeOptions), (this !== globalThis && this) || {}, defaultMergeOptions);\n\tlet merged = {_: {}};\n\n\tfor (const option of options) {\n\t\tif (option === undefined) {\n\t\t\tcontinue;\n\t\t}\n\n\t\tif (!isOptionObject(option)) {\n\t\t\tthrow new TypeError('`' + option + '` is not an Option Object');\n\t\t}\n\n\t\tmerged = merge(merged, {_: option}, config);\n\t}\n\n\treturn merged._;\n};\n", "/**\n * @packageDocumentation\n *\n * A logger for libp2p based on the venerable [debug](https://www.npmjs.com/package/debug) module.\n *\n * @example\n *\n * ```TypeScript\n * import { logger } from '@libp2p/logger'\n *\n * const log = logger('libp2p:my:component:name')\n *\n * try {\n *   // an operation\n *   log('something happened: %s', 'it was ok')\n * } catch (err) {\n *   log.error('something bad happened: %o', err)\n * }\n *\n * log('with this peer: %p', {})\n * log('and this base58btc: %b', Uint8Array.from([0, 1, 2, 3]))\n * log('and this base32: %t', Uint8Array.from([4, 5, 6, 7]))\n * ```\n *\n * ```console\n * $ DEBUG=libp2p:* node index.js\n * something happened: it was ok\n * something bad happened: <stack trace>\n * with this peer: 12D3Foo\n * with this base58btc: Qmfoo\n * with this base32: bafyfoo\n * ```\n */\n\nimport debug from 'debug'\nimport { base32 } from 'multiformats/bases/base32'\nimport { base58btc } from 'multiformats/bases/base58'\nimport { base64 } from 'multiformats/bases/base64'\nimport { truncatePeerId } from './utils.js'\nimport type { PeerId } from '@libp2p/interface'\nimport type { Multiaddr } from '@multiformats/multiaddr'\nimport type { Key } from 'interface-datastore'\nimport type { CID } from 'multiformats/cid'\n\n// Add a formatter for converting to a base58 string\ndebug.formatters.b = (v?: Uint8Array): string => {\n  return v == null ? 'undefined' : base58btc.baseEncode(v)\n}\n\n// Add a formatter for converting to a base32 string\ndebug.formatters.t = (v?: Uint8Array): string => {\n  return v == null ? 'undefined' : base32.baseEncode(v)\n}\n\n// Add a formatter for converting to a base64 string\ndebug.formatters.m = (v?: Uint8Array): string => {\n  return v == null ? 'undefined' : base64.baseEncode(v)\n}\n\n// Add a formatter for stringifying peer ids\ndebug.formatters.p = (v?: PeerId): string => {\n  return v == null ? 'undefined' : v.toString()\n}\n\n// Add a formatter for stringifying CIDs\ndebug.formatters.c = (v?: CID): string => {\n  return v == null ? 'undefined' : v.toString()\n}\n\n// Add a formatter for stringifying Datastore keys\ndebug.formatters.k = (v: Key): string => {\n  return v == null ? 'undefined' : v.toString()\n}\n\n// Add a formatter for stringifying Multiaddrs\ndebug.formatters.a = (v?: Multiaddr): string => {\n  return v == null ? 'undefined' : v.toString()\n}\n\nexport interface Logger {\n  (formatter: any, ...args: any[]): void\n  error(formatter: any, ...args: any[]): void\n  trace(formatter: any, ...args: any[]): void\n  enabled: boolean\n}\n\nexport interface ComponentLogger {\n  forComponent(name: string): Logger\n}\n\nfunction createDisabledLogger (namespace: string): debug.Debugger {\n  const logger = (): void => {}\n  logger.enabled = false\n  logger.color = ''\n  logger.diff = 0\n  logger.log = (): void => {}\n  logger.namespace = namespace\n  logger.destroy = () => true\n  logger.extend = () => logger\n\n  return logger\n}\n\nexport interface PeerLoggerOptions {\n  prefixLength: number\n  suffixLength: number\n}\n\n/**\n * Create a component logger that will prefix any log messages with a truncated\n * peer id.\n *\n * @example\n *\n * ```TypeScript\n * import { peerLogger } from '@libp2p/logger'\n * import { peerIdFromString } from '@libp2p/peer-id'\n *\n * const peerId = peerIdFromString('12D3FooBar')\n * const logger = peerLogger(peerId)\n *\n * const log = logger.forComponent('my-component')\n * log.info('hello world')\n * // logs \"12â€¦oBar:my-component hello world\"\n * ```\n */\nexport function peerLogger (peerId: PeerId, options: Partial<PeerLoggerOptions> = {}): ComponentLogger {\n  return prefixLogger(truncatePeerId(peerId, options))\n}\n\n/**\n * Create a component logger that will prefix any log messages with the passed\n * string.\n *\n * @example\n *\n * ```TypeScript\n * import { prefixLogger } from '@libp2p/logger'\n *\n * const logger = prefixLogger('my-node')\n *\n * const log = logger.forComponent('my-component')\n * log.info('hello world')\n * // logs \"my-node:my-component hello world\"\n * ```\n */\nexport function prefixLogger (prefix: string): ComponentLogger {\n  return {\n    forComponent (name: string) {\n      return logger(`${prefix}:${name}`)\n    }\n  }\n}\n\n/**\n * Create a component logger\n *\n * @example\n *\n * ```TypeScript\n * import { defaultLogger } from '@libp2p/logger'\n * import { peerIdFromString } from '@libp2p/peer-id'\n *\n * const logger = defaultLogger()\n *\n * const log = logger.forComponent('my-component')\n * log.info('hello world')\n * // logs \"my-component hello world\"\n * ```\n */\nexport function defaultLogger (): ComponentLogger {\n  return {\n    forComponent (name: string) {\n      return logger(name)\n    }\n  }\n}\n\n/**\n * Creates a logger for the passed component name.\n *\n * @example\n *\n * ```TypeScript\n * import { logger } from '@libp2p/logger'\n *\n * const log = logger('my-component')\n * log.info('hello world')\n * // logs \"my-component hello world\"\n * ```\n */\nexport function logger (name: string): Logger {\n  // trace logging is a no-op by default\n  let trace: debug.Debugger = createDisabledLogger(`${name}:trace`)\n\n  // look at all the debug names and see if trace logging has explicitly been enabled\n  if (debug.enabled(`${name}:trace`) && debug.names.map(r => r.toString()).find(n => n.includes(':trace')) != null) {\n    trace = debug(`${name}:trace`)\n  }\n\n  return Object.assign(debug(name), {\n    error: debug(`${name}:error`),\n    trace\n  })\n}\n\nexport function disable (): void {\n  debug.disable()\n}\n\nexport function enable (namespaces: string): void {\n  debug.enable(namespaces)\n}\n\nexport function enabled (namespaces: string): boolean {\n  return debug.enabled(namespaces)\n}\n", "/* eslint-disable import/export */\n/* eslint-disable complexity */\n/* eslint-disable @typescript-eslint/no-namespace */\n/* eslint-disable @typescript-eslint/no-unnecessary-boolean-literal-compare */\n/* eslint-disable @typescript-eslint/no-empty-interface */\n\nimport { encodeMessage, decodeMessage, message } from 'protons-runtime'\nimport type { Codec } from 'protons-runtime'\nimport type { Uint8ArrayList } from 'uint8arraylist'\n\nexport interface PeerIdProto {\n  id?: Uint8Array\n  pubKey?: Uint8Array\n  privKey?: Uint8Array\n}\n\nexport namespace PeerIdProto {\n  let _codec: Codec<PeerIdProto>\n\n  export const codec = (): Codec<PeerIdProto> => {\n    if (_codec == null) {\n      _codec = message<PeerIdProto>((obj, w, opts = {}) => {\n        if (opts.lengthDelimited !== false) {\n          w.fork()\n        }\n\n        if (obj.id != null) {\n          w.uint32(10)\n          w.bytes(obj.id)\n        }\n\n        if (obj.pubKey != null) {\n          w.uint32(18)\n          w.bytes(obj.pubKey)\n        }\n\n        if (obj.privKey != null) {\n          w.uint32(26)\n          w.bytes(obj.privKey)\n        }\n\n        if (opts.lengthDelimited !== false) {\n          w.ldelim()\n        }\n      }, (reader, length) => {\n        const obj: any = {}\n\n        const end = length == null ? reader.len : reader.pos + length\n\n        while (reader.pos < end) {\n          const tag = reader.uint32()\n\n          switch (tag >>> 3) {\n            case 1:\n              obj.id = reader.bytes()\n              break\n            case 2:\n              obj.pubKey = reader.bytes()\n              break\n            case 3:\n              obj.privKey = reader.bytes()\n              break\n            default:\n              reader.skipType(tag & 7)\n              break\n          }\n        }\n\n        return obj\n      })\n    }\n\n    return _codec\n  }\n\n  export const encode = (obj: Partial<PeerIdProto>): Uint8Array => {\n    return encodeMessage(obj, PeerIdProto.codec())\n  }\n\n  export const decode = (buf: Uint8Array | Uint8ArrayList): PeerIdProto => {\n    return decodeMessage(buf, PeerIdProto.codec())\n  }\n}\n", "/**\n * @packageDocumentation\n *\n * Generate, import, and export PeerIDs.\n *\n * A Peer ID is the SHA-256 [multihash](https://github.com/multiformats/multihash) of a public key.\n *\n * The public key is a base64 encoded string of a protobuf containing an RSA DER buffer. This uses a node buffer to pass the base64 encoded public key protobuf to the multihash for ID generation.\n *\n * @example\n *\n * ```TypeScript\n * import { createEd25519PeerId } from '@libp2p/peer-id-factory'\n *\n * const peerId = await createEd25519PeerId()\n * console.log(peerId.toString())\n * ```\n *\n * ```bash\n * 12D3KooWRm8J3iL796zPFi2EtGGtUJn58AG67gcqzMFHZnnsTzqD\n * ```\n */\n\nimport { generateKeyPair, marshalPrivateKey, unmarshalPrivateKey, marshalPublicKey, unmarshalPublicKey } from '@libp2p/crypto/keys'\nimport { peerIdFromKeys, peerIdFromBytes } from '@libp2p/peer-id'\nimport { fromString as uint8ArrayFromString } from 'uint8arrays/from-string'\nimport { PeerIdProto } from './proto.js'\nimport type { PublicKey, PrivateKey, RSAPeerId, Ed25519PeerId, Secp256k1PeerId, KeyType } from '@libp2p/interface'\n\nexport const createEd25519PeerId = async (): Promise<Ed25519PeerId> => {\n  const key = await generateKeyPair('Ed25519')\n  const id = await createFromPrivKey(key)\n\n  if (id.type === 'Ed25519') {\n    return id\n  }\n\n  throw new Error(`Generated unexpected PeerId type \"${id.type}\"`)\n}\n\nexport const createSecp256k1PeerId = async (): Promise<Secp256k1PeerId> => {\n  const key = await generateKeyPair('secp256k1')\n  const id = await createFromPrivKey(key)\n\n  if (id.type === 'secp256k1') {\n    return id\n  }\n\n  throw new Error(`Generated unexpected PeerId type \"${id.type}\"`)\n}\n\nexport const createRSAPeerId = async (opts?: { bits: number }): Promise<RSAPeerId> => {\n  const key = await generateKeyPair('RSA', opts?.bits ?? 2048)\n  const id = await createFromPrivKey(key)\n\n  if (id.type === 'RSA') {\n    return id\n  }\n\n  throw new Error(`Generated unexpected PeerId type \"${id.type}\"`)\n}\n\nexport async function createFromPubKey <T extends KeyType > (publicKey: PublicKey<T>): Promise<Ed25519PeerId | Secp256k1PeerId | RSAPeerId> {\n  return peerIdFromKeys(marshalPublicKey(publicKey))\n}\n\nexport async function createFromPrivKey <T extends KeyType > (privateKey: PrivateKey<T>): Promise<Ed25519PeerId | Secp256k1PeerId | RSAPeerId> {\n  return peerIdFromKeys(marshalPublicKey(privateKey.public), marshalPrivateKey(privateKey))\n}\n\nexport function exportToProtobuf (peerId: RSAPeerId | Ed25519PeerId | Secp256k1PeerId, excludePrivateKey?: boolean): Uint8Array {\n  return PeerIdProto.encode({\n    id: peerId.multihash.bytes,\n    pubKey: peerId.publicKey,\n    privKey: excludePrivateKey === true || peerId.privateKey == null ? undefined : peerId.privateKey\n  })\n}\n\nexport async function createFromProtobuf (buf: Uint8Array): Promise<Ed25519PeerId | Secp256k1PeerId | RSAPeerId> {\n  const {\n    id,\n    privKey,\n    pubKey\n  } = PeerIdProto.decode(buf)\n\n  return createFromParts(\n    id ?? new Uint8Array(0),\n    privKey,\n    pubKey\n  )\n}\n\nexport async function createFromJSON (obj: { id: string, privKey?: string, pubKey?: string }): Promise<Ed25519PeerId | Secp256k1PeerId | RSAPeerId> {\n  return createFromParts(\n    uint8ArrayFromString(obj.id, 'base58btc'),\n    obj.privKey != null ? uint8ArrayFromString(obj.privKey, 'base64pad') : undefined,\n    obj.pubKey != null ? uint8ArrayFromString(obj.pubKey, 'base64pad') : undefined\n  )\n}\n\nasync function createFromParts (multihash: Uint8Array, privKey?: Uint8Array, pubKey?: Uint8Array): Promise<Ed25519PeerId | Secp256k1PeerId | RSAPeerId> {\n  if (privKey != null) {\n    const key = await unmarshalPrivateKey(privKey)\n\n    return createFromPrivKey(key)\n  } else if (pubKey != null) {\n    const key = unmarshalPublicKey(pubKey)\n\n    return createFromPubKey(key)\n  }\n\n  return peerIdFromBytes(multihash)\n}\n", "/**\n * @packageDocumentation\n *\n * For when you need a one-liner to collect iterable values.\n *\n * @example\n *\n * ```javascript\n * import all from 'it-all'\n *\n * // This can also be an iterator, etc\n * const values = function * () {\n *   yield * [0, 1, 2, 3, 4]\n * }\n *\n * const arr = all(values)\n *\n * console.info(arr) // 0, 1, 2, 3, 4\n * ```\n *\n * Async sources must be awaited:\n *\n * ```javascript\n * const values = async function * () {\n *   yield * [0, 1, 2, 3, 4]\n * }\n *\n * const arr = await all(values())\n *\n * console.info(arr) // 0, 1, 2, 3, 4\n * ```\n */\n\nfunction isAsyncIterable <T> (thing: any): thing is AsyncIterable<T> {\n  return thing[Symbol.asyncIterator] != null\n}\n\n/**\n * Collects all values from an (async) iterable and returns them as an array\n */\nfunction all <T> (source: Iterable<T>): T[]\nfunction all <T> (source: Iterable<T> | AsyncIterable<T>): Promise<T[]>\nfunction all <T> (source: Iterable<T> | AsyncIterable<T>): Promise<T[]> | T[] {\n  if (isAsyncIterable(source)) {\n    return (async () => {\n      const arr = []\n\n      for await (const entry of source) {\n        arr.push(entry)\n      }\n\n      return arr\n    })()\n  }\n\n  const arr = []\n\n  for (const entry of source) {\n    arr.push(entry)\n  }\n\n  return arr\n}\n\nexport default all\n", "import EventEmitter from './index.js'\n\nexport { EventEmitter }\nexport default EventEmitter\n", "// Port of lower_bound from https://en.cppreference.com/w/cpp/algorithm/lower_bound\n// Used to compute insertion index to keep queue sorted after insertion\nexport default function lowerBound(array, value, comparator) {\n    let first = 0;\n    let count = array.length;\n    while (count > 0) {\n        const step = Math.trunc(count / 2);\n        let it = first + step;\n        if (comparator(array[it], value) <= 0) {\n            first = ++it;\n            count -= step + 1;\n        }\n        else {\n            count = step;\n        }\n    }\n    return first;\n}\n", "import lowerBound from './lower-bound.js';\nexport default class PriorityQueue {\n    #queue = [];\n    enqueue(run, options) {\n        options = {\n            priority: 0,\n            ...options,\n        };\n        const element = {\n            priority: options.priority,\n            run,\n        };\n        if (this.size && this.#queue[this.size - 1].priority >= options.priority) {\n            this.#queue.push(element);\n            return;\n        }\n        const index = lowerBound(this.#queue, element, (a, b) => b.priority - a.priority);\n        this.#queue.splice(index, 0, element);\n    }\n    dequeue() {\n        const item = this.#queue.shift();\n        return item?.run;\n    }\n    filter(options) {\n        return this.#queue.filter((element) => element.priority === options.priority).map((element) => element.run);\n    }\n    get size() {\n        return this.#queue.length;\n    }\n}\n", "import { EventEmitter } from 'eventemitter3';\nimport pTimeout, { TimeoutError } from 'p-timeout';\nimport PriorityQueue from './priority-queue.js';\n/**\nPromise queue with concurrency control.\n*/\nexport default class PQueue extends EventEmitter {\n    #carryoverConcurrencyCount;\n    #isIntervalIgnored;\n    #intervalCount = 0;\n    #intervalCap;\n    #interval;\n    #intervalEnd = 0;\n    #intervalId;\n    #timeoutId;\n    #queue;\n    #queueClass;\n    #pending = 0;\n    // The `!` is needed because of https://github.com/microsoft/TypeScript/issues/32194\n    #concurrency;\n    #isPaused;\n    #throwOnTimeout;\n    /**\n    Per-operation timeout in milliseconds. Operations fulfill once `timeout` elapses if they haven't already.\n\n    Applies to each future operation.\n    */\n    timeout;\n    // TODO: The `throwOnTimeout` option should affect the return types of `add()` and `addAll()`\n    constructor(options) {\n        super();\n        // eslint-disable-next-line @typescript-eslint/consistent-type-assertions\n        options = {\n            carryoverConcurrencyCount: false,\n            intervalCap: Number.POSITIVE_INFINITY,\n            interval: 0,\n            concurrency: Number.POSITIVE_INFINITY,\n            autoStart: true,\n            queueClass: PriorityQueue,\n            ...options,\n        };\n        if (!(typeof options.intervalCap === 'number' && options.intervalCap >= 1)) {\n            throw new TypeError(`Expected \\`intervalCap\\` to be a number from 1 and up, got \\`${options.intervalCap?.toString() ?? ''}\\` (${typeof options.intervalCap})`);\n        }\n        if (options.interval === undefined || !(Number.isFinite(options.interval) && options.interval >= 0)) {\n            throw new TypeError(`Expected \\`interval\\` to be a finite number >= 0, got \\`${options.interval?.toString() ?? ''}\\` (${typeof options.interval})`);\n        }\n        this.#carryoverConcurrencyCount = options.carryoverConcurrencyCount;\n        this.#isIntervalIgnored = options.intervalCap === Number.POSITIVE_INFINITY || options.interval === 0;\n        this.#intervalCap = options.intervalCap;\n        this.#interval = options.interval;\n        this.#queue = new options.queueClass();\n        this.#queueClass = options.queueClass;\n        this.concurrency = options.concurrency;\n        this.timeout = options.timeout;\n        this.#throwOnTimeout = options.throwOnTimeout === true;\n        this.#isPaused = options.autoStart === false;\n    }\n    get #doesIntervalAllowAnother() {\n        return this.#isIntervalIgnored || this.#intervalCount < this.#intervalCap;\n    }\n    get #doesConcurrentAllowAnother() {\n        return this.#pending < this.#concurrency;\n    }\n    #next() {\n        this.#pending--;\n        this.#tryToStartAnother();\n        this.emit('next');\n    }\n    #onResumeInterval() {\n        this.#onInterval();\n        this.#initializeIntervalIfNeeded();\n        this.#timeoutId = undefined;\n    }\n    get #isIntervalPaused() {\n        const now = Date.now();\n        if (this.#intervalId === undefined) {\n            const delay = this.#intervalEnd - now;\n            if (delay < 0) {\n                // Act as the interval was done\n                // We don't need to resume it here because it will be resumed on line 160\n                this.#intervalCount = (this.#carryoverConcurrencyCount) ? this.#pending : 0;\n            }\n            else {\n                // Act as the interval is pending\n                if (this.#timeoutId === undefined) {\n                    this.#timeoutId = setTimeout(() => {\n                        this.#onResumeInterval();\n                    }, delay);\n                }\n                return true;\n            }\n        }\n        return false;\n    }\n    #tryToStartAnother() {\n        if (this.#queue.size === 0) {\n            // We can clear the interval (\"pause\")\n            // Because we can redo it later (\"resume\")\n            if (this.#intervalId) {\n                clearInterval(this.#intervalId);\n            }\n            this.#intervalId = undefined;\n            this.emit('empty');\n            if (this.#pending === 0) {\n                this.emit('idle');\n            }\n            return false;\n        }\n        if (!this.#isPaused) {\n            const canInitializeInterval = !this.#isIntervalPaused;\n            if (this.#doesIntervalAllowAnother && this.#doesConcurrentAllowAnother) {\n                const job = this.#queue.dequeue();\n                if (!job) {\n                    return false;\n                }\n                this.emit('active');\n                job();\n                if (canInitializeInterval) {\n                    this.#initializeIntervalIfNeeded();\n                }\n                return true;\n            }\n        }\n        return false;\n    }\n    #initializeIntervalIfNeeded() {\n        if (this.#isIntervalIgnored || this.#intervalId !== undefined) {\n            return;\n        }\n        this.#intervalId = setInterval(() => {\n            this.#onInterval();\n        }, this.#interval);\n        this.#intervalEnd = Date.now() + this.#interval;\n    }\n    #onInterval() {\n        if (this.#intervalCount === 0 && this.#pending === 0 && this.#intervalId) {\n            clearInterval(this.#intervalId);\n            this.#intervalId = undefined;\n        }\n        this.#intervalCount = this.#carryoverConcurrencyCount ? this.#pending : 0;\n        this.#processQueue();\n    }\n    /**\n    Executes all queued functions until it reaches the limit.\n    */\n    #processQueue() {\n        // eslint-disable-next-line no-empty\n        while (this.#tryToStartAnother()) { }\n    }\n    get concurrency() {\n        return this.#concurrency;\n    }\n    set concurrency(newConcurrency) {\n        if (!(typeof newConcurrency === 'number' && newConcurrency >= 1)) {\n            throw new TypeError(`Expected \\`concurrency\\` to be a number from 1 and up, got \\`${newConcurrency}\\` (${typeof newConcurrency})`);\n        }\n        this.#concurrency = newConcurrency;\n        this.#processQueue();\n    }\n    async #throwOnAbort(signal) {\n        return new Promise((_resolve, reject) => {\n            signal.addEventListener('abort', () => {\n                reject(signal.reason);\n            }, { once: true });\n        });\n    }\n    async add(function_, options = {}) {\n        options = {\n            timeout: this.timeout,\n            throwOnTimeout: this.#throwOnTimeout,\n            ...options,\n        };\n        return new Promise((resolve, reject) => {\n            this.#queue.enqueue(async () => {\n                this.#pending++;\n                this.#intervalCount++;\n                try {\n                    options.signal?.throwIfAborted();\n                    let operation = function_({ signal: options.signal });\n                    if (options.timeout) {\n                        operation = pTimeout(Promise.resolve(operation), { milliseconds: options.timeout });\n                    }\n                    if (options.signal) {\n                        operation = Promise.race([operation, this.#throwOnAbort(options.signal)]);\n                    }\n                    const result = await operation;\n                    resolve(result);\n                    this.emit('completed', result);\n                }\n                catch (error) {\n                    if (error instanceof TimeoutError && !options.throwOnTimeout) {\n                        resolve();\n                        return;\n                    }\n                    reject(error);\n                    this.emit('error', error);\n                }\n                finally {\n                    this.#next();\n                }\n            }, options);\n            this.emit('add');\n            this.#tryToStartAnother();\n        });\n    }\n    async addAll(functions, options) {\n        return Promise.all(functions.map(async (function_) => this.add(function_, options)));\n    }\n    /**\n    Start (or resume) executing enqueued tasks within concurrency limit. No need to call this if queue is not paused (via `options.autoStart = false` or by `.pause()` method.)\n    */\n    start() {\n        if (!this.#isPaused) {\n            return this;\n        }\n        this.#isPaused = false;\n        this.#processQueue();\n        return this;\n    }\n    /**\n    Put queue execution on hold.\n    */\n    pause() {\n        this.#isPaused = true;\n    }\n    /**\n    Clear the queue.\n    */\n    clear() {\n        this.#queue = new this.#queueClass();\n    }\n    /**\n    Can be called multiple times. Useful if you for example add additional items at a later time.\n\n    @returns A promise that settles when the queue becomes empty.\n    */\n    async onEmpty() {\n        // Instantly resolve if the queue is empty\n        if (this.#queue.size === 0) {\n            return;\n        }\n        await this.#onEvent('empty');\n    }\n    /**\n    @returns A promise that settles when the queue size is less than the given limit: `queue.size < limit`.\n\n    If you want to avoid having the queue grow beyond a certain size you can `await queue.onSizeLessThan()` before adding a new item.\n\n    Note that this only limits the number of items waiting to start. There could still be up to `concurrency` jobs already running that this call does not include in its calculation.\n    */\n    async onSizeLessThan(limit) {\n        // Instantly resolve if the queue is empty.\n        if (this.#queue.size < limit) {\n            return;\n        }\n        await this.#onEvent('next', () => this.#queue.size < limit);\n    }\n    /**\n    The difference with `.onEmpty` is that `.onIdle` guarantees that all work from the queue has finished. `.onEmpty` merely signals that the queue is empty, but it could mean that some promises haven't completed yet.\n\n    @returns A promise that settles when the queue becomes empty, and all promises have completed; `queue.size === 0 && queue.pending === 0`.\n    */\n    async onIdle() {\n        // Instantly resolve if none pending and if nothing else is queued\n        if (this.#pending === 0 && this.#queue.size === 0) {\n            return;\n        }\n        await this.#onEvent('idle');\n    }\n    async #onEvent(event, filter) {\n        return new Promise(resolve => {\n            const listener = () => {\n                if (filter && !filter()) {\n                    return;\n                }\n                this.off(event, listener);\n                resolve();\n            };\n            this.on(event, listener);\n        });\n    }\n    /**\n    Size of the queue, the number of queued items waiting to run.\n    */\n    get size() {\n        return this.#queue.size;\n    }\n    /**\n    Size of the queue, filtered by the given options.\n\n    For example, this can be used to find the number of items remaining in the queue with a specific priority level.\n    */\n    sizeBy(options) {\n        // eslint-disable-next-line unicorn/no-array-callback-reference\n        return this.#queue.filter(options).length;\n    }\n    /**\n    Number of running items (no longer in the queue).\n    */\n    get pending() {\n        return this.#pending;\n    }\n    /**\n    Whether the queue is currently paused.\n    */\n    get isPaused() {\n        return this.#isPaused;\n    }\n}\n", "export interface WebworkerEventListener <T = any> {\n  (worker: Worker, event: MessageEvent<T>): void\n}\n\nconst events: Record<string, WebworkerEventListener[]> = {}\n\nconst observable = (worker: Worker & { port?: any }) => {\n  worker.addEventListener('message', (event) => {\n    observable.dispatchEvent('message', worker, event)\n  })\n\n  if (worker.port != null) {\n    worker.port.addEventListener('message', (event: any) => {\n      observable.dispatchEvent('message', worker, event)\n    })\n  }\n}\n\nobservable.addEventListener = (type: string, fn: WebworkerEventListener) => {\n  if (events[type] == null) {\n    events[type] = []\n  }\n\n  events[type].push(fn)\n}\n\nobservable.removeEventListener = (type: string, fn: WebworkerEventListener) => {\n  if (events[type] == null) {\n    return\n  }\n\n  events[type] = events[type]\n    .filter(listener => listener === fn)\n}\n\nobservable.dispatchEvent = function (type: string, worker: Worker, event: MessageEvent<any>) {\n  if (events[type] == null) {\n    return\n  }\n\n  events[type].forEach(fn => fn(worker, event))\n}\n\nexport default observable\n", "export const WORKER_REQUEST_READ_LOCK = 'lock:worker:request-read'\nexport const WORKER_RELEASE_READ_LOCK = 'lock:worker:release-read'\nexport const MASTER_GRANT_READ_LOCK = 'lock:master:grant-read'\n\nexport const WORKER_REQUEST_WRITE_LOCK = 'lock:worker:request-write'\nexport const WORKER_RELEASE_WRITE_LOCK = 'lock:worker:release-write'\nexport const MASTER_GRANT_WRITE_LOCK = 'lock:master:grant-write'\n", "export const nanoid = (size: number = 21): string => {\n  return Math.random().toString().substring(2)\n}\n", "import observer from 'observable-webworkers'\nimport {\n  WORKER_REQUEST_READ_LOCK,\n  WORKER_RELEASE_READ_LOCK,\n  MASTER_GRANT_READ_LOCK,\n  WORKER_REQUEST_WRITE_LOCK,\n  WORKER_RELEASE_WRITE_LOCK,\n  MASTER_GRANT_WRITE_LOCK\n} from './constants.js'\nimport { nanoid } from './utils.js'\nimport type { MorticeImplementation, MorticeOptions, Release } from './index.js'\n\nconst handleWorkerLockRequest = (emitter: EventTarget, masterEvent: string, requestType: string, releaseType: string, grantType: string) => {\n  return (worker: Worker, event: MessageEvent) => {\n    if (event.data.type !== requestType) {\n      return\n    }\n\n    const requestEvent = {\n      type: event.data.type,\n      name: event.data.name,\n      identifier: event.data.identifier\n    }\n\n    emitter.dispatchEvent(new MessageEvent(masterEvent, {\n      data: {\n        name: requestEvent.name,\n        handler: async (): Promise<void> => {\n          // grant lock to worker\n          worker.postMessage({\n            type: grantType,\n            name: requestEvent.name,\n            identifier: requestEvent.identifier\n          })\n\n          // wait for worker to finish\n          await new Promise<void>((resolve) => {\n            const releaseEventListener = (event: MessageEvent): void => {\n              if (event == null || event.data == null) {\n                return\n              }\n\n              const releaseEvent = {\n                type: event.data.type,\n                name: event.data.name,\n                identifier: event.data.identifier\n              }\n\n              if (releaseEvent.type === releaseType && releaseEvent.identifier === requestEvent.identifier) {\n                worker.removeEventListener('message', releaseEventListener)\n                resolve()\n              }\n            }\n\n            worker.addEventListener('message', releaseEventListener)\n          })\n        }\n      }\n    }))\n  }\n}\n\nconst makeWorkerLockRequest = (name: string, requestType: string, grantType: string, releaseType: string) => {\n  return async () => {\n    const id = nanoid()\n\n    globalThis.postMessage({\n      type: requestType,\n      identifier: id,\n      name\n    })\n\n    return new Promise<Release>((resolve) => {\n      const listener = (event: MessageEvent): void => {\n        if (event == null || event.data == null) {\n          return\n        }\n\n        const responseEvent = {\n          type: event.data.type,\n          identifier: event.data.identifier\n        }\n\n        if (responseEvent.type === grantType && responseEvent.identifier === id) {\n          globalThis.removeEventListener('message', listener)\n\n          // grant lock\n          resolve(() => {\n            // release lock\n            globalThis.postMessage({\n              type: releaseType,\n              identifier: id,\n              name\n            })\n          })\n        }\n      }\n\n      globalThis.addEventListener('message', listener)\n    })\n  }\n}\n\nconst defaultOptions = {\n  singleProcess: false\n}\n\nexport default (options: Required<MorticeOptions>): MorticeImplementation | EventTarget => {\n  options = Object.assign({}, defaultOptions, options)\n  const isPrimary = Boolean(globalThis.document) || options.singleProcess\n\n  if (isPrimary) {\n    const emitter = new EventTarget()\n\n    observer.addEventListener('message', handleWorkerLockRequest(emitter, 'requestReadLock', WORKER_REQUEST_READ_LOCK, WORKER_RELEASE_READ_LOCK, MASTER_GRANT_READ_LOCK))\n    observer.addEventListener('message', handleWorkerLockRequest(emitter, 'requestWriteLock', WORKER_REQUEST_WRITE_LOCK, WORKER_RELEASE_WRITE_LOCK, MASTER_GRANT_WRITE_LOCK))\n\n    return emitter\n  }\n\n  return {\n    isWorker: true,\n    readLock: (name) => makeWorkerLockRequest(name, WORKER_REQUEST_READ_LOCK, MASTER_GRANT_READ_LOCK, WORKER_RELEASE_READ_LOCK),\n    writeLock: (name) => makeWorkerLockRequest(name, WORKER_REQUEST_WRITE_LOCK, MASTER_GRANT_WRITE_LOCK, WORKER_RELEASE_WRITE_LOCK)\n  }\n}\n", "/**\n * @packageDocumentation\n *\n * - Reads occur concurrently\n * - Writes occur one at a time\n * - No reads occur while a write operation is in progress\n * - Locks can be created with different names\n * - Reads/writes can time out\n *\n * ## Usage\n *\n * ```javascript\n * import mortice from 'mortice'\n * import delay from 'delay'\n *\n * // the lock name & options objects are both optional\n * const mutex = mortice('my-lock', {\n *\n *   // how long before write locks time out (default: 24 hours)\n *   timeout: 30000,\n *\n *    // control how many read operations are executed concurrently (default: Infinity)\n *   concurrency: 5,\n *\n *   // by default the the lock will be held on the main thread, set this to true if the\n *   // a lock should reside on each worker (default: false)\n *   singleProcess: false\n * })\n *\n * Promise.all([\n *   (async () => {\n *     const release = await mutex.readLock()\n *\n *     try {\n *       console.info('read 1')\n *     } finally {\n *       release()\n *     }\n *   })(),\n *   (async () => {\n *     const release = await mutex.readLock()\n *\n *     try {\n *       console.info('read 2')\n *     } finally {\n *       release()\n *     }\n *   })(),\n *   (async () => {\n *     const release = await mutex.writeLock()\n *\n *     try {\n *       await delay(1000)\n *\n *       console.info('write 1')\n *     } finally {\n *       release()\n *     }\n *   })(),\n *   (async () => {\n *     const release = await mutex.readLock()\n *\n *     try {\n *       console.info('read 3')\n *     } finally {\n *       release()\n *     }\n *   })()\n * ])\n * ```\n *\n *     read 1\n *     read 2\n *     <small pause>\n *     write 1\n *     read 3\n *\n * ## Browser\n *\n * Because there's no global way to evesdrop on messages sent by Web Workers, please pass all created Web Workers to the [`observable-webworkers`](https://npmjs.org/package/observable-webworkers) module:\n *\n * ```javascript\n * // main.js\n * import mortice from 'mortice'\n * import observe from 'observable-webworkers'\n *\n * // create our lock on the main thread, it will be held here\n * const mutex = mortice()\n *\n * const worker = new Worker('worker.js')\n *\n * observe(worker)\n * ```\n *\n * ```javascript\n * // worker.js\n * import mortice from 'mortice'\n * import delay from 'delay'\n *\n * const mutex = mortice()\n *\n * let release = await mutex.readLock()\n * // read something\n * release()\n *\n * release = await mutex.writeLock()\n * // write something\n * release()\n * ```\n */\n\nimport PQueue from 'p-queue'\nimport pTimeout from 'p-timeout'\nimport impl from './node.js'\n\nexport interface MorticeOptions {\n  name?: string\n  timeout?: number\n  concurrency?: number\n  singleProcess?: boolean\n}\n\nexport interface Mortice {\n  readLock(): Promise<Release>\n  writeLock(): Promise<Release>\n}\n\nexport interface Release {\n  (): void\n}\n\nexport interface MorticeImplementation {\n  isWorker: boolean\n  readLock(name: string, options: MorticeOptions): Mortice['readLock']\n  writeLock(name: string, options: MorticeOptions): Mortice['writeLock']\n}\n\nconst mutexes: Record<string, Mortice> = {}\nlet implementation: any\n\nasync function createReleaseable (queue: PQueue, options: Required<MorticeOptions>): Promise<Release> {\n  let res: (release: Release) => void\n\n  const p = new Promise<Release>((resolve) => {\n    res = resolve\n  })\n\n  void queue.add(async () => pTimeout((async () => {\n    await new Promise<void>((resolve) => {\n      res(() => {\n        resolve()\n      })\n    })\n  })(), {\n    milliseconds: options.timeout\n  }))\n\n  return p\n}\n\nconst createMutex = (name: string, options: Required<MorticeOptions>): Mortice => {\n  if (implementation.isWorker === true) {\n    return {\n      readLock: implementation.readLock(name, options),\n      writeLock: implementation.writeLock(name, options)\n    }\n  }\n\n  const masterQueue = new PQueue({ concurrency: 1 })\n  let readQueue: PQueue | null\n\n  return {\n    async readLock () {\n      // If there's already a read queue, just add the task to it\n      if (readQueue != null) {\n        return createReleaseable(readQueue, options)\n      }\n\n      // Create a new read queue\n      readQueue = new PQueue({\n        concurrency: options.concurrency,\n        autoStart: false\n      })\n      const localReadQueue = readQueue\n\n      // Add the task to the read queue\n      const readPromise = createReleaseable(readQueue, options)\n\n      void masterQueue.add(async () => {\n        // Start the task only once the master queue has completed processing\n        // any previous tasks\n        localReadQueue.start()\n\n        // Once all the tasks in the read queue have completed, remove it so\n        // that the next read lock will occur after any write locks that were\n        // started in the interim\n        await localReadQueue.onIdle()\n          .then(() => {\n            if (readQueue === localReadQueue) {\n              readQueue = null\n            }\n          })\n      })\n\n      return readPromise\n    },\n    async writeLock () {\n      // Remove the read queue reference, so that any later read locks will be\n      // added to a new queue that starts after this write lock has been\n      // released\n      readQueue = null\n\n      return createReleaseable(masterQueue, options)\n    }\n  }\n}\n\nconst defaultOptions = {\n  name: 'lock',\n  concurrency: Infinity,\n  timeout: 84600000,\n  singleProcess: false\n}\n\ninterface EventData {\n  name: string\n  handler(): Promise<void>\n}\n\nexport default function createMortice (options?: MorticeOptions): Mortice {\n  const opts: Required<MorticeOptions> = Object.assign({}, defaultOptions, options)\n\n  if (implementation == null) {\n    implementation = impl(opts)\n\n    if (implementation.isWorker !== true) {\n      // we are master, set up worker requests\n      implementation.addEventListener('requestReadLock', (event: MessageEvent<EventData>) => {\n        if (mutexes[event.data.name] == null) {\n          return\n        }\n\n        void mutexes[event.data.name].readLock()\n          .then(async release => event.data.handler().finally(() => { release() }))\n      })\n\n      implementation.addEventListener('requestWriteLock', async (event: MessageEvent<EventData>) => {\n        if (mutexes[event.data.name] == null) {\n          return\n        }\n\n        void mutexes[event.data.name].writeLock()\n          .then(async release => event.data.handler().finally(() => { release() }))\n      })\n    }\n  }\n\n  if (mutexes[opts.name] == null) {\n    mutexes[opts.name] = createMutex(opts.name, opts)\n  }\n\n  return mutexes[opts.name]\n}\n", "export const codes = {\n  ERR_INVALID_PARAMETERS: 'ERR_INVALID_PARAMETERS'\n}\n", "/* eslint-disable import/export */\n/* eslint-disable complexity */\n/* eslint-disable @typescript-eslint/no-namespace */\n/* eslint-disable @typescript-eslint/no-unnecessary-boolean-literal-compare */\n/* eslint-disable @typescript-eslint/no-empty-interface */\n\nimport { encodeMessage, decodeMessage, message } from 'protons-runtime'\nimport type { Codec } from 'protons-runtime'\nimport type { Uint8ArrayList } from 'uint8arraylist'\n\nexport interface Peer {\n  addresses: Address[]\n  protocols: string[]\n  publicKey?: Uint8Array\n  peerRecordEnvelope?: Uint8Array\n  metadata: Map<string, Uint8Array>\n  tags: Map<string, Tag>\n}\n\nexport namespace Peer {\n  export interface Peer$metadataEntry {\n    key: string\n    value: Uint8Array\n  }\n\n  export namespace Peer$metadataEntry {\n    let _codec: Codec<Peer$metadataEntry>\n\n    export const codec = (): Codec<Peer$metadataEntry> => {\n      if (_codec == null) {\n        _codec = message<Peer$metadataEntry>((obj, w, opts = {}) => {\n          if (opts.lengthDelimited !== false) {\n            w.fork()\n          }\n\n          if ((obj.key != null && obj.key !== '')) {\n            w.uint32(10)\n            w.string(obj.key)\n          }\n\n          if ((obj.value != null && obj.value.byteLength > 0)) {\n            w.uint32(18)\n            w.bytes(obj.value)\n          }\n\n          if (opts.lengthDelimited !== false) {\n            w.ldelim()\n          }\n        }, (reader, length) => {\n          const obj: any = {\n            key: '',\n            value: new Uint8Array(0)\n          }\n\n          const end = length == null ? reader.len : reader.pos + length\n\n          while (reader.pos < end) {\n            const tag = reader.uint32()\n\n            switch (tag >>> 3) {\n              case 1:\n                obj.key = reader.string()\n                break\n              case 2:\n                obj.value = reader.bytes()\n                break\n              default:\n                reader.skipType(tag & 7)\n                break\n            }\n          }\n\n          return obj\n        })\n      }\n\n      return _codec\n    }\n\n    export const encode = (obj: Partial<Peer$metadataEntry>): Uint8Array => {\n      return encodeMessage(obj, Peer$metadataEntry.codec())\n    }\n\n    export const decode = (buf: Uint8Array | Uint8ArrayList): Peer$metadataEntry => {\n      return decodeMessage(buf, Peer$metadataEntry.codec())\n    }\n  }\n\n  export interface Peer$tagsEntry {\n    key: string\n    value?: Tag\n  }\n\n  export namespace Peer$tagsEntry {\n    let _codec: Codec<Peer$tagsEntry>\n\n    export const codec = (): Codec<Peer$tagsEntry> => {\n      if (_codec == null) {\n        _codec = message<Peer$tagsEntry>((obj, w, opts = {}) => {\n          if (opts.lengthDelimited !== false) {\n            w.fork()\n          }\n\n          if ((obj.key != null && obj.key !== '')) {\n            w.uint32(10)\n            w.string(obj.key)\n          }\n\n          if (obj.value != null) {\n            w.uint32(18)\n            Tag.codec().encode(obj.value, w)\n          }\n\n          if (opts.lengthDelimited !== false) {\n            w.ldelim()\n          }\n        }, (reader, length) => {\n          const obj: any = {\n            key: ''\n          }\n\n          const end = length == null ? reader.len : reader.pos + length\n\n          while (reader.pos < end) {\n            const tag = reader.uint32()\n\n            switch (tag >>> 3) {\n              case 1:\n                obj.key = reader.string()\n                break\n              case 2:\n                obj.value = Tag.codec().decode(reader, reader.uint32())\n                break\n              default:\n                reader.skipType(tag & 7)\n                break\n            }\n          }\n\n          return obj\n        })\n      }\n\n      return _codec\n    }\n\n    export const encode = (obj: Partial<Peer$tagsEntry>): Uint8Array => {\n      return encodeMessage(obj, Peer$tagsEntry.codec())\n    }\n\n    export const decode = (buf: Uint8Array | Uint8ArrayList): Peer$tagsEntry => {\n      return decodeMessage(buf, Peer$tagsEntry.codec())\n    }\n  }\n\n  let _codec: Codec<Peer>\n\n  export const codec = (): Codec<Peer> => {\n    if (_codec == null) {\n      _codec = message<Peer>((obj, w, opts = {}) => {\n        if (opts.lengthDelimited !== false) {\n          w.fork()\n        }\n\n        if (obj.addresses != null) {\n          for (const value of obj.addresses) {\n            w.uint32(10)\n            Address.codec().encode(value, w)\n          }\n        }\n\n        if (obj.protocols != null) {\n          for (const value of obj.protocols) {\n            w.uint32(18)\n            w.string(value)\n          }\n        }\n\n        if (obj.publicKey != null) {\n          w.uint32(34)\n          w.bytes(obj.publicKey)\n        }\n\n        if (obj.peerRecordEnvelope != null) {\n          w.uint32(42)\n          w.bytes(obj.peerRecordEnvelope)\n        }\n\n        if (obj.metadata != null && obj.metadata.size !== 0) {\n          for (const [key, value] of obj.metadata.entries()) {\n            w.uint32(50)\n            Peer.Peer$metadataEntry.codec().encode({ key, value }, w)\n          }\n        }\n\n        if (obj.tags != null && obj.tags.size !== 0) {\n          for (const [key, value] of obj.tags.entries()) {\n            w.uint32(58)\n            Peer.Peer$tagsEntry.codec().encode({ key, value }, w)\n          }\n        }\n\n        if (opts.lengthDelimited !== false) {\n          w.ldelim()\n        }\n      }, (reader, length) => {\n        const obj: any = {\n          addresses: [],\n          protocols: [],\n          metadata: new Map<string, Uint8Array>(),\n          tags: new Map<string, undefined>()\n        }\n\n        const end = length == null ? reader.len : reader.pos + length\n\n        while (reader.pos < end) {\n          const tag = reader.uint32()\n\n          switch (tag >>> 3) {\n            case 1:\n              obj.addresses.push(Address.codec().decode(reader, reader.uint32()))\n              break\n            case 2:\n              obj.protocols.push(reader.string())\n              break\n            case 4:\n              obj.publicKey = reader.bytes()\n              break\n            case 5:\n              obj.peerRecordEnvelope = reader.bytes()\n              break\n            case 6: {\n              const entry = Peer.Peer$metadataEntry.codec().decode(reader, reader.uint32())\n              obj.metadata.set(entry.key, entry.value)\n              break\n            }\n            case 7: {\n              const entry = Peer.Peer$tagsEntry.codec().decode(reader, reader.uint32())\n              obj.tags.set(entry.key, entry.value)\n              break\n            }\n            default:\n              reader.skipType(tag & 7)\n              break\n          }\n        }\n\n        return obj\n      })\n    }\n\n    return _codec\n  }\n\n  export const encode = (obj: Partial<Peer>): Uint8Array => {\n    return encodeMessage(obj, Peer.codec())\n  }\n\n  export const decode = (buf: Uint8Array | Uint8ArrayList): Peer => {\n    return decodeMessage(buf, Peer.codec())\n  }\n}\n\nexport interface Address {\n  multiaddr: Uint8Array\n  isCertified?: boolean\n}\n\nexport namespace Address {\n  let _codec: Codec<Address>\n\n  export const codec = (): Codec<Address> => {\n    if (_codec == null) {\n      _codec = message<Address>((obj, w, opts = {}) => {\n        if (opts.lengthDelimited !== false) {\n          w.fork()\n        }\n\n        if ((obj.multiaddr != null && obj.multiaddr.byteLength > 0)) {\n          w.uint32(10)\n          w.bytes(obj.multiaddr)\n        }\n\n        if (obj.isCertified != null) {\n          w.uint32(16)\n          w.bool(obj.isCertified)\n        }\n\n        if (opts.lengthDelimited !== false) {\n          w.ldelim()\n        }\n      }, (reader, length) => {\n        const obj: any = {\n          multiaddr: new Uint8Array(0)\n        }\n\n        const end = length == null ? reader.len : reader.pos + length\n\n        while (reader.pos < end) {\n          const tag = reader.uint32()\n\n          switch (tag >>> 3) {\n            case 1:\n              obj.multiaddr = reader.bytes()\n              break\n            case 2:\n              obj.isCertified = reader.bool()\n              break\n            default:\n              reader.skipType(tag & 7)\n              break\n          }\n        }\n\n        return obj\n      })\n    }\n\n    return _codec\n  }\n\n  export const encode = (obj: Partial<Address>): Uint8Array => {\n    return encodeMessage(obj, Address.codec())\n  }\n\n  export const decode = (buf: Uint8Array | Uint8ArrayList): Address => {\n    return decodeMessage(buf, Address.codec())\n  }\n}\n\nexport interface Tag {\n  value: number\n  expiry?: bigint\n}\n\nexport namespace Tag {\n  let _codec: Codec<Tag>\n\n  export const codec = (): Codec<Tag> => {\n    if (_codec == null) {\n      _codec = message<Tag>((obj, w, opts = {}) => {\n        if (opts.lengthDelimited !== false) {\n          w.fork()\n        }\n\n        if ((obj.value != null && obj.value !== 0)) {\n          w.uint32(8)\n          w.uint32(obj.value)\n        }\n\n        if (obj.expiry != null) {\n          w.uint32(16)\n          w.uint64(obj.expiry)\n        }\n\n        if (opts.lengthDelimited !== false) {\n          w.ldelim()\n        }\n      }, (reader, length) => {\n        const obj: any = {\n          value: 0\n        }\n\n        const end = length == null ? reader.len : reader.pos + length\n\n        while (reader.pos < end) {\n          const tag = reader.uint32()\n\n          switch (tag >>> 3) {\n            case 1:\n              obj.value = reader.uint32()\n              break\n            case 2:\n              obj.expiry = reader.uint64()\n              break\n            default:\n              reader.skipType(tag & 7)\n              break\n          }\n        }\n\n        return obj\n      })\n    }\n\n    return _codec\n  }\n\n  export const encode = (obj: Partial<Tag>): Uint8Array => {\n    return encodeMessage(obj, Tag.codec())\n  }\n\n  export const decode = (buf: Uint8Array | Uint8ArrayList): Tag => {\n    return decodeMessage(buf, Tag.codec())\n  }\n}\n", "import { peerIdFromPeerId } from '@libp2p/peer-id'\nimport { multiaddr } from '@multiformats/multiaddr'\nimport { Peer as PeerPB } from '../pb/peer.js'\nimport type { PeerId, Peer, Tag } from '@libp2p/interface'\n\nexport function bytesToPeer (peerId: PeerId, buf: Uint8Array): Peer {\n  const peer = PeerPB.decode(buf)\n\n  if (peer.publicKey != null && peerId.publicKey == null) {\n    peerId = peerIdFromPeerId({\n      ...peerId,\n      publicKey: peerId.publicKey\n    })\n  }\n\n  const tags = new Map<string, Tag>()\n\n  // remove any expired tags\n  const now = BigInt(Date.now())\n\n  for (const [key, tag] of peer.tags.entries()) {\n    if (tag.expiry != null && tag.expiry < now) {\n      continue\n    }\n\n    tags.set(key, tag)\n  }\n\n  return {\n    ...peer,\n    id: peerId,\n    addresses: peer.addresses.map(({ multiaddr: ma, isCertified }) => {\n      return {\n        multiaddr: multiaddr(ma),\n        isCertified: isCertified ?? false\n      }\n    }),\n    metadata: peer.metadata,\n    peerRecordEnvelope: peer.peerRecordEnvelope ?? undefined,\n    tags\n  }\n}\n", "import { fromString as uint8ArrayFromString } from 'uint8arrays/from-string'\nimport { type SupportedEncodings, toString as uint8ArrayToString } from 'uint8arrays/to-string'\n\nconst pathSepS = '/'\nconst pathSepB = new TextEncoder().encode(pathSepS)\nconst pathSep = pathSepB[0]\n\n/**\n * A Key represents the unique identifier of an object.\n * Our Key scheme is inspired by file systems and Google App Engine key model.\n * Keys are meant to be unique across a system. Keys are hierarchical,\n * incorporating more and more specific namespaces. Thus keys can be deemed\n * 'children' or 'ancestors' of other keys:\n * - `new Key('/Comedy')`\n * - `new Key('/Comedy/MontyPython')`\n * Also, every namespace can be parametrized to embed relevant object\n * information. For example, the Key `name` (most specific namespace) could\n * include the object type:\n * - `new Key('/Comedy/MontyPython/Actor:JohnCleese')`\n * - `new Key('/Comedy/MontyPython/Sketch:CheeseShop')`\n * - `new Key('/Comedy/MontyPython/Sketch:CheeseShop/Character:Mousebender')`\n *\n */\nexport class Key {\n  private _buf: Uint8Array\n\n  /**\n   * @param {string | Uint8Array} s\n   * @param {boolean} [clean]\n   */\n  constructor (s: string | Uint8Array, clean?: boolean) {\n    if (typeof s === 'string') {\n      this._buf = uint8ArrayFromString(s)\n    } else if (s instanceof Uint8Array) {\n      this._buf = s\n    } else {\n      throw new Error('Invalid key, should be String of Uint8Array')\n    }\n\n    if (clean == null) {\n      clean = true\n    }\n\n    if (clean) {\n      this.clean()\n    }\n\n    if (this._buf.byteLength === 0 || this._buf[0] !== pathSep) {\n      throw new Error('Invalid key')\n    }\n  }\n\n  /**\n   * Convert to the string representation\n   *\n   * @param {import('uint8arrays/to-string').SupportedEncodings} [encoding='utf8'] - The encoding to use.\n   * @returns {string}\n   */\n  toString (encoding: SupportedEncodings = 'utf8'): string {\n    return uint8ArrayToString(this._buf, encoding)\n  }\n\n  /**\n   * Return the Uint8Array representation of the key\n   *\n   * @returns {Uint8Array}\n   */\n  uint8Array (): Uint8Array {\n    return this._buf\n  }\n\n  /**\n   * Return string representation of the key\n   *\n   * @returns {string}\n   */\n  get [Symbol.toStringTag] (): string {\n    return `Key(${this.toString()})`\n  }\n\n  /**\n   * Constructs a key out of a namespace array.\n   *\n   * @param {Array<string>} list - The array of namespaces\n   * @returns {Key}\n   *\n   * @example\n   * ```js\n   * Key.withNamespaces(['one', 'two'])\n   * // => Key('/one/two')\n   * ```\n   */\n  static withNamespaces (list: string[]): Key {\n    return new Key(list.join(pathSepS))\n  }\n\n  /**\n   * Returns a randomly (uuid) generated key.\n   *\n   * @returns {Key}\n   *\n   * @example\n   * ```js\n   * Key.random()\n   * // => Key('/344502982398')\n   * ```\n   */\n  static random (): Key {\n    return new Key(Math.random().toString().substring(2))\n  }\n\n  /**\n   * @param {*} other\n   */\n  static asKey (other: any): Key | null {\n    if (other instanceof Uint8Array || typeof other === 'string') {\n      // we can create a key from this\n      return new Key(other)\n    }\n\n    if (typeof other.uint8Array === 'function') {\n      // this is an older version or may have crossed the esm/cjs boundary\n      return new Key(other.uint8Array())\n    }\n\n    return null\n  }\n\n  /**\n   * Cleanup the current key\n   *\n   * @returns {void}\n   */\n  clean (): void {\n    if (this._buf == null || this._buf.byteLength === 0) {\n      this._buf = pathSepB\n    }\n\n    if (this._buf[0] !== pathSep) {\n      const bytes = new Uint8Array(this._buf.byteLength + 1)\n      bytes.fill(pathSep, 0, 1)\n      bytes.set(this._buf, 1)\n      this._buf = bytes\n    }\n\n    // normalize does not remove trailing slashes\n    while (this._buf.byteLength > 1 && this._buf[this._buf.byteLength - 1] === pathSep) {\n      this._buf = this._buf.subarray(0, -1)\n    }\n  }\n\n  /**\n   * Check if the given key is sorted lower than ourself.\n   *\n   * @param {Key} key - The other Key to check against\n   * @returns {boolean}\n   */\n  less (key: Key): boolean {\n    const list1 = this.list()\n    const list2 = key.list()\n\n    for (let i = 0; i < list1.length; i++) {\n      if (list2.length < i + 1) {\n        return false\n      }\n\n      const c1 = list1[i]\n      const c2 = list2[i]\n\n      if (c1 < c2) {\n        return true\n      } else if (c1 > c2) {\n        return false\n      }\n    }\n\n    return list1.length < list2.length\n  }\n\n  /**\n   * Returns the key with all parts in reversed order.\n   *\n   * @returns {Key}\n   *\n   * @example\n   * ```js\n   * new Key('/Comedy/MontyPython/Actor:JohnCleese').reverse()\n   * // => Key('/Actor:JohnCleese/MontyPython/Comedy')\n   * ```\n   */\n  reverse (): Key {\n    return Key.withNamespaces(this.list().slice().reverse())\n  }\n\n  /**\n   * Returns the `namespaces` making up this Key.\n   *\n   * @returns {Array<string>}\n   */\n  namespaces (): string[] {\n    return this.list()\n  }\n\n  /** Returns the \"base\" namespace of this key.\n   *\n   * @returns {string}\n   *\n   * @example\n   * ```js\n   * new Key('/Comedy/MontyPython/Actor:JohnCleese').baseNamespace()\n   * // => 'Actor:JohnCleese'\n   * ```\n   */\n  baseNamespace (): string {\n    const ns = this.namespaces()\n    return ns[ns.length - 1]\n  }\n\n  /**\n   * Returns the `list` representation of this key.\n   *\n   * @returns {Array<string>}\n   *\n   * @example\n   * ```js\n   * new Key('/Comedy/MontyPython/Actor:JohnCleese').list()\n   * // => ['Comedy', 'MontyPythong', 'Actor:JohnCleese']\n   * ```\n   */\n  list (): string[] {\n    return this.toString().split(pathSepS).slice(1)\n  }\n\n  /**\n   * Returns the \"type\" of this key (value of last namespace).\n   *\n   * @returns {string}\n   *\n   * @example\n   * ```js\n   * new Key('/Comedy/MontyPython/Actor:JohnCleese').type()\n   * // => 'Actor'\n   * ```\n   */\n  type (): string {\n    return namespaceType(this.baseNamespace())\n  }\n\n  /**\n   * Returns the \"name\" of this key (field of last namespace).\n   *\n   * @returns {string}\n   *\n   * @example\n   * ```js\n   * new Key('/Comedy/MontyPython/Actor:JohnCleese').name()\n   * // => 'JohnCleese'\n   * ```\n   */\n  name (): string {\n    return namespaceValue(this.baseNamespace())\n  }\n\n  /**\n   * Returns an \"instance\" of this type key (appends value to namespace).\n   *\n   * @param {string} s - The string to append.\n   * @returns {Key}\n   *\n   * @example\n   * ```js\n   * new Key('/Comedy/MontyPython/Actor').instance('JohnClesse')\n   * // => Key('/Comedy/MontyPython/Actor:JohnCleese')\n   * ```\n   */\n  instance (s: string): Key {\n    return new Key(this.toString() + ':' + s)\n  }\n\n  /**\n   * Returns the \"path\" of this key (parent + type).\n   *\n   * @returns {Key}\n   *\n   * @example\n   * ```js\n   * new Key('/Comedy/MontyPython/Actor:JohnCleese').path()\n   * // => Key('/Comedy/MontyPython/Actor')\n   * ```\n   */\n  path (): Key {\n    let p = this.parent().toString()\n    if (!p.endsWith(pathSepS)) {\n      p += pathSepS\n    }\n    p += this.type()\n    return new Key(p)\n  }\n\n  /**\n   * Returns the `parent` Key of this Key.\n   *\n   * @returns {Key}\n   *\n   * @example\n   * ```js\n   * new Key(\"/Comedy/MontyPython/Actor:JohnCleese\").parent()\n   * // => Key(\"/Comedy/MontyPython\")\n   * ```\n   */\n  parent (): Key {\n    const list = this.list()\n    if (list.length === 1) {\n      return new Key(pathSepS)\n    }\n\n    return new Key(list.slice(0, -1).join(pathSepS))\n  }\n\n  /**\n   * Returns the `child` Key of this Key.\n   *\n   * @param {Key} key - The child Key to add\n   * @returns {Key}\n   *\n   * @example\n   * ```js\n   * new Key('/Comedy/MontyPython').child(new Key('Actor:JohnCleese'))\n   * // => Key('/Comedy/MontyPython/Actor:JohnCleese')\n   * ```\n   */\n  child (key: Key): Key {\n    if (this.toString() === pathSepS) {\n      return key\n    } else if (key.toString() === pathSepS) {\n      return this\n    }\n\n    return new Key(this.toString() + key.toString(), false)\n  }\n\n  /**\n   * Returns whether this key is a prefix of `other`\n   *\n   * @param {Key} other - The other key to test against\n   * @returns {boolean}\n   *\n   * @example\n   * ```js\n   * new Key('/Comedy').isAncestorOf('/Comedy/MontyPython')\n   * // => true\n   * ```\n   */\n  isAncestorOf (other: Key): boolean {\n    if (other.toString() === this.toString()) {\n      return false\n    }\n\n    return other.toString().startsWith(this.toString())\n  }\n\n  /**\n   * Returns whether this key is a contains another as prefix.\n   *\n   * @param {Key} other - The other Key to test against\n   * @returns {boolean}\n   *\n   * @example\n   * ```js\n   * new Key('/Comedy/MontyPython').isDecendantOf('/Comedy')\n   * // => true\n   * ```\n   */\n  isDecendantOf (other: Key): boolean {\n    if (other.toString() === this.toString()) {\n      return false\n    }\n\n    return this.toString().startsWith(other.toString())\n  }\n\n  /**\n   * Checks if this key has only one namespace.\n   *\n   * @returns {boolean}\n   */\n  isTopLevel (): boolean {\n    return this.list().length === 1\n  }\n\n  /**\n   * Concats one or more Keys into one new Key.\n   *\n   * @param {Array<Key>} keys - The array of keys to concatenate\n   * @returns {Key}\n   */\n  concat (...keys: Key[]): Key {\n    return Key.withNamespaces([...this.namespaces(), ...flatten(keys.map(key => key.namespaces()))])\n  }\n}\n\n/**\n * The first component of a namespace. `foo` in `foo:bar`\n *\n * @param {string} ns\n * @returns {string}\n */\nfunction namespaceType (ns: string): string {\n  const parts = ns.split(':')\n  if (parts.length < 2) {\n    return ''\n  }\n  return parts.slice(0, -1).join(':')\n}\n\n/**\n * The last component of a namespace, `baz` in `foo:bar:baz`.\n *\n * @param {string} ns\n * @returns {string}\n */\nfunction namespaceValue (ns: string): string {\n  const parts = ns.split(':')\n  return parts[parts.length - 1]\n}\n\n/**\n * Flatten array of arrays (only one level)\n *\n * @template T\n * @param {Array<any>} arr\n * @returns {T[]}\n */\nfunction flatten (arr: any[]): string[] {\n  return ([]).concat(...arr)\n}\n", "import { CodeError } from '@libp2p/interface'\nimport { isPeerId, type PeerId } from '@libp2p/interface'\nimport { Key } from 'interface-datastore/key'\nimport { codes } from '../errors.js'\n\nexport const NAMESPACE_COMMON = '/peers/'\n\nexport function peerIdToDatastoreKey (peerId: PeerId): Key {\n  if (!isPeerId(peerId) || peerId.type == null) {\n    throw new CodeError('Invalid PeerId', codes.ERR_INVALID_PARAMETERS)\n  }\n\n  const b32key = peerId.toCID().toString()\n  return new Key(`${NAMESPACE_COMMON}${b32key}`)\n}\n", "import { CodeError } from '@libp2p/interface'\nimport { isMultiaddr, multiaddr } from '@multiformats/multiaddr'\nimport { codes } from '../errors.js'\nimport type { AddressFilter } from '../index.js'\nimport type { Address as AddressPB } from '../pb/peer.js'\nimport type { PeerId, Address } from '@libp2p/interface'\n\nexport async function dedupeFilterAndSortAddresses (peerId: PeerId, filter: AddressFilter, addresses: Array<Address | AddressPB | undefined>): Promise<AddressPB[]> {\n  const addressMap = new Map<string, Address>()\n\n  for (const addr of addresses) {\n    if (addr == null) {\n      continue\n    }\n\n    if (addr.multiaddr instanceof Uint8Array) {\n      addr.multiaddr = multiaddr(addr.multiaddr)\n    }\n\n    if (!isMultiaddr(addr.multiaddr)) {\n      throw new CodeError('Multiaddr was invalid', codes.ERR_INVALID_PARAMETERS)\n    }\n\n    if (!(await filter(peerId, addr.multiaddr))) {\n      continue\n    }\n\n    const isCertified = addr.isCertified ?? false\n    const maStr = addr.multiaddr.toString()\n    const existingAddr = addressMap.get(maStr)\n\n    if (existingAddr != null) {\n      addr.isCertified = existingAddr.isCertified || isCertified\n    } else {\n      addressMap.set(maStr, {\n        multiaddr: addr.multiaddr,\n        isCertified\n      })\n    }\n  }\n\n  return [...addressMap.values()]\n    .sort((a, b) => {\n      return a.multiaddr.toString().localeCompare(b.multiaddr.toString())\n    })\n    .map(({ isCertified, multiaddr }) => ({\n      isCertified,\n      multiaddr: multiaddr.bytes\n    }))\n}\n", "import { CodeError } from '@libp2p/interface'\nimport { equals as uint8arrayEquals } from 'uint8arrays/equals'\nimport { codes } from '../errors.js'\nimport { dedupeFilterAndSortAddresses } from './dedupe-addresses.js'\nimport type { AddressFilter } from '../index.js'\nimport type { Tag, Peer as PeerPB } from '../pb/peer.js'\nimport type { PeerId, Address, Peer, PeerData, TagOptions } from '@libp2p/interface'\n\nexport interface ToPBPeerOptions {\n  addressFilter?: AddressFilter\n  existingPeer?: Peer\n}\n\nexport async function toPeerPB (peerId: PeerId, data: Partial<PeerData>, strategy: 'merge' | 'patch', options: ToPBPeerOptions): Promise<PeerPB> {\n  if (data == null) {\n    throw new CodeError('Invalid PeerData', codes.ERR_INVALID_PARAMETERS)\n  }\n\n  if (data.publicKey != null && peerId.publicKey != null && !uint8arrayEquals(data.publicKey, peerId.publicKey)) {\n    throw new CodeError('publicKey bytes do not match peer id publicKey bytes', codes.ERR_INVALID_PARAMETERS)\n  }\n\n  const existingPeer = options.existingPeer\n\n  if (existingPeer != null && !peerId.equals(existingPeer.id)) {\n    throw new CodeError('peer id did not match existing peer id', codes.ERR_INVALID_PARAMETERS)\n  }\n\n  let addresses: Address[] = existingPeer?.addresses ?? []\n  let protocols = new Set<string>(existingPeer?.protocols ?? [])\n  let metadata: Map<string, Uint8Array> = existingPeer?.metadata ?? new Map()\n  let tags: Map<string, Tag> = existingPeer?.tags ?? new Map()\n  let peerRecordEnvelope: Uint8Array | undefined = existingPeer?.peerRecordEnvelope\n\n  // when patching, we replace the original fields with passed values\n  if (strategy === 'patch') {\n    if (data.multiaddrs != null || data.addresses != null) {\n      addresses = []\n\n      if (data.multiaddrs != null) {\n        addresses.push(...data.multiaddrs.map(multiaddr => ({\n          isCertified: false,\n          multiaddr\n        })))\n      }\n\n      if (data.addresses != null) {\n        addresses.push(...data.addresses)\n      }\n    }\n\n    if (data.protocols != null) {\n      protocols = new Set(data.protocols)\n    }\n\n    if (data.metadata != null) {\n      const metadataEntries = data.metadata instanceof Map ? [...data.metadata.entries()] : Object.entries(data.metadata)\n\n      metadata = createSortedMap(metadataEntries, {\n        validate: validateMetadata\n      })\n    }\n\n    if (data.tags != null) {\n      const tagsEntries = data.tags instanceof Map ? [...data.tags.entries()] : Object.entries(data.tags)\n\n      tags = createSortedMap(tagsEntries, {\n        validate: validateTag,\n        map: mapTag\n      })\n    }\n\n    if (data.peerRecordEnvelope != null) {\n      peerRecordEnvelope = data.peerRecordEnvelope\n    }\n  }\n\n  // when merging, we join the original fields with passed values\n  if (strategy === 'merge') {\n    if (data.multiaddrs != null) {\n      addresses.push(...data.multiaddrs.map(multiaddr => ({\n        isCertified: false,\n        multiaddr\n      })))\n    }\n\n    if (data.addresses != null) {\n      addresses.push(...data.addresses)\n    }\n\n    if (data.protocols != null) {\n      protocols = new Set([...protocols, ...data.protocols])\n    }\n\n    if (data.metadata != null) {\n      const metadataEntries = data.metadata instanceof Map ? [...data.metadata.entries()] : Object.entries(data.metadata)\n\n      for (const [key, value] of metadataEntries) {\n        if (value == null) {\n          metadata.delete(key)\n        } else {\n          metadata.set(key, value)\n        }\n      }\n\n      metadata = createSortedMap([...metadata.entries()], {\n        validate: validateMetadata\n      })\n    }\n\n    if (data.tags != null) {\n      const tagsEntries = data.tags instanceof Map ? [...data.tags.entries()] : Object.entries(data.tags)\n      const mergedTags = new Map<string, Tag | TagOptions>(tags)\n\n      for (const [key, value] of tagsEntries) {\n        if (value == null) {\n          mergedTags.delete(key)\n        } else {\n          mergedTags.set(key, value)\n        }\n      }\n\n      tags = createSortedMap([...mergedTags.entries()], {\n        validate: validateTag,\n        map: mapTag\n      })\n    }\n\n    if (data.peerRecordEnvelope != null) {\n      peerRecordEnvelope = data.peerRecordEnvelope\n    }\n  }\n\n  const output: PeerPB = {\n    addresses: await dedupeFilterAndSortAddresses(peerId, options.addressFilter ?? (async () => true), addresses),\n    protocols: [...protocols.values()].sort((a, b) => {\n      return a.localeCompare(b)\n    }),\n    metadata,\n    tags,\n\n    publicKey: existingPeer?.id.publicKey ?? data.publicKey ?? peerId.publicKey,\n    peerRecordEnvelope\n  }\n\n  // Ed25519 and secp256k1 have their public key embedded in them so no need to duplicate it\n  if (peerId.type !== 'RSA') {\n    delete output.publicKey\n  }\n\n  return output\n}\n\ninterface CreateSortedMapOptions <V, R = V> {\n  validate(key: string, value: V): void\n  map?(key: string, value: V): R\n}\n\n/**\n * In JS maps are ordered by insertion order so create a new map with the\n * keys inserted in alphabetical order.\n */\nfunction createSortedMap <V, R = V> (entries: Array<[string, V | undefined]>, options: CreateSortedMapOptions<V, R>): Map<string, R> {\n  const output = new Map()\n\n  for (const [key, value] of entries) {\n    if (value == null) {\n      continue\n    }\n\n    options.validate(key, value)\n  }\n\n  for (const [key, value] of entries.sort(([a], [b]) => {\n    return a.localeCompare(b)\n  })) {\n    if (value != null) {\n      output.set(key, options.map?.(key, value) ?? value)\n    }\n  }\n\n  return output\n}\n\nfunction validateMetadata (key: string, value: Uint8Array): void {\n  if (typeof key !== 'string') {\n    throw new CodeError('Metadata key must be a string', codes.ERR_INVALID_PARAMETERS)\n  }\n\n  if (!(value instanceof Uint8Array)) {\n    throw new CodeError('Metadata value must be a Uint8Array', codes.ERR_INVALID_PARAMETERS)\n  }\n}\n\nfunction validateTag (key: string, tag: TagOptions): void {\n  if (typeof key !== 'string') {\n    throw new CodeError('Tag name must be a string', codes.ERR_INVALID_PARAMETERS)\n  }\n\n  if (tag.value != null) {\n    if (parseInt(`${tag.value}`, 10) !== tag.value) {\n      throw new CodeError('Tag value must be an integer', codes.ERR_INVALID_PARAMETERS)\n    }\n\n    if (tag.value < 0 || tag.value > 100) {\n      throw new CodeError('Tag value must be between 0-100', codes.ERR_INVALID_PARAMETERS)\n    }\n  }\n\n  if (tag.ttl != null) {\n    if (parseInt(`${tag.ttl}`, 10) !== tag.ttl) {\n      throw new CodeError('Tag ttl must be an integer', codes.ERR_INVALID_PARAMETERS)\n    }\n\n    if (tag.ttl < 0) {\n      throw new CodeError('Tag ttl must be between greater than 0', codes.ERR_INVALID_PARAMETERS)\n    }\n  }\n}\n\nfunction mapTag (key: string, tag: any): Tag {\n  let expiry: bigint | undefined\n\n  if (tag.expiry != null) {\n    expiry = tag.expiry\n  }\n\n  if (tag.ttl != null) {\n    expiry = BigInt(Date.now() + Number(tag.ttl))\n  }\n\n  return {\n    value: tag.value ?? 0,\n    expiry\n  }\n}\n", "import { CodeError } from '@libp2p/interface'\nimport { PeerMap } from '@libp2p/peer-collections'\nimport { peerIdFromBytes } from '@libp2p/peer-id'\nimport mortice, { type Mortice } from 'mortice'\nimport { base32 } from 'multiformats/bases/base32'\nimport { equals as uint8ArrayEquals } from 'uint8arrays/equals'\nimport { codes } from './errors.js'\nimport { Peer as PeerPB } from './pb/peer.js'\nimport { bytesToPeer } from './utils/bytes-to-peer.js'\nimport { NAMESPACE_COMMON, peerIdToDatastoreKey } from './utils/peer-id-to-datastore-key.js'\nimport { toPeerPB } from './utils/to-peer-pb.js'\nimport type { AddressFilter, PersistentPeerStoreComponents, PersistentPeerStoreInit } from './index.js'\nimport type { PeerUpdate as PeerUpdateExternal, PeerId, Peer, PeerData, PeerQuery } from '@libp2p/interface'\nimport type { Datastore, Key, Query } from 'interface-datastore'\n\n/**\n * Event detail emitted when peer data changes\n */\nexport interface PeerUpdate extends PeerUpdateExternal {\n  updated: boolean\n}\n\nfunction decodePeer (key: Key, value: Uint8Array, cache: PeerMap<Peer>): Peer {\n  // /peers/${peer-id-as-libp2p-key-cid-string-in-base-32}\n  const base32Str = key.toString().split('/')[2]\n  const buf = base32.decode(base32Str)\n  const peerId = peerIdFromBytes(buf)\n\n  const cached = cache.get(peerId)\n\n  if (cached != null) {\n    return cached\n  }\n\n  const peer = bytesToPeer(peerId, value)\n\n  cache.set(peerId, peer)\n\n  return peer\n}\n\nfunction mapQuery (query: PeerQuery, cache: PeerMap<Peer>): Query {\n  if (query == null) {\n    return {}\n  }\n\n  return {\n    prefix: NAMESPACE_COMMON,\n    filters: (query.filters ?? []).map(fn => ({ key, value }) => {\n      return fn(decodePeer(key, value, cache))\n    }),\n    orders: (query.orders ?? []).map(fn => (a, b) => {\n      return fn(decodePeer(a.key, a.value, cache), decodePeer(b.key, b.value, cache))\n    })\n  }\n}\n\nexport class PersistentStore {\n  private readonly peerId: PeerId\n  private readonly datastore: Datastore\n  public readonly lock: Mortice\n  private readonly addressFilter?: AddressFilter\n\n  constructor (components: PersistentPeerStoreComponents, init: PersistentPeerStoreInit = {}) {\n    this.peerId = components.peerId\n    this.datastore = components.datastore\n    this.addressFilter = init.addressFilter\n    this.lock = mortice({\n      name: 'peer-store',\n      singleProcess: true\n    })\n  }\n\n  async has (peerId: PeerId): Promise<boolean> {\n    return this.datastore.has(peerIdToDatastoreKey(peerId))\n  }\n\n  async delete (peerId: PeerId): Promise<void> {\n    if (this.peerId.equals(peerId)) {\n      throw new CodeError('Cannot delete self peer', codes.ERR_INVALID_PARAMETERS)\n    }\n\n    await this.datastore.delete(peerIdToDatastoreKey(peerId))\n  }\n\n  async load (peerId: PeerId): Promise<Peer> {\n    const buf = await this.datastore.get(peerIdToDatastoreKey(peerId))\n\n    return bytesToPeer(peerId, buf)\n  }\n\n  async save (peerId: PeerId, data: PeerData): Promise<PeerUpdate> {\n    const {\n      existingBuf,\n      existingPeer\n    } = await this.#findExistingPeer(peerId)\n\n    const peerPb: PeerPB = await toPeerPB(peerId, data, 'patch', {\n      addressFilter: this.addressFilter\n    })\n\n    return this.#saveIfDifferent(peerId, peerPb, existingBuf, existingPeer)\n  }\n\n  async patch (peerId: PeerId, data: Partial<PeerData>): Promise<PeerUpdate> {\n    const {\n      existingBuf,\n      existingPeer\n    } = await this.#findExistingPeer(peerId)\n\n    const peerPb: PeerPB = await toPeerPB(peerId, data, 'patch', {\n      addressFilter: this.addressFilter,\n      existingPeer\n    })\n\n    return this.#saveIfDifferent(peerId, peerPb, existingBuf, existingPeer)\n  }\n\n  async merge (peerId: PeerId, data: PeerData): Promise<PeerUpdate> {\n    const {\n      existingBuf,\n      existingPeer\n    } = await this.#findExistingPeer(peerId)\n\n    const peerPb: PeerPB = await toPeerPB(peerId, data, 'merge', {\n      addressFilter: this.addressFilter,\n      existingPeer\n    })\n\n    return this.#saveIfDifferent(peerId, peerPb, existingBuf, existingPeer)\n  }\n\n  async * all (query?: PeerQuery): AsyncGenerator<Peer, void, unknown> {\n    const peerCache = new PeerMap<Peer>()\n\n    for await (const { key, value } of this.datastore.query(mapQuery(query ?? {}, peerCache))) {\n      const peer = decodePeer(key, value, peerCache)\n\n      if (peer.id.equals(this.peerId)) {\n        // Skip self peer if present\n        continue\n      }\n\n      yield peer\n    }\n  }\n\n  async #findExistingPeer (peerId: PeerId): Promise<{ existingBuf?: Uint8Array, existingPeer?: Peer }> {\n    try {\n      const existingBuf = await this.datastore.get(peerIdToDatastoreKey(peerId))\n      const existingPeer = bytesToPeer(peerId, existingBuf)\n\n      return {\n        existingBuf,\n        existingPeer\n      }\n    } catch (err: any) {\n      if (err.code !== 'ERR_NOT_FOUND') {\n        throw err\n      }\n    }\n\n    return {}\n  }\n\n  async #saveIfDifferent (peerId: PeerId, peer: PeerPB, existingBuf?: Uint8Array, existingPeer?: Peer): Promise<PeerUpdate> {\n    const buf = PeerPB.encode(peer)\n\n    if (existingBuf != null && uint8ArrayEquals(buf, existingBuf)) {\n      return {\n        peer: bytesToPeer(peerId, buf),\n        previous: existingPeer,\n        updated: false\n      }\n    }\n\n    await this.datastore.put(peerIdToDatastoreKey(peerId), buf)\n\n    return {\n      peer: bytesToPeer(peerId, buf),\n      previous: existingPeer,\n      updated: true\n    }\n  }\n}\n", "/**\n * @packageDocumentation\n *\n * The peer store is where libp2p stores data about the peers it has encountered on the network.\n */\n\nimport { RecordEnvelope, PeerRecord } from '@libp2p/peer-record'\nimport all from 'it-all'\nimport { PersistentStore, type PeerUpdate } from './store.js'\nimport type { ComponentLogger, Libp2pEvents, Logger, TypedEventTarget, PeerId, PeerStore, Peer, PeerData, PeerQuery } from '@libp2p/interface'\nimport type { Multiaddr } from '@multiformats/multiaddr'\nimport type { Datastore } from 'interface-datastore'\n\nexport interface PersistentPeerStoreComponents {\n  peerId: PeerId\n  datastore: Datastore\n  events: TypedEventTarget<Libp2pEvents>\n  logger: ComponentLogger\n}\n\n/**\n * Return true to allow storing the passed multiaddr for the passed peer\n */\nexport interface AddressFilter {\n  (peerId: PeerId, multiaddr: Multiaddr): Promise<boolean>\n}\n\nexport interface PersistentPeerStoreInit {\n  addressFilter?: AddressFilter\n}\n\n/**\n * An implementation of PeerStore that stores data in a Datastore\n */\nexport class PersistentPeerStore implements PeerStore {\n  private readonly store: PersistentStore\n  private readonly events: TypedEventTarget<Libp2pEvents>\n  private readonly peerId: PeerId\n  private readonly log: Logger\n\n  constructor (components: PersistentPeerStoreComponents, init: PersistentPeerStoreInit = {}) {\n    this.log = components.logger.forComponent('libp2p:peer-store')\n    this.events = components.events\n    this.peerId = components.peerId\n    this.store = new PersistentStore(components, init)\n  }\n\n  async forEach (fn: (peer: Peer,) => void, query?: PeerQuery): Promise<void> {\n    this.log.trace('forEach await read lock')\n    const release = await this.store.lock.readLock()\n    this.log.trace('forEach got read lock')\n\n    try {\n      for await (const peer of this.store.all(query)) {\n        fn(peer)\n      }\n    } finally {\n      this.log.trace('forEach release read lock')\n      release()\n    }\n  }\n\n  async all (query?: PeerQuery): Promise<Peer[]> {\n    this.log.trace('all await read lock')\n    const release = await this.store.lock.readLock()\n    this.log.trace('all got read lock')\n\n    try {\n      return await all(this.store.all(query))\n    } finally {\n      this.log.trace('all release read lock')\n      release()\n    }\n  }\n\n  async delete (peerId: PeerId): Promise<void> {\n    this.log.trace('delete await write lock')\n    const release = await this.store.lock.writeLock()\n    this.log.trace('delete got write lock')\n\n    try {\n      await this.store.delete(peerId)\n    } finally {\n      this.log.trace('delete release write lock')\n      release()\n    }\n  }\n\n  async has (peerId: PeerId): Promise<boolean> {\n    this.log.trace('has await read lock')\n    const release = await this.store.lock.readLock()\n    this.log.trace('has got read lock')\n\n    try {\n      return await this.store.has(peerId)\n    } finally {\n      this.log.trace('has release read lock')\n      release()\n    }\n  }\n\n  async get (peerId: PeerId): Promise<Peer> {\n    this.log.trace('get await read lock')\n    const release = await this.store.lock.readLock()\n    this.log.trace('get got read lock')\n\n    try {\n      return await this.store.load(peerId)\n    } finally {\n      this.log.trace('get release read lock')\n      release()\n    }\n  }\n\n  async save (id: PeerId, data: PeerData): Promise<Peer> {\n    this.log.trace('save await write lock')\n    const release = await this.store.lock.writeLock()\n    this.log.trace('save got write lock')\n\n    try {\n      const result = await this.store.save(id, data)\n\n      this.#emitIfUpdated(id, result)\n\n      return result.peer\n    } finally {\n      this.log.trace('save release write lock')\n      release()\n    }\n  }\n\n  async patch (id: PeerId, data: PeerData): Promise<Peer> {\n    this.log.trace('patch await write lock')\n    const release = await this.store.lock.writeLock()\n    this.log.trace('patch got write lock')\n\n    try {\n      const result = await this.store.patch(id, data)\n\n      this.#emitIfUpdated(id, result)\n\n      return result.peer\n    } finally {\n      this.log.trace('patch release write lock')\n      release()\n    }\n  }\n\n  async merge (id: PeerId, data: PeerData): Promise<Peer> {\n    this.log.trace('merge await write lock')\n    const release = await this.store.lock.writeLock()\n    this.log.trace('merge got write lock')\n\n    try {\n      const result = await this.store.merge(id, data)\n\n      this.#emitIfUpdated(id, result)\n\n      return result.peer\n    } finally {\n      this.log.trace('merge release write lock')\n      release()\n    }\n  }\n\n  async consumePeerRecord (buf: Uint8Array, expectedPeer?: PeerId): Promise<boolean> {\n    const envelope = await RecordEnvelope.openAndCertify(buf, PeerRecord.DOMAIN)\n\n    if (expectedPeer?.equals(envelope.peerId) === false) {\n      this.log('envelope peer id was not the expected peer id - expected: %p received: %p', expectedPeer, envelope.peerId)\n      return false\n    }\n\n    const peerRecord = PeerRecord.createFromProtobuf(envelope.payload)\n    let peer: Peer | undefined\n\n    try {\n      peer = await this.get(envelope.peerId)\n    } catch (err: any) {\n      if (err.code !== 'ERR_NOT_FOUND') {\n        throw err\n      }\n    }\n\n    // ensure seq is greater than, or equal to, the last received\n    if (peer?.peerRecordEnvelope != null) {\n      const storedEnvelope = await RecordEnvelope.createFromProtobuf(peer.peerRecordEnvelope)\n      const storedRecord = PeerRecord.createFromProtobuf(storedEnvelope.payload)\n\n      if (storedRecord.seqNumber >= peerRecord.seqNumber) {\n        this.log('sequence number was lower or equal to existing sequence number - stored: %d received: %d', storedRecord.seqNumber, peerRecord.seqNumber)\n        return false\n      }\n    }\n\n    await this.patch(peerRecord.peerId, {\n      peerRecordEnvelope: buf,\n      addresses: peerRecord.multiaddrs.map(multiaddr => ({\n        isCertified: true,\n        multiaddr\n      }))\n    })\n\n    return true\n  }\n\n  #emitIfUpdated (id: PeerId, result: PeerUpdate): void {\n    if (!result.updated) {\n      return\n    }\n\n    if (this.peerId.equals(id)) {\n      this.events.safeDispatchEvent('self:peer:update', { detail: result })\n    } else {\n      this.events.safeDispatchEvent('peer:update', { detail: result })\n    }\n  }\n}\n", "/**\n * @packageDocumentation\n *\n * Mostly useful for tests or when you want to be explicit about consuming an iterable without doing anything with any yielded values.\n *\n * @example\n *\n * ```javascript\n * import drain from 'it-drain'\n *\n * // This can also be an iterator, generator, etc\n * const values = [0, 1, 2, 3, 4]\n *\n * drain(values)\n * ```\n *\n * Async sources must be awaited:\n *\n * ```javascript\n * import drain from 'it-drain'\n *\n * const values = async function * {\n *   yield * [0, 1, 2, 3, 4]\n * }\n *\n * await drain(values())\n * ```\n */\n\nfunction isAsyncIterable <T> (thing: any): thing is AsyncIterable<T> {\n  return thing[Symbol.asyncIterator] != null\n}\n\n/**\n * Drains an (async) iterable discarding its' content and does not return\n * anything\n */\nfunction drain (source: Iterable<unknown>): void\nfunction drain (source: Iterable<unknown> | AsyncIterable<unknown>): Promise<void>\nfunction drain (source: Iterable<unknown> | AsyncIterable<unknown>): Promise<void> | void {\n  if (isAsyncIterable(source)) {\n    return (async () => {\n      for await (const _ of source) { } // eslint-disable-line no-unused-vars,no-empty,@typescript-eslint/no-unused-vars\n    })()\n  } else {\n    for (const _ of source) { } // eslint-disable-line no-unused-vars,no-empty,@typescript-eslint/no-unused-vars\n  }\n}\n\nexport default drain\n", "/**\n * @packageDocumentation\n *\n * Filter values out of an (async)iterable\n *\n * @example\n *\n * ```javascript\n * import all from 'it-all'\n * import filter from 'it-filter'\n *\n * // This can also be an iterator, generator, etc\n * const values = [0, 1, 2, 3, 4]\n *\n * const fn = (val, index) => val > 2 // Return boolean to keep item\n *\n * const arr = all(filter(values, fn))\n *\n * console.info(arr) // 3, 4\n * ```\n *\n * Async sources and filter functions must be awaited:\n *\n * ```javascript\n * import all from 'it-all'\n * import filter from 'it-filter'\n *\n * const values = async function * () {\n *   yield * [0, 1, 2, 3, 4]\n * }\n *\n * const fn = async val => (val, index) > 2 // Return boolean or promise of boolean to keep item\n *\n * const arr = await all(filter(values, fn))\n *\n * console.info(arr) // 3, 4\n * ```\n */\n\nimport peek from 'it-peekable'\n\nfunction isAsyncIterable <T> (thing: any): thing is AsyncIterable<T> {\n  return thing[Symbol.asyncIterator] != null\n}\n\n/**\n * Filters the passed (async) iterable by using the filter function\n */\nfunction filter <T> (source: Iterable<T>, fn: (val: T, index: number) => Promise<boolean>): AsyncGenerator<T, void, undefined>\nfunction filter <T> (source: Iterable<T>, fn: (val: T, index: number) => boolean): Generator<T, void, undefined>\nfunction filter <T> (source: Iterable<T> | AsyncIterable<T>, fn: (val: T, index: number) => boolean | Promise<boolean>): AsyncGenerator<T, void, undefined>\nfunction filter <T> (source: Iterable<T> | AsyncIterable<T>, fn: (val: T, index: number) => boolean | Promise<boolean>): Generator<T, void, undefined> | AsyncGenerator<T, void, undefined> {\n  let index = 0\n\n  if (isAsyncIterable(source)) {\n    return (async function * () {\n      for await (const entry of source) {\n        if (await fn(entry, index++)) {\n          yield entry\n        }\n      }\n    })()\n  }\n\n  // if mapping function returns a promise we have to return an async generator\n  const peekable = peek(source)\n  const { value, done } = peekable.next()\n\n  if (done === true) {\n    return (function * () {}())\n  }\n\n  const res = fn(value, index++)\n\n  // @ts-expect-error .then is not present on O\n  if (typeof res.then === 'function') {\n    return (async function * () {\n      if (await res) {\n        yield value\n      }\n\n      for await (const entry of peekable) {\n        if (await fn(entry, index++)) {\n          yield entry\n        }\n      }\n    })()\n  }\n\n  const func = fn as (val: T, index: number) => boolean\n\n  return (function * () {\n    if (res === true) {\n      yield value\n    }\n\n    for (const entry of peekable) {\n      if (func(entry, index++)) {\n        yield entry\n      }\n    }\n  })()\n}\n\nexport default filter\n", "/**\n * @packageDocumentation\n *\n * Consumes all values from an (async)iterable and returns them sorted by the passed sort function.\n *\n * @example\n *\n * ```javascript\n * import sort from 'it-sort'\n * import all from 'it-all'\n *\n * const sorter = (a, b) => {\n *   return a.localeCompare(b)\n * }\n *\n * // This can also be an iterator, generator, etc\n * const values = ['foo', 'bar']\n *\n * const arr = all(sort(values, sorter))\n *\n * console.info(arr) // 'bar', 'foo'\n * ```\n *\n * Async sources must be awaited:\n *\n * ```javascript\n * import sort from 'it-sort'\n * import all from 'it-all'\n *\n * const sorter = (a, b) => {\n *   return a.localeCompare(b)\n * }\n *\n * const values = async function * () {\n *   yield * ['foo', 'bar']\n * }\n *\n * const arr = await all(sort(values, sorter))\n *\n * console.info(arr) // 'bar', 'foo'\n * ```\n */\n\nimport all from 'it-all'\n\nfunction isAsyncIterable <T> (thing: any): thing is AsyncIterable<T> {\n  return thing[Symbol.asyncIterator] != null\n}\n\nexport interface CompareFunction<T> {\n  (a: T, b: T): number\n}\n\n/**\n * Collects all values from an async iterator, sorts them\n * using the passed function and yields them\n */\nfunction sort <T> (source: Iterable<T>, sorter: CompareFunction<T>): Generator<T, void, undefined>\nfunction sort <T> (source: Iterable<T> | AsyncIterable<T>, sorter: CompareFunction<T>): AsyncGenerator<T, void, undefined>\nfunction sort <T> (source: Iterable<T> | AsyncIterable<T>, sorter: CompareFunction<T>): AsyncGenerator<T, void, undefined> | Generator<T, void, undefined> {\n  if (isAsyncIterable(source)) {\n    return (async function * () {\n      const arr = await all(source)\n\n      yield * arr.sort(sorter)\n    })()\n  }\n\n  return (function * () {\n    const arr = all(source)\n\n    yield * arr.sort(sorter)\n  })()\n}\n\nexport default sort\n", "/**\n * @packageDocumentation\n *\n * For when you only want a few values out of an (async)iterable.\n *\n * @example\n *\n * ```javascript\n * import take from 'it-take'\n * import all from 'it-all'\n *\n * // This can also be an iterator, generator, etc\n * const values = [0, 1, 2, 3, 4]\n *\n * const arr = all(take(values, 2))\n *\n * console.info(arr) // 0, 1\n * ```\n *\n * Async sources must be awaited:\n *\n * ```javascript\n * import take from 'it-take'\n * import all from 'it-all'\n *\n * const values = async function * () {\n *   yield * [0, 1, 2, 3, 4]\n * }\n *\n * const arr = await all(take(values(), 2))\n *\n * console.info(arr) // 0, 1\n * ```\n */\n\nfunction isAsyncIterable <T> (thing: any): thing is AsyncIterable<T> {\n  return thing[Symbol.asyncIterator] != null\n}\n\n/**\n * Stop iteration after n items have been received\n */\nfunction take <T> (source: Iterable<T>, limit: number): Generator<T, void, undefined>\nfunction take <T> (source: Iterable<T> | AsyncIterable<T>, limit: number): AsyncGenerator<T, void, undefined>\nfunction take <T> (source: Iterable<T> | AsyncIterable<T>, limit: number): AsyncGenerator<T, void, undefined> | Generator<T, void, undefined> {\n  if (isAsyncIterable(source)) {\n    return (async function * () {\n      let items = 0\n\n      if (limit < 1) {\n        return\n      }\n\n      for await (const entry of source) {\n        yield entry\n\n        items++\n\n        if (items === limit) {\n          return\n        }\n      }\n    })()\n  }\n\n  return (function * () {\n    let items = 0\n\n    if (limit < 1) {\n      return\n    }\n\n    for (const entry of source) {\n      yield entry\n\n      items++\n\n      if (items === limit) {\n        return\n      }\n    }\n  })()\n}\n\nexport default take\n", "import drain from 'it-drain'\nimport filter from 'it-filter'\nimport sort from 'it-sort'\nimport take from 'it-take'\nimport type { Batch, Datastore, Key, KeyQuery, Pair, Query } from 'interface-datastore'\nimport type { AbortOptions, Await, AwaitIterable } from 'interface-store'\n\nexport class BaseDatastore implements Datastore {\n  put (key: Key, val: Uint8Array, options?: AbortOptions): Await<Key> {\n    return Promise.reject(new Error('.put is not implemented'))\n  }\n\n  get (key: Key, options?: AbortOptions): Await<Uint8Array> {\n    return Promise.reject(new Error('.get is not implemented'))\n  }\n\n  has (key: Key, options?: AbortOptions): Await<boolean> {\n    return Promise.reject(new Error('.has is not implemented'))\n  }\n\n  delete (key: Key, options?: AbortOptions): Await<void> {\n    return Promise.reject(new Error('.delete is not implemented'))\n  }\n\n  async * putMany (source: AwaitIterable<Pair>, options: AbortOptions = {}): AwaitIterable<Key> {\n    for await (const { key, value } of source) {\n      await this.put(key, value, options)\n      yield key\n    }\n  }\n\n  async * getMany (source: AwaitIterable<Key>, options: AbortOptions = {}): AwaitIterable<Pair> {\n    for await (const key of source) {\n      yield {\n        key,\n        value: await this.get(key, options)\n      }\n    }\n  }\n\n  async * deleteMany (source: AwaitIterable<Key>, options: AbortOptions = {}): AwaitIterable<Key> {\n    for await (const key of source) {\n      await this.delete(key, options)\n      yield key\n    }\n  }\n\n  batch (): Batch {\n    let puts: Pair[] = []\n    let dels: Key[] = []\n\n    return {\n      put (key, value) {\n        puts.push({ key, value })\n      },\n\n      delete (key) {\n        dels.push(key)\n      },\n      commit: async (options) => {\n        await drain(this.putMany(puts, options))\n        puts = []\n        await drain(this.deleteMany(dels, options))\n        dels = []\n      }\n    }\n  }\n\n  /**\n   * Extending classes should override `query` or implement this method\n   */\n  // eslint-disable-next-line require-yield\n  async * _all (q: Query, options?: AbortOptions): AwaitIterable<Pair> {\n    throw new Error('._all is not implemented')\n  }\n\n  /**\n   * Extending classes should override `queryKeys` or implement this method\n   */\n  // eslint-disable-next-line require-yield\n  async * _allKeys (q: KeyQuery, options?: AbortOptions): AwaitIterable<Key> {\n    throw new Error('._allKeys is not implemented')\n  }\n\n  query (q: Query, options?: AbortOptions): AwaitIterable<Pair> {\n    let it = this._all(q, options)\n\n    if (q.prefix != null) {\n      const prefix = q.prefix\n      it = filter(it, (e) => e.key.toString().startsWith(prefix))\n    }\n\n    if (Array.isArray(q.filters)) {\n      it = q.filters.reduce((it, f) => filter(it, f), it)\n    }\n\n    if (Array.isArray(q.orders)) {\n      it = q.orders.reduce((it, f) => sort(it, f), it)\n    }\n\n    if (q.offset != null) {\n      let i = 0\n      const offset = q.offset\n      it = filter(it, () => i++ >= offset)\n    }\n\n    if (q.limit != null) {\n      it = take(it, q.limit)\n    }\n\n    return it\n  }\n\n  queryKeys (q: KeyQuery, options?: AbortOptions): AwaitIterable<Key> {\n    let it = this._allKeys(q, options)\n\n    if (q.prefix != null) {\n      const prefix = q.prefix\n      it = filter(it, (key) =>\n        key.toString().startsWith(prefix)\n      )\n    }\n\n    if (Array.isArray(q.filters)) {\n      it = q.filters.reduce((it, f) => filter(it, f), it)\n    }\n\n    if (Array.isArray(q.orders)) {\n      it = q.orders.reduce((it, f) => sort(it, f), it)\n    }\n\n    if (q.offset != null) {\n      const offset = q.offset\n      let i = 0\n      it = filter(it, () => i++ >= offset)\n    }\n\n    if (q.limit != null) {\n      it = take(it, q.limit)\n    }\n\n    return it\n  }\n}\n", "import errCode from 'err-code'\n\nexport function dbOpenFailedError (err?: Error): Error {\n  err = err ?? new Error('Cannot open database')\n  return errCode(err, 'ERR_DB_OPEN_FAILED')\n}\n\nexport function dbDeleteFailedError (err?: Error): Error {\n  err = err ?? new Error('Delete failed')\n  return errCode(err, 'ERR_DB_DELETE_FAILED')\n}\n\nexport function dbWriteFailedError (err?: Error): Error {\n  err = err ?? new Error('Write failed')\n  return errCode(err, 'ERR_DB_WRITE_FAILED')\n}\n\nexport function dbReadFailedError (err?: Error): Error {\n  err = err ?? new Error('Read failed')\n  return errCode(err, 'ERR_DB_READ_FAILED')\n}\n\nexport function notFoundError (err?: Error): Error {\n  err = err ?? new Error('Not Found')\n  return errCode(err, 'ERR_NOT_FOUND')\n}\n\nexport function abortedError (err?: Error): Error {\n  err = err ?? new Error('Aborted')\n  return errCode(err, 'ERR_ABORTED')\n}\n", "import { Key } from 'interface-datastore/key'\nimport { BaseDatastore } from './base.js'\nimport * as Errors from './errors.js'\nimport type { Pair } from 'interface-datastore'\nimport type { Await, AwaitIterable } from 'interface-store'\n\nexport class MemoryDatastore extends BaseDatastore {\n  private readonly data: Map<string, Uint8Array>\n\n  constructor () {\n    super()\n\n    this.data = new Map()\n  }\n\n  put (key: Key, val: Uint8Array): Await<Key> { // eslint-disable-line require-await\n    this.data.set(key.toString(), val)\n\n    return key\n  }\n\n  get (key: Key): Await<Uint8Array> {\n    const result = this.data.get(key.toString())\n\n    if (result == null) {\n      throw Errors.notFoundError()\n    }\n\n    return result\n  }\n\n  has (key: Key): Await<boolean> { // eslint-disable-line require-await\n    return this.data.has(key.toString())\n  }\n\n  delete (key: Key): Await<void> { // eslint-disable-line require-await\n    this.data.delete(key.toString())\n  }\n\n  * _all (): AwaitIterable<Pair> {\n    for (const [key, value] of this.data.entries()) {\n      yield { key: new Key(key), value }\n    }\n  }\n\n  * _allKeys (): AwaitIterable<Key> {\n    for (const key of this.data.keys()) {\n      yield new Key(key)\n    }\n  }\n}\n", "export function debounce (func: () => void, wait: number): () => void {\n  let timeout: ReturnType<typeof setTimeout> | undefined\n\n  return function () {\n    const later = function (): void {\n      timeout = undefined\n      func()\n    }\n\n    clearTimeout(timeout)\n    timeout = setTimeout(later, wait)\n  }\n}\n", "import { peerIdFromString } from '@libp2p/peer-id'\nimport { multiaddr } from '@multiformats/multiaddr'\nimport { debounce } from './utils.js'\nimport type { ComponentLogger, Libp2pEvents, Logger, TypedEventTarget, PeerId, PeerStore } from '@libp2p/interface'\nimport type { TransportManager } from '@libp2p/interface-internal'\nimport type { Multiaddr } from '@multiformats/multiaddr'\n\nexport interface AddressManagerInit {\n  /**\n   * Pass an function in this field to override the list of addresses\n   * that are announced to the network\n   */\n  announceFilter?: AddressFilter\n\n  /**\n   * list of multiaddrs string representation to listen\n   */\n  listen?: string[]\n\n  /**\n   * list of multiaddrs string representation to announce\n   */\n  announce?: string[]\n\n  /**\n   * list of multiaddrs string representation to never announce\n   */\n  noAnnounce?: string[]\n}\n\nexport interface DefaultAddressManagerComponents {\n  peerId: PeerId\n  transportManager: TransportManager\n  peerStore: PeerStore\n  events: TypedEventTarget<Libp2pEvents>\n  logger: ComponentLogger\n}\n\n/**\n * A function that takes a list of multiaddrs and returns a list\n * to announce\n */\nexport interface AddressFilter {\n  (addrs: Multiaddr[]): Multiaddr[]\n}\n\nconst defaultAddressFilter = (addrs: Multiaddr[]): Multiaddr[] => addrs\n\ninterface ObservedAddressMetadata {\n  confident: boolean\n}\n\n/**\n * If the passed multiaddr contains the passed peer id, remove it\n */\nfunction stripPeerId (ma: Multiaddr, peerId: PeerId): Multiaddr {\n  const observedPeerIdStr = ma.getPeerId()\n\n  // strip our peer id if it has been passed\n  if (observedPeerIdStr != null) {\n    const observedPeerId = peerIdFromString(observedPeerIdStr)\n\n    // use same encoding for comparison\n    if (observedPeerId.equals(peerId)) {\n      ma = ma.decapsulate(multiaddr(`/p2p/${peerId.toString()}`))\n    }\n  }\n\n  return ma\n}\n\nexport class DefaultAddressManager {\n  private readonly log: Logger\n  private readonly components: DefaultAddressManagerComponents\n  // this is an array to allow for duplicates, e.g. multiples of `/ip4/0.0.0.0/tcp/0`\n  private readonly listen: string[]\n  private readonly announce: Set<string>\n  private readonly observed: Map<string, ObservedAddressMetadata>\n  private readonly announceFilter: AddressFilter\n\n  /**\n   * Responsible for managing the peer addresses.\n   * Peers can specify their listen and announce addresses.\n   * The listen addresses will be used by the libp2p transports to listen for new connections,\n   * while the announce addresses will be used for the peer addresses' to other peers in the network.\n   */\n  constructor (components: DefaultAddressManagerComponents, init: AddressManagerInit = {}) {\n    const { listen = [], announce = [] } = init\n\n    this.components = components\n    this.log = components.logger.forComponent('libp2p:address-manager')\n    this.listen = listen.map(ma => ma.toString())\n    this.announce = new Set(announce.map(ma => ma.toString()))\n    this.observed = new Map()\n    this.announceFilter = init.announceFilter ?? defaultAddressFilter\n\n    // this method gets called repeatedly on startup when transports start listening so\n    // debounce it so we don't cause multiple self:peer:update events to be emitted\n    this._updatePeerStoreAddresses = debounce(this._updatePeerStoreAddresses.bind(this), 1000)\n\n    // update our stored addresses when new transports listen\n    components.events.addEventListener('transport:listening', () => {\n      this._updatePeerStoreAddresses()\n    })\n    // update our stored addresses when existing transports stop listening\n    components.events.addEventListener('transport:close', () => {\n      this._updatePeerStoreAddresses()\n    })\n  }\n\n  _updatePeerStoreAddresses (): void {\n    // if announce addresses have been configured, ensure they make it into our peer\n    // record for things like identify\n    const addrs = this.getAnnounceAddrs()\n      .concat(this.components.transportManager.getAddrs())\n      .concat(\n        [...this.observed.entries()]\n          .filter(([_, metadata]) => metadata.confident)\n          .map(([str]) => multiaddr(str))\n      ).map(ma => {\n        // strip our peer id if it is present\n        if (ma.getPeerId() === this.components.peerId.toString()) {\n          return ma.decapsulate(`/p2p/${this.components.peerId.toString()}`)\n        }\n\n        return ma\n      })\n\n    this.components.peerStore.patch(this.components.peerId, {\n      multiaddrs: addrs\n    })\n      .catch(err => { this.log.error('error updating addresses', err) })\n  }\n\n  /**\n   * Get peer listen multiaddrs\n   */\n  getListenAddrs (): Multiaddr[] {\n    return Array.from(this.listen).map((a) => multiaddr(a))\n  }\n\n  /**\n   * Get peer announcing multiaddrs\n   */\n  getAnnounceAddrs (): Multiaddr[] {\n    return Array.from(this.announce).map((a) => multiaddr(a))\n  }\n\n  /**\n   * Get observed multiaddrs\n   */\n  getObservedAddrs (): Multiaddr[] {\n    return Array.from(this.observed).map(([a]) => multiaddr(a))\n  }\n\n  /**\n   * Add peer observed addresses\n   */\n  addObservedAddr (addr: Multiaddr): void {\n    addr = stripPeerId(addr, this.components.peerId)\n    const addrString = addr.toString()\n\n    // do not trigger the change:addresses event if we already know about this address\n    if (this.observed.has(addrString)) {\n      return\n    }\n\n    this.observed.set(addrString, {\n      confident: false\n    })\n  }\n\n  confirmObservedAddr (addr: Multiaddr): void {\n    addr = stripPeerId(addr, this.components.peerId)\n    const addrString = addr.toString()\n\n    const metadata = this.observed.get(addrString) ?? {\n      confident: false\n    }\n\n    const startingConfidence = metadata.confident\n\n    this.observed.set(addrString, {\n      confident: true\n    })\n\n    // only trigger the 'self:peer:update' event if our confidence in an address has changed\n    if (!startingConfidence) {\n      this._updatePeerStoreAddresses()\n    }\n  }\n\n  removeObservedAddr (addr: Multiaddr): void {\n    addr = stripPeerId(addr, this.components.peerId)\n    const addrString = addr.toString()\n\n    this.observed.delete(addrString)\n  }\n\n  getAddresses (): Multiaddr[] {\n    let addrs = this.getAnnounceAddrs().map(ma => ma.toString())\n\n    if (addrs.length === 0) {\n      // no configured announce addrs, add configured listen addresses\n      addrs = this.components.transportManager.getAddrs().map(ma => ma.toString())\n    }\n\n    // add observed addresses we are confident in\n    addrs = addrs.concat(\n      Array.from(this.observed)\n        .filter(([ma, metadata]) => metadata.confident)\n        .map(([ma]) => ma)\n    )\n\n    // dedupe multiaddrs\n    const addrSet = new Set(addrs)\n\n    // Create advertising list\n    return this.announceFilter(Array.from(addrSet)\n      .map(str => multiaddr(str)))\n      .map(ma => {\n        // do not append our peer id to a path multiaddr as it will become invalid\n        if (ma.protos().pop()?.path === true) {\n          return ma\n        }\n\n        if (ma.getPeerId() === this.components.peerId.toString()) {\n          return ma\n        }\n\n        return ma.encapsulate(`/p2p/${this.components.peerId.toString()}`)\n      })\n  }\n}\n", "import { CodeError } from '@libp2p/interface'\nimport { isStartable, type Startable, type Libp2pEvents, type ComponentLogger, type NodeInfo, type ConnectionProtector, type ConnectionGater, type ContentRouting, type TypedEventTarget, type Metrics, type PeerId, type PeerRouting, type PeerStore, type PrivateKey, type Upgrader } from '@libp2p/interface'\nimport { defaultLogger } from '@libp2p/logger'\nimport type { AddressManager, ConnectionManager, Registrar, TransportManager } from '@libp2p/interface-internal'\nimport type { DNS } from '@multiformats/dns'\nimport type { Datastore } from 'interface-datastore'\n\nexport interface Components extends Record<string, any>, Startable {\n  peerId: PeerId\n  privateKey: PrivateKey\n  nodeInfo: NodeInfo\n  logger: ComponentLogger\n  events: TypedEventTarget<Libp2pEvents>\n  addressManager: AddressManager\n  peerStore: PeerStore\n  upgrader: Upgrader\n  registrar: Registrar\n  connectionManager: ConnectionManager\n  transportManager: TransportManager\n  connectionGater: ConnectionGater\n  contentRouting: ContentRouting\n  peerRouting: PeerRouting\n  datastore: Datastore\n  connectionProtector?: ConnectionProtector\n  metrics?: Metrics\n  dns?: DNS\n}\n\nexport interface ComponentsInit {\n  peerId?: PeerId\n  privateKey?: PrivateKey\n  nodeInfo?: NodeInfo\n  logger?: ComponentLogger\n  events?: TypedEventTarget<Libp2pEvents>\n  addressManager?: AddressManager\n  peerStore?: PeerStore\n  upgrader?: Upgrader\n  metrics?: Metrics\n  registrar?: Registrar\n  connectionManager?: ConnectionManager\n  transportManager?: TransportManager\n  connectionGater?: ConnectionGater\n  contentRouting?: ContentRouting\n  peerRouting?: PeerRouting\n  datastore?: Datastore\n  connectionProtector?: ConnectionProtector\n  dns?: DNS\n}\n\nclass DefaultComponents implements Startable {\n  public components: Record<string, any> = {}\n  private _started = false\n\n  constructor (init: ComponentsInit = {}) {\n    this.components = {}\n\n    for (const [key, value] of Object.entries(init)) {\n      this.components[key] = value\n    }\n\n    if (this.components.logger == null) {\n      this.components.logger = defaultLogger()\n    }\n  }\n\n  isStarted (): boolean {\n    return this._started\n  }\n\n  private async _invokeStartableMethod (methodName: 'beforeStart' | 'start' | 'afterStart' | 'beforeStop' | 'stop' | 'afterStop'): Promise<void> {\n    await Promise.all(\n      Object.values(this.components)\n        .filter(obj => isStartable(obj))\n        .map(async (startable: Startable) => {\n          await startable[methodName]?.()\n        })\n    )\n  }\n\n  async beforeStart (): Promise<void> {\n    await this._invokeStartableMethod('beforeStart')\n  }\n\n  async start (): Promise<void> {\n    await this._invokeStartableMethod('start')\n    this._started = true\n  }\n\n  async afterStart (): Promise<void> {\n    await this._invokeStartableMethod('afterStart')\n  }\n\n  async beforeStop (): Promise<void> {\n    await this._invokeStartableMethod('beforeStop')\n  }\n\n  async stop (): Promise<void> {\n    await this._invokeStartableMethod('stop')\n    this._started = false\n  }\n\n  async afterStop (): Promise<void> {\n    await this._invokeStartableMethod('afterStop')\n  }\n}\n\nconst OPTIONAL_SERVICES = [\n  'metrics',\n  'connectionProtector',\n  'dns'\n]\n\nconst NON_SERVICE_PROPERTIES = [\n  'components',\n  'isStarted',\n  'beforeStart',\n  'start',\n  'afterStart',\n  'beforeStop',\n  'stop',\n  'afterStop',\n  'then',\n  '_invokeStartableMethod'\n]\n\nexport function defaultComponents (init: ComponentsInit = {}): Components {\n  const components = new DefaultComponents(init)\n\n  const proxy = new Proxy(components, {\n    get (target, prop, receiver) {\n      if (typeof prop === 'string' && !NON_SERVICE_PROPERTIES.includes(prop)) {\n        const service = components.components[prop]\n\n        if (service == null && !OPTIONAL_SERVICES.includes(prop)) {\n          throw new CodeError(`${prop} not set`, 'ERR_SERVICE_MISSING')\n        }\n\n        return service\n      }\n\n      return Reflect.get(target, prop, receiver)\n    },\n\n    set (target, prop, value) {\n      if (typeof prop === 'string') {\n        components.components[prop] = value\n      } else {\n        Reflect.set(target, prop, value)\n      }\n\n      return true\n    }\n  })\n\n  // @ts-expect-error component keys are proxied\n  return proxy\n}\n", "import { isPrivateIp } from '@libp2p/utils/private-ip'\nimport type { ConnectionGater } from '@libp2p/interface'\nimport type { Multiaddr } from '@multiformats/multiaddr'\n\n/**\n * Returns a connection gater that disallows dialling private addresses by\n * default. Browsers are severely limited in their resource usage so don't\n * waste time trying to dial undiallable addresses.\n */\nexport function connectionGater (gater: ConnectionGater = {}): ConnectionGater {\n  return {\n    denyDialPeer: async () => false,\n    denyDialMultiaddr: async (multiaddr: Multiaddr) => {\n      const tuples = multiaddr.stringTuples()\n\n      if (tuples[0][0] === 4 || tuples[0][0] === 41) {\n        return Boolean(isPrivateIp(`${tuples[0][1]}`))\n      }\n\n      return false\n    },\n    denyInboundConnection: async () => false,\n    denyOutboundConnection: async () => false,\n    denyInboundEncryptedConnection: async () => false,\n    denyOutboundEncryptedConnection: async () => false,\n    denyInboundUpgradedConnection: async () => false,\n    denyOutboundUpgradedConnection: async () => false,\n    filterMultiaddrForPeer: async () => true,\n    ...gater\n  }\n}\n", "import { isPrivateIp } from '../private-ip.js'\nimport type { Multiaddr } from '@multiformats/multiaddr'\n\n/**\n * Check if a given multiaddr has a private address.\n */\nexport function isPrivate (ma: Multiaddr): boolean {\n  try {\n    const { address } = ma.nodeAddress()\n\n    return Boolean(isPrivateIp(address))\n  } catch {\n    return true\n  }\n}\n", "/**\n * @packageDocumentation\n *\n * Provides strategies to sort a list of multiaddrs.\n *\n * @example\n *\n * ```typescript\n * import { publicAddressesFirst } from '@libp2p/utils/address-sort'\n * import { multiaddr } from '@multformats/multiaddr'\n *\n *\n * const addresses = [\n *   multiaddr('/ip4/127.0.0.1/tcp/9000'),\n *   multiaddr('/ip4/82.41.53.1/tcp/9000')\n * ].sort(publicAddressesFirst)\n *\n * console.info(addresses)\n * // ['/ip4/82.41.53.1/tcp/9000', '/ip4/127.0.0.1/tcp/9000']\n * ```\n */\n\nimport { Circuit } from '@multiformats/multiaddr-matcher'\nimport { isPrivate } from './multiaddr/is-private.js'\nimport type { Address } from '@libp2p/interface'\n\n/**\n * Compare function for array.sort() that moves public addresses to the start\n * of the array.\n */\nexport function publicAddressesFirst (a: Address, b: Address): -1 | 0 | 1 {\n  const isAPrivate = isPrivate(a.multiaddr)\n  const isBPrivate = isPrivate(b.multiaddr)\n\n  if (isAPrivate && !isBPrivate) {\n    return 1\n  } else if (!isAPrivate && isBPrivate) {\n    return -1\n  }\n\n  return 0\n}\n\n/**\n * Compare function for array.sort() that moves certified addresses to the start\n * of the array.\n */\nexport function certifiedAddressesFirst (a: Address, b: Address): -1 | 0 | 1 {\n  if (a.isCertified && !b.isCertified) {\n    return -1\n  } else if (!a.isCertified && b.isCertified) {\n    return 1\n  }\n\n  return 0\n}\n\n/**\n * Compare function for array.sort() that moves circuit relay addresses to the\n * start of the array.\n */\nexport function circuitRelayAddressesLast (a: Address, b: Address): -1 | 0 | 1 {\n  const isACircuit = Circuit.exactMatch(a.multiaddr)\n  const isBCircuit = Circuit.exactMatch(b.multiaddr)\n\n  if (isACircuit && !isBCircuit) {\n    return 1\n  } else if (!isACircuit && isBCircuit) {\n    return -1\n  }\n\n  return 0\n}\n\nexport function defaultAddressSort (a: Address, b: Address): -1 | 0 | 1 {\n  const publicResult = publicAddressesFirst(a, b)\n\n  if (publicResult !== 0) {\n    return publicResult\n  }\n\n  const relayResult = circuitRelayAddressesLast(a, b)\n\n  if (relayResult !== 0) {\n    return relayResult\n  }\n\n  const certifiedResult = certifiedAddressesFirst(a, b)\n\n  return certifiedResult\n}\n", "\n/**\n * Progress events are emitted during long running operations\n */\nexport interface ProgressEvent<T extends string = any, D = unknown> {\n  /**\n   * The event type\n   */\n  type: T\n\n  /**\n   * Context-specific event information\n   */\n  detail: D\n}\n\n/**\n * An implementation of the ProgressEvent interface, this is essentially\n * a typed `CustomEvent` with a `type` property that lets us disambiguate\n * events passed to `progress` callbacks.\n */\nexport class CustomProgressEvent<D = unknown, T extends string = any> extends Event implements ProgressEvent<T, D> {\n  // @ts-expect-error type is a property of Event, we just declare it here for use as a type disambiguator\n  public type: T\n  public detail: D\n\n  constructor (type: T, detail?: any) {\n    super(type)\n\n    this.detail = detail\n  }\n}\n\n/**\n * Define an `onProgress` callback that can be invoked with `ProgressEvent`s\n *\n * @example\n *\n * ```typescript\n * type MyOperationProgressEvents =\n *   ProgressEvent<'operation:start'> |\n *   ProgressEvent<'operation:success', Result> |\n *   ProgressEvent<'operation:error', Error>\n *\n * export interface MyOperationOptions extends ProgressOptions<MyOperationProgressEvents> {\n *  // define options here\n * }\n * ```\n */\nexport interface ProgressOptions<Event extends ProgressEvent = any> {\n  onProgress?: (evt: Event) => void\n}\n", "import { RecordType } from '../index.js'\n\nexport function getTypes (types?: RecordType | RecordType[]): RecordType[] {\n  const DEFAULT_TYPES = [\n    RecordType.A\n  ]\n\n  if (types == null) {\n    return DEFAULT_TYPES\n  }\n\n  if (Array.isArray(types)) {\n    if (types.length === 0) {\n      return DEFAULT_TYPES\n    }\n\n    return types\n  }\n\n  return [\n    types\n  ]\n}\n", "import { toString as uint8ArrayToString } from 'uint8arrays/to-string'\nimport { RecordType, type DNSResponse } from '../index.js'\n\n/**\n * This TTL will be used if the remote service does not return one\n */\nexport const DEFAULT_TTL = 60\n\nexport function toDNSResponse (obj: any): DNSResponse {\n  return {\n    Status: obj.Status ?? 0,\n    TC: obj.TC ?? obj.flag_tc ?? false,\n    RD: obj.RD ?? obj.flag_rd ?? false,\n    RA: obj.RA ?? obj.flag_ra ?? false,\n    AD: obj.AD ?? obj.flag_ad ?? false,\n    CD: obj.CD ?? obj.flag_cd ?? false,\n    Question: (obj.Question ?? obj.questions ?? []).map((question: any) => {\n      return {\n        name: question.name,\n        type: RecordType[question.type]\n      }\n    }),\n    Answer: (obj.Answer ?? obj.answers ?? []).map((answer: any) => {\n      return {\n        name: answer.name,\n        type: RecordType[answer.type],\n        TTL: (answer.TTL ?? answer.ttl ?? DEFAULT_TTL),\n        data: answer.data instanceof Uint8Array ? uint8ArrayToString(answer.data) : answer.data\n      }\n    })\n  }\n}\n", "/* eslint-env browser */\n\nimport PQueue from 'p-queue'\nimport { CustomProgressEvent } from 'progress-events'\nimport { RecordType, type DNSResponse } from '../index.js'\nimport { getTypes } from '../utils/get-types.js'\nimport { toDNSResponse } from '../utils/to-dns-response.js'\nimport type { DNSResolver } from './index.js'\n\n/**\n * Browsers limit concurrent connections per host (~6), we don't want to exhaust\n * the limit so this value controls how many DNS queries can be in flight at\n * once.\n */\nexport const DEFAULT_QUERY_CONCURRENCY = 4\n\nexport interface DNSJSONOverHTTPSOptions {\n  queryConcurrency?: number\n}\n\n/**\n * Uses the RFC 8427 'application/dns-json' content-type to resolve DNS queries.\n *\n * Supports and server that uses the same schema as Google's DNS over HTTPS\n * resolver.\n *\n * This resolver needs fewer dependencies than the regular DNS-over-HTTPS\n * resolver so can result in a smaller bundle size and consequently is preferred\n * for browser use.\n *\n * @see https://developers.cloudflare.com/1.1.1.1/encryption/dns-over-https/make-api-requests/dns-json/\n * @see https://github.com/curl/curl/wiki/DNS-over-HTTPS#publicly-available-servers\n * @see https://dnsprivacy.org/public_resolvers/\n * @see https://datatracker.ietf.org/doc/html/rfc8427\n */\nexport function dnsJsonOverHttps (url: string, init: DNSJSONOverHTTPSOptions = {}): DNSResolver {\n  const httpQueue = new PQueue({\n    concurrency: init.queryConcurrency ?? DEFAULT_QUERY_CONCURRENCY\n  })\n\n  return async (fqdn, options = {}) => {\n    const searchParams = new URLSearchParams()\n    searchParams.set('name', fqdn)\n\n    getTypes(options.types).forEach(type => {\n      // We pass record type as a string to the server because cloudflare DNS bug. see https://github.com/ipfs/helia/issues/474\n      searchParams.append('type', RecordType[type])\n    })\n\n    options.onProgress?.(new CustomProgressEvent<string>('dns:query', { detail: fqdn }))\n\n    // query DNS-JSON over HTTPS server\n    const response = await httpQueue.add(async () => {\n      const res = await fetch(`${url}?${searchParams}`, {\n        headers: {\n          accept: 'application/dns-json'\n        },\n        signal: options?.signal\n      })\n\n      if (res.status !== 200) {\n        throw new Error(`Unexpected HTTP status: ${res.status} - ${res.statusText}`)\n      }\n\n      const response = toDNSResponse(await res.json())\n\n      options.onProgress?.(new CustomProgressEvent<DNSResponse>('dns:response', { detail: response }))\n\n      return response\n    }, {\n      signal: options.signal\n    })\n\n    if (response == null) {\n      throw new Error('No DNS response received')\n    }\n\n    return response\n  }\n}\n", "import { dnsJsonOverHttps } from './dns-json-over-https.js'\nimport type { DNSResolver } from './index.js'\n\nexport function defaultResolver (): DNSResolver[] {\n  return [\n    dnsJsonOverHttps('https://cloudflare-dns.com/dns-query'),\n    dnsJsonOverHttps('https://dns.google/resolve')\n  ]\n}\n", "import hashlru from 'hashlru'\nimport { RecordType } from '../index.js'\nimport { DEFAULT_TTL, toDNSResponse } from './to-dns-response.js'\nimport type { Answer, DNSResponse } from '../index.js'\n\ninterface CachedAnswer {\n  expires: number\n  value: Answer\n}\n\nexport interface AnswerCache {\n  get (fqdn: string, types: RecordType[]): DNSResponse | undefined\n  add (domain: string, answer: Answer): void\n  remove (domain: string, type: ResponseType): void\n  clear (): void\n}\n\n/**\n * Time Aware Least Recent Used Cache\n *\n * @see https://arxiv.org/pdf/1801.00390\n */\nclass CachedAnswers {\n  private readonly lru: ReturnType<typeof hashlru>\n\n  constructor (maxSize: number) {\n    this.lru = hashlru(maxSize)\n  }\n\n  get (fqdn: string, types: RecordType[]): DNSResponse | undefined {\n    let foundAllAnswers = true\n    const answers: Answer[] = []\n\n    for (const type of types) {\n      const cached = this.getAnswers(fqdn, type)\n\n      if (cached.length === 0) {\n        foundAllAnswers = false\n        break\n      }\n\n      answers.push(...cached)\n    }\n\n    if (foundAllAnswers) {\n      return toDNSResponse({ answers })\n    }\n  }\n\n  private getAnswers (domain: string, type: RecordType): Answer[] {\n    const key = `${domain.toLowerCase()}-${type}`\n    const answers: CachedAnswer[] = this.lru.get(key)\n\n    if (answers != null) {\n      const cachedAnswers = answers\n        .filter((entry) => {\n          return entry.expires > Date.now()\n        })\n        .map(({ expires, value }) => ({\n          ...value,\n          TTL: Math.round((expires - Date.now()) / 1000),\n          type: RecordType[value.type]\n        }))\n\n      if (cachedAnswers.length === 0) {\n        this.lru.remove(key)\n      }\n\n      // @ts-expect-error hashlru stringifies stored types which turns enums\n      // into strings, we convert back into enums above but tsc doesn't know\n      return cachedAnswers\n    }\n\n    return []\n  }\n\n  add (domain: string, answer: Answer): void {\n    const key = `${domain.toLowerCase()}-${answer.type}`\n\n    const answers: CachedAnswer[] = this.lru.get(key) ?? []\n    answers.push({\n      expires: Date.now() + ((answer.TTL ?? DEFAULT_TTL) * 1000),\n      value: answer\n    })\n\n    this.lru.set(key, answers)\n  }\n\n  remove (domain: string, type: ResponseType): void {\n    const key = `${domain.toLowerCase()}-${type}`\n\n    this.lru.remove(key)\n  }\n\n  clear (): void {\n    this.lru.clear()\n  }\n}\n\n/**\n * Avoid sending multiple queries for the same hostname by caching results\n */\nexport function cache (size: number): AnswerCache {\n  return new CachedAnswers(size)\n}\n", "import { CustomProgressEvent } from 'progress-events'\nimport { defaultResolver } from './resolvers/default.js'\nimport { cache } from './utils/cache.js'\nimport { getTypes } from './utils/get-types.js'\nimport type { DNS as DNSInterface, DNSInit, DNSResponse, QueryOptions } from './index.js'\nimport type { DNSResolver } from './resolvers/index.js'\nimport type { AnswerCache } from './utils/cache.js'\n\nconst DEFAULT_ANSWER_CACHE_SIZE = 1000\n\nexport class DNS implements DNSInterface {\n  private readonly resolvers: Record<string, DNSResolver[]>\n  private readonly cache: AnswerCache\n\n  constructor (init: DNSInit) {\n    this.resolvers = {}\n    this.cache = cache(init.cacheSize ?? DEFAULT_ANSWER_CACHE_SIZE)\n\n    Object.entries(init.resolvers ?? {}).forEach(([tld, resolver]) => {\n      if (!Array.isArray(resolver)) {\n        resolver = [resolver]\n      }\n\n      // convert `com` -> `com.`\n      if (!tld.endsWith('.')) {\n        tld = `${tld}.`\n      }\n\n      this.resolvers[tld] = resolver\n    })\n\n    // configure default resolver if none specified\n    if (this.resolvers['.'] == null) {\n      this.resolvers['.'] = defaultResolver()\n    }\n  }\n\n  /**\n   * Queries DNS resolvers for the passed record types for the passed domain.\n   *\n   * If cached records exist for all desired types they will be returned\n   * instead.\n   *\n   * Any new responses will be added to the cache for subsequent requests.\n   */\n  async query (domain: string, options: QueryOptions = {}): Promise<DNSResponse> {\n    const types = getTypes(options.types)\n    const cached = options.cached !== false ? this.cache.get(domain, types) : undefined\n\n    if (cached != null) {\n      options.onProgress?.(new CustomProgressEvent<string>('dns:cache', { detail: cached }))\n\n      return cached\n    }\n\n    const tld = `${domain.split('.').pop()}.`\n    const resolvers = (this.resolvers[tld] ?? this.resolvers['.']).sort(() => {\n      return (Math.random() > 0.5) ? -1 : 1\n    })\n\n    const errors: Error[] = []\n\n    for (const resolver of resolvers) {\n      // skip further resolutions if the user aborted the signal\n      if (options.signal?.aborted === true) {\n        break\n      }\n\n      try {\n        const result = await resolver(domain, {\n          ...options,\n          types\n        })\n\n        for (const answer of result.Answer) {\n          this.cache.add(domain, answer)\n        }\n\n        return result\n      } catch (err: any) {\n        errors.push(err)\n        options.onProgress?.(new CustomProgressEvent<Error>('dns:error', { detail: err }))\n      }\n    }\n\n    if (errors.length === 1) {\n      throw errors[0]\n    }\n\n    throw new AggregateError(errors, `DNS lookup of ${domain} ${types} failed`)\n  }\n}\n", "/**\n * @packageDocumentation\n *\n * Query DNS records using `node:dns`, DNS over HTTP and/or DNSJSON over HTTP.\n *\n * A list of publicly accessible servers can be found [here](https://github.com/curl/curl/wiki/DNS-over-HTTPS#publicly-available-servers).\n *\n * @example Using the default resolver\n *\n * ```TypeScript\n * import { dns } from '@multiformats/dns'\n *\n * const resolver = dns()\n *\n * // resolve A records with a 5s timeout\n * const result = await dns.query('google.com', {\n *   signal: AbortSignal.timeout(5000)\n * })\n * ```\n *\n * @example Using per-TLD resolvers\n *\n * ```TypeScript\n * import { dns } from '@multiformats/dns'\n * import { dnsJsonOverHttps } from '@multiformats/dns/resolvers'\n *\n * const resolver = dns({\n *   resolvers: {\n *     // will only be used to resolve `.com` addresses\n *     'com.': dnsJsonOverHttps('https://cloudflare-dns.com/dns-query'),\n *\n *     // this can also be an array, resolvers will be shuffled and tried in\n *     // series\n *     'net.': [\n *       dnsJsonOverHttps('https://dns.google/resolve'),\n *       dnsJsonOverHttps('https://dns.pub/dns-query')\n *     ],\n *\n *     // will only be used to resolve all other addresses\n *     '.': dnsJsonOverHttps('https://dnsforge.de/dns-query'),\n *   }\n * })\n * ```\n *\n * @example Query for specific record types\n *\n * ```TypeScript\n * import { dns, RecordType } from '@multiformats/dns'\n *\n * const resolver = dns()\n *\n * // resolve only TXT records\n * const result = await dns.query('google.com', {\n *   types: [\n *     RecordType.TXT\n *   ]\n * })\n * ```\n *\n * ## Caching\n *\n * Individual Aanswers are cached so. If you make a request, for which all\n * record types are cached, all values will be pulled from the cache.\n *\n * If any of the record types are not cached, a new request will be resolved as\n * if none of the records were cached, and the cache will be updated to include\n * the new results.\n *\n * @example Ignoring the cache\n *\n * ```TypeScript\n * import { dns, RecordType } from '@multiformats/dns'\n *\n * const resolver = dns()\n *\n * // do not used cached results, always resolve a new query\n * const result = await dns.query('google.com', {\n *   cached: false\n * })\n * ```\n */\n\nimport { DNS as DNSClass } from './dns.js'\nimport type { DNSResolver } from './resolvers/index.js'\nimport type { ProgressEvent, ProgressOptions } from 'progress-events'\n\n/**\n * A subset of DNS Record Types\n *\n * @see https://www.iana.org/assignments/dns-parameters/dns-parameters.xhtml#dns-parameters-4.\n */\nexport enum RecordType {\n  A = 1,\n  CNAME = 5,\n  TXT = 16,\n  AAAA = 28\n}\n\nexport interface Question {\n  /**\n   * The record name requested.\n   */\n  name: string\n\n  /**\n   * The type of DNS record requested.\n   *\n   * @see https://www.iana.org/assignments/dns-parameters/dns-parameters.xhtml#dns-parameters-4.\n   */\n  type: RecordType\n}\n\nexport interface Answer {\n  /**\n   * The record owner.\n   */\n  name: string\n\n  /**\n   * The type of DNS record.\n   *\n   * @see https://www.iana.org/assignments/dns-parameters/dns-parameters.xhtml#dns-parameters-4\n   */\n  type: RecordType\n\n  /**\n   * The number of seconds the answer can be stored in cache before it is\n   * considered stale.\n   */\n  TTL: number\n\n  /**\n   * The value of the DNS record for the given name and type. The data will be\n   * in text for standardized record types and in hex for unknown types.\n   */\n  data: string\n}\n\nexport interface DNSResponse {\n  /**\n   * The Response Code of the DNS Query.\n   *\n   * @see https://www.iana.org/assignments/dns-parameters/dns-parameters.xhtml#dns-parameters-6\n   */\n  Status: number\n\n  /**\n   * If true, it means the truncated bit was set. This happens when the DNS\n   * answer is larger than a single UDP or TCP packet.\n   */\n  TC: boolean\n\n  /**\n   * If true, it means the Recursive Desired bit was set.\n   */\n  RD: boolean\n\n  /**\n   * If true, it means the Recursion Available bit was set.\n   */\n  RA: boolean\n\n  /**\n   * If true, it means that every record in the answer was verified with DNSSEC.\n   */\n  AD: boolean\n\n  /**\n   * If true, the client asked to disable DNSSEC validation.\n   */\n  CD: boolean\n\n  /**\n   * The records that were requested.\n   */\n  Question: Question[]\n\n  /**\n   * Values for the records that were requested.\n   */\n  Answer: Answer[]\n}\n\n/**\n * The default maximum amount of recursion allowed during a query\n */\nexport const MAX_RECURSIVE_DEPTH = 32\n\nexport interface QueryOptions extends ProgressOptions<ResolveDnsProgressEvents> {\n  signal?: AbortSignal\n\n  /**\n   * Do not use cached DNS entries\n   *\n   * @default false\n   */\n  cached?: boolean\n\n  /**\n   * The type or types of DNS records to resolve\n   *\n   * @default [RecordType.A, RecordType.AAAA]\n   */\n  types?: RecordType | RecordType[]\n}\n\nexport interface DNS {\n  query(fqdn: string, options?: QueryOptions): Promise<DNSResponse>\n}\n\nexport type ResolveDnsProgressEvents =\n  ProgressEvent<'dns:cache', string> |\n  ProgressEvent<'dns:query', string> |\n  ProgressEvent<'dns:response', DNSResponse> |\n  ProgressEvent<'dns:error', Error>\n\nexport type DNSResolvers = Record<string, DNSResolver | DNSResolver[]>\n\nexport interface DNSInit {\n  /**\n   * A set of resolvers used to answer DNS queries\n   *\n   * String keys control which resolvers are used for which TLDs.\n   *\n   * @example\n   *\n   * ```TypeScript\n   * import { dns } from '@multiformats/dns'\n   * import { dnsOverHttps } from '@multiformats/dns'\n   *\n   * const resolver = dns({\n   *   resolvers: {\n   *     // only used for .com domains\n   *     'com.': dnsOverHttps('https://example-1.com'),\n   *\n   *     // only used for .net domains, can be an array\n   *     'net.': [\n   *       dnsOverHttps('https://example-2.com'),\n   *       dnsOverHttps('https://example-3.com'),\n   *     ],\n   *\n   *     // used for everything else (can be an array)\n   *     '.': dnsOverHttps('https://example-4.com')\n   *   }\n   * })\n   * ```\n   */\n  resolvers?: DNSResolvers\n\n  /**\n   * To avoid repeating DNS lookups, successful answers are cached according to\n   * their TTL. To avoid exhausting memory, this option controls how many\n   * answers to cache.\n   *\n   * @default 1000\n   */\n  cacheSize?: number\n}\n\nexport function dns (init: DNSInit = {}): DNS {\n  return new DNSClass(init)\n}\n", "import { CodeError } from '@libp2p/interface'\nimport { dns, RecordType } from '@multiformats/dns'\nimport { multiaddr } from '../index.js'\nimport { getProtocol } from '../protocols-table.js'\nimport type { Resolver } from './index.js'\nimport type { AbortOptions, Multiaddr } from '../index.js'\nimport type { DNS } from '@multiformats/dns'\n\nconst MAX_RECURSIVE_DEPTH = 32\nconst { code: dnsaddrCode } = getProtocol('dnsaddr')\n\nexport interface DNSADDROptions extends AbortOptions {\n  /**\n   * An optional DNS resolver\n   */\n  dns?: DNS\n\n  /**\n   * When resolving DNSADDR Multiaddrs that resolve to other DNSADDR Multiaddrs,\n   * limit how many times we will recursively resolve them.\n   *\n   * @default 32\n   */\n  maxRecursiveDepth?: number\n}\n\nexport const dnsaddrResolver: Resolver<DNSADDROptions> = async function dnsaddrResolver (ma: Multiaddr, options: DNSADDROptions = {}): Promise<string[]> {\n  const recursionLimit = options.maxRecursiveDepth ?? MAX_RECURSIVE_DEPTH\n\n  if (recursionLimit === 0) {\n    throw new CodeError('Max recursive depth reached', 'ERR_MAX_RECURSIVE_DEPTH_REACHED')\n  }\n\n  const [, hostname] = ma.stringTuples().find(([proto]) => proto === dnsaddrCode) ?? []\n\n  const resolver = options?.dns ?? dns()\n  const result = await resolver.query(`_dnsaddr.${hostname}`, {\n    signal: options?.signal,\n    types: [\n      RecordType.TXT\n    ]\n  })\n\n  const peerId = ma.getPeerId()\n  const output: string[] = []\n\n  for (const answer of result.Answer) {\n    const addr = answer.data.split('=')[1]\n\n    if (addr == null) {\n      continue\n    }\n\n    if (peerId != null && !addr.includes(peerId)) {\n      continue\n    }\n\n    const ma = multiaddr(addr)\n\n    if (addr.startsWith('/dnsaddr')) {\n      const resolved = await ma.resolve({\n        ...options,\n        maxRecursiveDepth: recursionLimit - 1\n      })\n\n      output.push(...resolved.map(ma => ma.toString()))\n    } else {\n      output.push(ma.toString())\n    }\n  }\n\n  return output\n}\n", "/**\n * Thin ESM wrapper for CJS named exports.\n *\n * Ref: https://redfin.engineering/node-modules-at-war-why-commonjs-and-es-modules-cant-get-along-9617135eeca1\n */\n\nimport mergeOptions from './index.js';\nexport default mergeOptions;\n", "export enum messages {\n  NOT_STARTED_YET = 'The libp2p node is not started yet',\n  ERR_PROTECTOR_REQUIRED = 'Private network is enforced, but no protector was provided',\n  NOT_FOUND = 'Not found'\n}\n\nexport enum codes {\n  ERR_PROTECTOR_REQUIRED = 'ERR_PROTECTOR_REQUIRED',\n  ERR_PEER_DIAL_INTERCEPTED = 'ERR_PEER_DIAL_INTERCEPTED',\n  ERR_CONNECTION_INTERCEPTED = 'ERR_CONNECTION_INTERCEPTED',\n  ERR_INVALID_PROTOCOLS_FOR_STREAM = 'ERR_INVALID_PROTOCOLS_FOR_STREAM',\n  ERR_CONNECTION_ENDED = 'ERR_CONNECTION_ENDED',\n  ERR_CONNECTION_FAILED = 'ERR_CONNECTION_FAILED',\n  ERR_NODE_NOT_STARTED = 'ERR_NODE_NOT_STARTED',\n  ERR_ALREADY_ABORTED = 'ERR_ALREADY_ABORTED',\n  ERR_TOO_MANY_ADDRESSES = 'ERR_TOO_MANY_ADDRESSES',\n  ERR_NO_VALID_ADDRESSES = 'ERR_NO_VALID_ADDRESSES',\n  ERR_RELAYED_DIAL = 'ERR_RELAYED_DIAL',\n  ERR_DIALED_SELF = 'ERR_DIALED_SELF',\n  ERR_DISCOVERED_SELF = 'ERR_DISCOVERED_SELF',\n  ERR_DUPLICATE_TRANSPORT = 'ERR_DUPLICATE_TRANSPORT',\n  ERR_ENCRYPTION_FAILED = 'ERR_ENCRYPTION_FAILED',\n  ERR_HOP_REQUEST_FAILED = 'ERR_HOP_REQUEST_FAILED',\n  ERR_INVALID_KEY = 'ERR_INVALID_KEY',\n  ERR_INVALID_MESSAGE = 'ERR_INVALID_MESSAGE',\n  ERR_INVALID_PARAMETERS = 'ERR_INVALID_PARAMETERS',\n  ERR_INVALID_PEER = 'ERR_INVALID_PEER',\n  ERR_MUXER_UNAVAILABLE = 'ERR_MUXER_UNAVAILABLE',\n  ERR_NOT_FOUND = 'ERR_NOT_FOUND',\n  ERR_TRANSPORT_UNAVAILABLE = 'ERR_TRANSPORT_UNAVAILABLE',\n  ERR_TRANSPORT_DIAL_FAILED = 'ERR_TRANSPORT_DIAL_FAILED',\n  ERR_UNSUPPORTED_PROTOCOL = 'ERR_UNSUPPORTED_PROTOCOL',\n  ERR_PROTOCOL_HANDLER_ALREADY_REGISTERED = 'ERR_PROTOCOL_HANDLER_ALREADY_REGISTERED',\n  ERR_INVALID_MULTIADDR = 'ERR_INVALID_MULTIADDR',\n  ERR_SIGNATURE_NOT_VALID = 'ERR_SIGNATURE_NOT_VALID',\n  ERR_FIND_SELF = 'ERR_FIND_SELF',\n  ERR_NO_ROUTERS_AVAILABLE = 'ERR_NO_ROUTERS_AVAILABLE',\n  ERR_CONNECTION_NOT_MULTIPLEXED = 'ERR_CONNECTION_NOT_MULTIPLEXED',\n  ERR_NO_DIAL_TOKENS = 'ERR_NO_DIAL_TOKENS',\n  ERR_INVALID_CMS = 'ERR_INVALID_CMS',\n  ERR_MISSING_KEYS = 'ERR_MISSING_KEYS',\n  ERR_NO_KEY = 'ERR_NO_KEY',\n  ERR_INVALID_KEY_NAME = 'ERR_INVALID_KEY_NAME',\n  ERR_INVALID_KEY_TYPE = 'ERR_INVALID_KEY_TYPE',\n  ERR_KEY_ALREADY_EXISTS = 'ERR_KEY_ALREADY_EXISTS',\n  ERR_INVALID_KEY_SIZE = 'ERR_INVALID_KEY_SIZE',\n  ERR_KEY_NOT_FOUND = 'ERR_KEY_NOT_FOUND',\n  ERR_OLD_KEY_NAME_INVALID = 'ERR_OLD_KEY_NAME_INVALID',\n  ERR_NEW_KEY_NAME_INVALID = 'ERR_NEW_KEY_NAME_INVALID',\n  ERR_PASSWORD_REQUIRED = 'ERR_PASSWORD_REQUIRED',\n  ERR_PEM_REQUIRED = 'ERR_PEM_REQUIRED',\n  ERR_CANNOT_READ_KEY = 'ERR_CANNOT_READ_KEY',\n  ERR_MISSING_PRIVATE_KEY = 'ERR_MISSING_PRIVATE_KEY',\n  ERR_MISSING_PUBLIC_KEY = 'ERR_MISSING_PUBLIC_KEY',\n  ERR_INVALID_OLD_PASS_TYPE = 'ERR_INVALID_OLD_PASS_TYPE',\n  ERR_INVALID_NEW_PASS_TYPE = 'ERR_INVALID_NEW_PASS_TYPE',\n  ERR_INVALID_PASS_LENGTH = 'ERR_INVALID_PASS_LENGTH',\n  ERR_NOT_IMPLEMENTED = 'ERR_NOT_IMPLEMENTED',\n  ERR_WRONG_PING_ACK = 'ERR_WRONG_PING_ACK',\n  ERR_INVALID_RECORD = 'ERR_INVALID_RECORD',\n  ERR_ALREADY_SUCCEEDED = 'ERR_ALREADY_SUCCEEDED',\n  ERR_NO_HANDLER_FOR_PROTOCOL = 'ERR_NO_HANDLER_FOR_PROTOCOL',\n  ERR_TOO_MANY_OUTBOUND_PROTOCOL_STREAMS = 'ERR_TOO_MANY_OUTBOUND_PROTOCOL_STREAMS',\n  ERR_TOO_MANY_INBOUND_PROTOCOL_STREAMS = 'ERR_TOO_MANY_INBOUND_PROTOCOL_STREAMS',\n  ERR_CONNECTION_DENIED = 'ERR_CONNECTION_DENIED',\n  ERR_TRANSFER_LIMIT_EXCEEDED = 'ERR_TRANSFER_LIMIT_EXCEEDED'\n}\n", "import { CodeError, FaultTolerance } from '@libp2p/interface'\nimport { peerIdFromKeys } from '@libp2p/peer-id'\nimport { defaultAddressSort } from '@libp2p/utils/address-sort'\nimport { dnsaddrResolver } from '@multiformats/multiaddr/resolvers'\nimport mergeOptions from 'merge-options'\nimport { codes, messages } from './errors.js'\nimport type { Libp2pInit } from './index.js'\nimport type { ServiceMap, RecursivePartial } from '@libp2p/interface'\nimport type { Multiaddr } from '@multiformats/multiaddr'\n\nconst DefaultConfig: Partial<Libp2pInit> = {\n  addresses: {\n    listen: [],\n    announce: [],\n    noAnnounce: [],\n    announceFilter: (multiaddrs: Multiaddr[]) => multiaddrs\n  },\n  connectionManager: {\n    resolvers: {\n      dnsaddr: dnsaddrResolver\n    },\n    addressSorter: defaultAddressSort\n  },\n  transportManager: {\n    faultTolerance: FaultTolerance.FATAL_ALL\n  }\n}\n\nexport async function validateConfig <T extends ServiceMap = Record<string, unknown>> (opts: RecursivePartial<Libp2pInit<T>>): Promise<Libp2pInit<T>> {\n  const resultingOptions: Libp2pInit<T> = mergeOptions(DefaultConfig, opts)\n\n  if (resultingOptions.connectionProtector === null && globalThis.process?.env?.LIBP2P_FORCE_PNET != null) { // eslint-disable-line no-undef\n    throw new CodeError(messages.ERR_PROTECTOR_REQUIRED, codes.ERR_PROTECTOR_REQUIRED)\n  }\n\n  if (!(await peerIdFromKeys(resultingOptions.privateKey.public.bytes, resultingOptions.privateKey.bytes)).equals(resultingOptions.peerId)) {\n    throw new CodeError('Private key doesn\\'t match peer id', codes.ERR_INVALID_KEY)\n  }\n\n  return resultingOptions\n}\n", "import { CodeError } from '@libp2p/interface'\nimport delay from 'delay'\n\nexport interface RateLimiterInit {\n  /**\n   * Number of points\n   *\n   * @default 4\n   */\n  points?: number\n\n  /**\n   * Per seconds\n   *\n   * @default 1\n   */\n  duration?: number\n\n  /**\n   * Block if consumed more than points in current duration for blockDuration seconds\n   *\n   * @default 0\n   */\n  blockDuration?: number\n\n  /**\n   * Execute allowed actions evenly over duration\n   *\n   * @default false\n   */\n  execEvenly?: boolean\n\n  /**\n   * ms, works with execEvenly=true option\n   *\n   * @default duration * 1000 / points\n   */\n  execEvenlyMinDelayMs?: number\n\n  /**\n   * @default rlflx\n   */\n  keyPrefix?: string\n}\n\nexport interface GetKeySecDurationOptions {\n  customDuration?: number\n}\n\nexport interface RateLimiterResult {\n  remainingPoints: number\n  msBeforeNext: number\n  consumedPoints: number\n  isFirstInDuration: boolean\n}\n\nexport interface RateRecord {\n  value: number\n  expiresAt?: Date\n  timeoutId?: ReturnType<typeof setTimeout>\n}\n\nexport class RateLimiter {\n  public readonly memoryStorage: MemoryStorage\n  protected points: number\n  protected duration: number\n  protected blockDuration: number\n  protected execEvenly: boolean\n  protected execEvenlyMinDelayMs: number\n  protected keyPrefix: string\n\n  constructor (opts: RateLimiterInit = {}) {\n    this.points = opts.points ?? 4\n    this.duration = opts.duration ?? 1\n    this.blockDuration = opts.blockDuration ?? 0\n    this.execEvenly = opts.execEvenly ?? false\n    this.execEvenlyMinDelayMs = opts.execEvenlyMinDelayMs ?? (this.duration * 1000 / this.points)\n    this.keyPrefix = opts.keyPrefix ?? 'rlflx'\n    this.memoryStorage = new MemoryStorage()\n  }\n\n  async consume (key: string, pointsToConsume: number = 1, options: GetKeySecDurationOptions = {}): Promise<RateLimiterResult> {\n    const rlKey = this.getKey(key)\n    const secDuration = this._getKeySecDuration(options)\n    let res = this.memoryStorage.incrby(rlKey, pointsToConsume, secDuration)\n    res.remainingPoints = Math.max(this.points - res.consumedPoints, 0)\n\n    if (res.consumedPoints > this.points) {\n      // Block only first time when consumed more than points\n      if (this.blockDuration > 0 && res.consumedPoints <= (this.points + pointsToConsume)) {\n        // Block key\n        res = this.memoryStorage.set(rlKey, res.consumedPoints, this.blockDuration)\n      }\n\n      throw new CodeError('Rate limit exceeded', 'ERR_RATE_LIMIT_EXCEEDED', res)\n    } else if (this.execEvenly && res.msBeforeNext > 0 && !res.isFirstInDuration) {\n      // Execute evenly\n      let delayMs = Math.ceil(res.msBeforeNext / (res.remainingPoints + 2))\n      if (delayMs < this.execEvenlyMinDelayMs) {\n        delayMs = res.consumedPoints * this.execEvenlyMinDelayMs\n      }\n\n      await delay(delayMs)\n    }\n\n    return res\n  }\n\n  penalty (key: string, points: number = 1, options: GetKeySecDurationOptions = {}): RateLimiterResult {\n    const rlKey = this.getKey(key)\n    const secDuration = this._getKeySecDuration(options)\n    const res = this.memoryStorage.incrby(rlKey, points, secDuration)\n    res.remainingPoints = Math.max(this.points - res.consumedPoints, 0)\n\n    return res\n  }\n\n  reward (key: string, points: number = 1, options: GetKeySecDurationOptions = {}): RateLimiterResult {\n    const rlKey = this.getKey(key)\n    const secDuration = this._getKeySecDuration(options)\n    const res = this.memoryStorage.incrby(rlKey, -points, secDuration)\n    res.remainingPoints = Math.max(this.points - res.consumedPoints, 0)\n\n    return res\n  }\n\n  /**\n   * Block any key for secDuration seconds\n   *\n   * @param key\n   * @param secDuration\n   */\n  block (key: string, secDuration: number): RateLimiterResult {\n    const msDuration = secDuration * 1000\n    const initPoints = this.points + 1\n\n    this.memoryStorage.set(this.getKey(key), initPoints, secDuration)\n\n    return {\n      remainingPoints: 0,\n      msBeforeNext: msDuration === 0 ? -1 : msDuration,\n      consumedPoints: initPoints,\n      isFirstInDuration: false\n    }\n  }\n\n  set (key: string, points: number, secDuration: number = 0): RateLimiterResult {\n    const msDuration = (secDuration >= 0 ? secDuration : this.duration) * 1000\n\n    this.memoryStorage.set(this.getKey(key), points, secDuration)\n\n    return {\n      remainingPoints: 0,\n      msBeforeNext: msDuration === 0 ? -1 : msDuration,\n      consumedPoints: points,\n      isFirstInDuration: false\n    }\n  }\n\n  get (key: string): RateLimiterResult | undefined {\n    const res = this.memoryStorage.get(this.getKey(key))\n\n    if (res != null) {\n      res.remainingPoints = Math.max(this.points - res.consumedPoints, 0)\n    }\n\n    return res\n  }\n\n  delete (key: string): void {\n    this.memoryStorage.delete(this.getKey(key))\n  }\n\n  private _getKeySecDuration (options?: GetKeySecDurationOptions): number {\n    if (options?.customDuration != null && options.customDuration >= 0) {\n      return options.customDuration\n    }\n\n    return this.duration\n  }\n\n  getKey (key: string): string {\n    return this.keyPrefix.length > 0 ? `${this.keyPrefix}:${key}` : key\n  }\n\n  parseKey (rlKey: string): string {\n    return rlKey.substring(this.keyPrefix.length)\n  }\n}\n\nclass MemoryStorage {\n  public readonly storage: Map<string, RateRecord>\n\n  constructor () {\n    this.storage = new Map()\n  }\n\n  incrby (key: string, value: number, durationSec: number): RateLimiterResult {\n    const existing = this.storage.get(key)\n\n    if (existing != null) {\n      const msBeforeExpires = existing.expiresAt != null\n        ? existing.expiresAt.getTime() - new Date().getTime()\n        : -1\n\n      if (existing.expiresAt == null || msBeforeExpires > 0) {\n        // Change value\n        existing.value += value\n\n        return {\n          remainingPoints: 0,\n          msBeforeNext: msBeforeExpires,\n          consumedPoints: existing.value,\n          isFirstInDuration: false\n        }\n      }\n\n      return this.set(key, value, durationSec)\n    }\n\n    return this.set(key, value, durationSec)\n  }\n\n  set (key: string, value: number, durationSec: number): RateLimiterResult {\n    const durationMs = durationSec * 1000\n    const existing = this.storage.get(key)\n\n    if (existing != null) {\n      clearTimeout(existing.timeoutId)\n    }\n\n    const record: RateRecord = {\n      value,\n      expiresAt: durationMs > 0 ? new Date(Date.now() + durationMs) : undefined\n    }\n\n    this.storage.set(key, record)\n\n    if (durationMs > 0) {\n      record.timeoutId = setTimeout(() => {\n        this.storage.delete(key)\n      }, durationMs)\n\n      if (record.timeoutId.unref != null) {\n        record.timeoutId.unref()\n      }\n    }\n\n    return {\n      remainingPoints: 0,\n      msBeforeNext: durationMs === 0 ? -1 : durationMs,\n      consumedPoints: record.value,\n      isFirstInDuration: true\n    }\n  }\n\n  get (key: string): RateLimiterResult | undefined {\n    const existing = this.storage.get(key)\n\n    if (existing != null) {\n      const msBeforeExpires = existing.expiresAt != null\n        ? existing.expiresAt.getTime() - new Date().getTime()\n        : -1\n      return {\n        remainingPoints: 0,\n        msBeforeNext: msBeforeExpires,\n        consumedPoints: existing.value,\n        isFirstInDuration: false\n      }\n    }\n  }\n\n  delete (key: string): boolean {\n    const record = this.storage.get(key)\n\n    if (record != null) {\n      if (record.timeoutId != null) {\n        clearTimeout(record.timeoutId)\n      }\n\n      this.storage.delete(key)\n\n      return true\n    }\n    return false\n  }\n}\n", "import { CodeError, isPeerId } from '@libp2p/interface'\nimport { peerIdFromString } from '@libp2p/peer-id'\nimport { isMultiaddr } from '@multiformats/multiaddr'\nimport { codes } from './errors.js'\nimport type { PeerId } from '@libp2p/interface'\nimport type { Multiaddr } from '@multiformats/multiaddr'\n\nexport interface PeerAddress {\n  peerId?: PeerId\n  multiaddrs: Multiaddr[]\n}\n\n/**\n * Extracts a PeerId and/or multiaddr from the passed PeerId or Multiaddr or an array of Multiaddrs\n */\nexport function getPeerAddress (peer: PeerId | Multiaddr | Multiaddr[]): PeerAddress {\n  if (isPeerId(peer)) {\n    return { peerId: peer, multiaddrs: [] }\n  }\n\n  if (!Array.isArray(peer)) {\n    peer = [peer]\n  }\n\n  let peerId: PeerId | undefined\n\n  if (peer.length > 0) {\n    const peerIdStr = peer[0].getPeerId()\n    peerId = peerIdStr == null ? undefined : peerIdFromString(peerIdStr)\n\n    // ensure PeerId is either not set or is consistent\n    peer.forEach(ma => {\n      if (!isMultiaddr(ma)) {\n        throw new CodeError('Invalid Multiaddr', codes.ERR_INVALID_MULTIADDR)\n      }\n\n      const maPeerIdStr = ma.getPeerId()\n\n      if (maPeerIdStr == null) {\n        if (peerId != null) {\n          throw new CodeError('Multiaddrs must all have the same peer id or have no peer id', codes.ERR_INVALID_PARAMETERS)\n        }\n      } else {\n        const maPeerId = peerIdFromString(maPeerIdStr)\n\n        if (peerId == null || !peerId.equals(maPeerId)) {\n          throw new CodeError('Multiaddrs must all have the same peer id or have no peer id', codes.ERR_INVALID_PARAMETERS)\n        }\n      }\n    })\n  }\n\n  return {\n    peerId,\n    multiaddrs: peer\n  }\n}\n", "/**\n * @see https://libp2p.github.io/js-libp2p/interfaces/index._internal_.ConnectionManagerConfig.html#dialTimeout\n */\nexport const DIAL_TIMEOUT = 5e3\n\n/**\n * @see https://libp2p.github.io/js-libp2p/interfaces/index._internal_.ConnectionManagerConfig.html#inboundUpgradeTimeout\n */\nexport const INBOUND_UPGRADE_TIMEOUT = 2e3\n\n/**\n * @see https://libp2p.github.io/js-libp2p/interfaces/index._internal_.ConnectionManagerConfig.html#maxPeerAddrsToDial\n */\nexport const MAX_PEER_ADDRS_TO_DIAL = 25\n\n/**\n * @see https://libp2p.github.io/js-libp2p/interfaces/index._internal_.ConnectionManagerConfig.html#autoDialInterval\n */\nexport const AUTO_DIAL_INTERVAL = 5000\n\n/**\n * @see https://libp2p.github.io/js-libp2p/interfaces/index._internal_.ConnectionManagerConfig.html#autoDialConcurrency\n */\nexport const AUTO_DIAL_CONCURRENCY = 25\n\n/**\n * @see https://libp2p.github.io/js-libp2p/interfaces/index._internal_.ConnectionManagerConfig.html#autoDialPriority\n */\nexport const AUTO_DIAL_PRIORITY = 0\n\n/**\n * @see https://libp2p.github.io/js-libp2p/interfaces/index._internal_.ConnectionManagerConfig.html#autoDialMaxQueueLength\n */\nexport const AUTO_DIAL_MAX_QUEUE_LENGTH = 100\n\n/**\n * @see https://libp2p.github.io/js-libp2p/interfaces/libp2p.index.unknown.ConnectionManagerInit.html#autoDialDiscoveredPeersDebounce\n */\nexport const AUTO_DIAL_DISCOVERED_PEERS_DEBOUNCE = 10\n\n/**\n * @see https://libp2p.github.io/js-libp2p/interfaces/index._internal_.ConnectionManagerConfig.html#inboundConnectionThreshold\n */\nexport const INBOUND_CONNECTION_THRESHOLD = 5\n\n/**\n * @see https://libp2p.github.io/js-libp2p/interfaces/index._internal_.ConnectionManagerConfig.html#maxIncomingPendingConnections\n */\nexport const MAX_INCOMING_PENDING_CONNECTIONS = 10\n\n/**\n * Store as part of the peer store metadata for a given peer, the value for this\n * key is a timestamp of the last time a dial attempted failed with the relevant\n * peer stored as a string.\n *\n * Used to insure we do not endlessly try to auto dial peers we have recently\n * failed to dial.\n */\nexport const LAST_DIAL_FAILURE_KEY = 'last-dial-failure'\n\n/**\n * @see https://libp2p.github.io/js-libp2p/interfaces/index._internal_.ConnectionManagerConfig.html#maxDialQueueLength\n */\nexport const MAX_DIAL_QUEUE_LENGTH = 500\n", "export * from './constants.defaults.js'\n\n/**\n * @see https://libp2p.github.io/js-libp2p/interfaces/index._internal_.ConnectionManagerConfig.html#minConnections\n */\nexport const MIN_CONNECTIONS = 5\n\n/**\n * @see https://libp2p.github.io/js-libp2p/interfaces/index._internal_.ConnectionManagerConfig.html#maxConnections\n */\nexport const MAX_CONNECTIONS = 100\n\n/**\n * @see https://libp2p.github.io/js-libp2p/interfaces/index._internal_.ConnectionManagerConfig.html#maxParallelDials\n */\nexport const MAX_PARALLEL_DIALS = 50\n\n/**\n * @see https://libp2p.github.io/js-libp2p/interfaces/libp2p.index.unknown.ConnectionManagerInit.html#autoDialPeerRetryThreshold\n */\nexport const AUTO_DIAL_PEER_RETRY_THRESHOLD = 1000 * 60 * 7\n", "import { PeerMap, PeerSet } from '@libp2p/peer-collections'\nimport { PeerQueue } from '@libp2p/utils/peer-queue'\nimport { toString as uint8ArrayToString } from 'uint8arrays/to-string'\nimport { AUTO_DIAL_CONCURRENCY, AUTO_DIAL_DISCOVERED_PEERS_DEBOUNCE, AUTO_DIAL_INTERVAL, AUTO_DIAL_MAX_QUEUE_LENGTH, AUTO_DIAL_PEER_RETRY_THRESHOLD, AUTO_DIAL_PRIORITY, LAST_DIAL_FAILURE_KEY, MIN_CONNECTIONS } from './constants.js'\nimport type { Libp2pEvents, Logger, ComponentLogger, TypedEventTarget, PeerStore, Startable, Metrics } from '@libp2p/interface'\nimport type { ConnectionManager } from '@libp2p/interface-internal'\n\ninterface AutoDialInit {\n  minConnections?: number\n  maxQueueLength?: number\n  autoDialConcurrency?: number\n  autoDialPriority?: number\n  autoDialInterval?: number\n  autoDialPeerRetryThreshold?: number\n  autoDialDiscoveredPeersDebounce?: number\n}\n\ninterface AutoDialComponents {\n  connectionManager: ConnectionManager\n  peerStore: PeerStore\n  events: TypedEventTarget<Libp2pEvents>\n  logger: ComponentLogger\n  metrics?: Metrics\n}\n\nconst defaultOptions = {\n  minConnections: MIN_CONNECTIONS,\n  maxQueueLength: AUTO_DIAL_MAX_QUEUE_LENGTH,\n  autoDialConcurrency: AUTO_DIAL_CONCURRENCY,\n  autoDialPriority: AUTO_DIAL_PRIORITY,\n  autoDialInterval: AUTO_DIAL_INTERVAL,\n  autoDialPeerRetryThreshold: AUTO_DIAL_PEER_RETRY_THRESHOLD,\n  autoDialDiscoveredPeersDebounce: AUTO_DIAL_DISCOVERED_PEERS_DEBOUNCE\n}\n\nexport class AutoDial implements Startable {\n  private readonly connectionManager: ConnectionManager\n  private readonly peerStore: PeerStore\n  private readonly queue: PeerQueue<void>\n  private readonly minConnections: number\n  private readonly autoDialPriority: number\n  private readonly autoDialIntervalMs: number\n  private readonly autoDialMaxQueueLength: number\n  private readonly autoDialPeerRetryThresholdMs: number\n  private readonly autoDialDiscoveredPeersDebounce: number\n  private autoDialInterval?: ReturnType<typeof setInterval>\n  private started: boolean\n  private running: boolean\n  private readonly log: Logger\n\n  /**\n   * Proactively tries to connect to known peers stored in the PeerStore.\n   * It will keep the number of connections below the upper limit and sort\n   * the peers to connect based on whether we know their keys and protocols.\n   */\n  constructor (components: AutoDialComponents, init: AutoDialInit) {\n    this.connectionManager = components.connectionManager\n    this.peerStore = components.peerStore\n    this.minConnections = init.minConnections ?? defaultOptions.minConnections\n    this.autoDialPriority = init.autoDialPriority ?? defaultOptions.autoDialPriority\n    this.autoDialIntervalMs = init.autoDialInterval ?? defaultOptions.autoDialInterval\n    this.autoDialMaxQueueLength = init.maxQueueLength ?? defaultOptions.maxQueueLength\n    this.autoDialPeerRetryThresholdMs = init.autoDialPeerRetryThreshold ?? defaultOptions.autoDialPeerRetryThreshold\n    this.autoDialDiscoveredPeersDebounce = init.autoDialDiscoveredPeersDebounce ?? defaultOptions.autoDialDiscoveredPeersDebounce\n    this.log = components.logger.forComponent('libp2p:connection-manager:auto-dial')\n    this.started = false\n    this.running = false\n    this.queue = new PeerQueue({\n      concurrency: init.autoDialConcurrency ?? defaultOptions.autoDialConcurrency,\n      metricName: 'libp2p_autodial_queue',\n      metrics: components.metrics\n    })\n    this.queue.addEventListener('error', (evt) => {\n      this.log.error('error during auto-dial', evt.detail)\n    })\n\n    // check the min connection limit whenever a peer disconnects\n    components.events.addEventListener('connection:close', () => {\n      this.autoDial()\n        .catch(err => {\n          this.log.error(err)\n        })\n    })\n\n    // sometimes peers are discovered in quick succession so add a small\n    // debounce to ensure all eligible peers are autodialed\n    let debounce: ReturnType<typeof setTimeout>\n\n    // when new peers are discovered, dial them if we don't have\n    // enough connections\n    components.events.addEventListener('peer:discovery', () => {\n      clearTimeout(debounce)\n      debounce = setTimeout(() => {\n        this.autoDial()\n          .catch(err => {\n            this.log.error(err)\n          })\n      }, this.autoDialDiscoveredPeersDebounce)\n    })\n  }\n\n  isStarted (): boolean {\n    return this.started\n  }\n\n  start (): void {\n    this.started = true\n  }\n\n  afterStart (): void {\n    this.autoDial()\n      .catch(err => {\n        this.log.error('error while autodialing', err)\n      })\n  }\n\n  stop (): void {\n    // clear the queue\n    this.queue.clear()\n    clearTimeout(this.autoDialInterval)\n    this.started = false\n    this.running = false\n  }\n\n  async autoDial (): Promise<void> {\n    if (!this.started || this.running) {\n      return\n    }\n\n    const connections = this.connectionManager.getConnectionsMap()\n    const numConnections = connections.size\n\n    // already have enough connections\n    if (numConnections >= this.minConnections) {\n      if (this.minConnections > 0) {\n        this.log.trace('have enough connections %d/%d', numConnections, this.minConnections)\n      }\n\n      // no need to schedule next autodial as it will be run when on\n      // connection:close event\n      return\n    }\n\n    if (this.queue.size > this.autoDialMaxQueueLength) {\n      this.log('not enough connections %d/%d but auto dial queue is full', numConnections, this.minConnections)\n      this.sheduleNextAutodial()\n      return\n    }\n\n    this.running = true\n\n    this.log('not enough connections %d/%d - will dial peers to increase the number of connections', numConnections, this.minConnections)\n\n    const dialQueue = new PeerSet(\n      // @ts-expect-error boolean filter removes falsy peer IDs\n      this.connectionManager.getDialQueue()\n        .map(queue => queue.peerId)\n        .filter(Boolean)\n    )\n\n    // sort peers on whether we know protocols or public keys for them\n    const peers = await this.peerStore.all({\n      filters: [\n        // remove some peers\n        (peer) => {\n          // remove peers without addresses\n          if (peer.addresses.length === 0) {\n            this.log.trace('not autodialing %p because they have no addresses', peer.id)\n            return false\n          }\n\n          // remove peers we are already connected to\n          if (connections.has(peer.id)) {\n            this.log.trace('not autodialing %p because they are already connected', peer.id)\n            return false\n          }\n\n          // remove peers we are already dialling\n          if (dialQueue.has(peer.id)) {\n            this.log.trace('not autodialing %p because they are already being dialed', peer.id)\n            return false\n          }\n\n          // remove peers already in the autodial queue\n          if (this.queue.has(peer.id)) {\n            this.log.trace('not autodialing %p because they are already being autodialed', peer.id)\n            return false\n          }\n\n          return true\n        }\n      ]\n    })\n\n    // shuffle the peers - this is so peers with the same tag values will be\n    // dialled in a different order each time\n    const shuffledPeers = peers.sort(() => Math.random() > 0.5 ? 1 : -1)\n\n    // sort shuffled peers by tag value\n    const peerValues = new PeerMap<number>()\n    for (const peer of shuffledPeers) {\n      if (peerValues.has(peer.id)) {\n        continue\n      }\n\n      // sum all tag values\n      peerValues.set(peer.id, [...peer.tags.values()].reduce((acc, curr) => {\n        return acc + curr.value\n      }, 0))\n    }\n\n    // sort by value, highest to lowest\n    const sortedPeers = shuffledPeers.sort((a, b) => {\n      const peerAValue = peerValues.get(a.id) ?? 0\n      const peerBValue = peerValues.get(b.id) ?? 0\n\n      if (peerAValue > peerBValue) {\n        return -1\n      }\n\n      if (peerAValue < peerBValue) {\n        return 1\n      }\n\n      return 0\n    })\n\n    const peersThatHaveNotFailed = sortedPeers.filter(peer => {\n      const lastDialFailure = peer.metadata.get(LAST_DIAL_FAILURE_KEY)\n\n      if (lastDialFailure == null) {\n        return true\n      }\n\n      const lastDialFailureTimestamp = parseInt(uint8ArrayToString(lastDialFailure))\n\n      if (isNaN(lastDialFailureTimestamp)) {\n        return true\n      }\n\n      // only dial if the time since the last failure is above the retry threshold\n      return Date.now() - lastDialFailureTimestamp > this.autoDialPeerRetryThresholdMs\n    })\n\n    this.log('selected %d/%d peers to dial', peersThatHaveNotFailed.length, peers.length)\n\n    for (const peer of peersThatHaveNotFailed) {\n      this.queue.add(async () => {\n        const numConnections = this.connectionManager.getConnectionsMap().size\n\n        // Check to see if we still need to auto dial\n        if (numConnections >= this.minConnections) {\n          this.log('got enough connections now %d/%d', numConnections, this.minConnections)\n          this.queue.clear()\n          return\n        }\n\n        this.log('connecting to a peerStore stored peer %p', peer.id)\n        await this.connectionManager.openConnection(peer.id, {\n          priority: this.autoDialPriority\n        })\n      }, {\n        peerId: peer.id\n      }).catch(err => {\n        this.log.error('could not connect to peerStore stored peer', err)\n      })\n    }\n\n    this.running = false\n    this.sheduleNextAutodial()\n  }\n\n  private sheduleNextAutodial (): void {\n    if (!this.started) {\n      return\n    }\n\n    this.autoDialInterval = setTimeout(() => {\n      this.autoDial()\n        .catch(err => {\n          this.log.error('error while autodialing', err)\n        })\n    }, this.autoDialIntervalMs)\n  }\n}\n", "import { PeerMap } from '@libp2p/peer-collections'\nimport { MAX_CONNECTIONS } from './constants.js'\nimport type { Libp2pEvents, Logger, ComponentLogger, TypedEventTarget, PeerStore } from '@libp2p/interface'\nimport type { ConnectionManager } from '@libp2p/interface-internal'\nimport type { Multiaddr } from '@multiformats/multiaddr'\n\ninterface ConnectionPrunerInit {\n  maxConnections?: number\n  allow?: Multiaddr[]\n}\n\ninterface ConnectionPrunerComponents {\n  connectionManager: ConnectionManager\n  peerStore: PeerStore\n  events: TypedEventTarget<Libp2pEvents>\n  logger: ComponentLogger\n}\n\nconst defaultOptions = {\n  maxConnections: MAX_CONNECTIONS,\n  allow: []\n}\n\n/**\n * If we go over the max connections limit, choose some connections to close\n */\nexport class ConnectionPruner {\n  private readonly maxConnections: number\n  private readonly connectionManager: ConnectionManager\n  private readonly peerStore: PeerStore\n  private readonly allow: Multiaddr[]\n  private readonly events: TypedEventTarget<Libp2pEvents>\n  private readonly log: Logger\n\n  constructor (components: ConnectionPrunerComponents, init: ConnectionPrunerInit = {}) {\n    this.maxConnections = init.maxConnections ?? defaultOptions.maxConnections\n    this.allow = init.allow ?? defaultOptions.allow\n    this.connectionManager = components.connectionManager\n    this.peerStore = components.peerStore\n    this.events = components.events\n    this.log = components.logger.forComponent('libp2p:connection-manager:connection-pruner')\n\n    // check the max connection limit whenever a peer connects\n    components.events.addEventListener('connection:open', () => {\n      this.maybePruneConnections()\n        .catch(err => {\n          this.log.error(err)\n        })\n    })\n  }\n\n  /**\n   * If we have more connections than our maximum, select some excess connections\n   * to prune based on peer value\n   */\n  async maybePruneConnections (): Promise<void> {\n    const connections = this.connectionManager.getConnections()\n    const numConnections = connections.length\n    const toPrune = Math.max(numConnections - this.maxConnections, 0)\n\n    this.log('checking max connections limit %d/%d', numConnections, this.maxConnections)\n    if (numConnections <= this.maxConnections) {\n      return\n    }\n\n    this.log('max connections limit exceeded %d/%d, pruning %d connection(s)', numConnections, this.maxConnections, toPrune)\n    const peerValues = new PeerMap<number>()\n\n    // work out peer values\n    for (const connection of connections) {\n      const remotePeer = connection.remotePeer\n\n      if (peerValues.has(remotePeer)) {\n        continue\n      }\n\n      peerValues.set(remotePeer, 0)\n\n      try {\n        const peer = await this.peerStore.get(remotePeer)\n\n        // sum all tag values\n        peerValues.set(remotePeer, [...peer.tags.values()].reduce((acc, curr) => {\n          return acc + curr.value\n        }, 0))\n      } catch (err: any) {\n        if (err.code !== 'ERR_NOT_FOUND') {\n          this.log.error('error loading peer tags', err)\n        }\n      }\n    }\n\n    // sort by value, lowest to highest\n    const sortedConnections = connections.sort((a, b) => {\n      const peerAValue = peerValues.get(a.remotePeer) ?? 0\n      const peerBValue = peerValues.get(b.remotePeer) ?? 0\n\n      if (peerAValue > peerBValue) {\n        return 1\n      }\n\n      if (peerAValue < peerBValue) {\n        return -1\n      }\n\n      // if the peers have an equal tag value then we want to close short-lived connections first\n      const connectionALifespan = a.timeline.open\n      const connectionBLifespan = b.timeline.open\n\n      if (connectionALifespan < connectionBLifespan) {\n        return 1\n      }\n\n      if (connectionALifespan > connectionBLifespan) {\n        return -1\n      }\n\n      return 0\n    })\n\n    // close some connections\n    const toClose = []\n\n    for (const connection of sortedConnections) {\n      this.log('too many connections open - closing a connection to %p', connection.remotePeer)\n      // check allow list\n      const connectionInAllowList = this.allow.some((ma) => {\n        return connection.remoteAddr.toString().startsWith(ma.toString())\n      })\n\n      // Connections in the allow list should be excluded from pruning\n      if (!connectionInAllowList) {\n        toClose.push(connection)\n      }\n\n      if (toClose.length === toPrune) {\n        break\n      }\n    }\n\n    // close connections\n    await Promise.all(\n      toClose.map(async connection => {\n        try {\n          await connection.close()\n        } catch (err) {\n          this.log.error(err)\n        }\n      })\n    )\n\n    // despatch prune event\n    this.events.safeDispatchEvent('connection:prune', { detail: toClose })\n  }\n}\n", "import { resolvers } from '@multiformats/multiaddr'\nimport type { LoggerOptions } from '@libp2p/interface'\nimport type { Multiaddr, ResolveOptions } from '@multiformats/multiaddr'\n\n/**\n * Recursively resolve DNSADDR multiaddrs\n */\nexport async function resolveMultiaddrs (ma: Multiaddr, options: ResolveOptions & LoggerOptions): Promise<Multiaddr[]> {\n  // check multiaddr resolvers\n  let resolvable = false\n\n  for (const key of resolvers.keys()) {\n    resolvable = ma.protoNames().includes(key)\n\n    if (resolvable) {\n      break\n    }\n  }\n\n  // return multiaddr if it is not resolvable\n  if (!resolvable) {\n    return [ma]\n  }\n\n  const output = await ma.resolve(options)\n\n  options.log('resolved %s to', ma, output.map(ma => ma.toString()))\n\n  return output\n}\n", "/* eslint-disable max-depth */\nimport { CodeError, AggregateCodeError, ERR_TIMEOUT, setMaxListeners } from '@libp2p/interface'\nimport { PeerMap } from '@libp2p/peer-collections'\nimport { defaultAddressSort } from '@libp2p/utils/address-sort'\nimport { Queue, type QueueAddOptions } from '@libp2p/utils/queue'\nimport { type Multiaddr, type Resolver, resolvers, multiaddr } from '@multiformats/multiaddr'\nimport { dnsaddrResolver } from '@multiformats/multiaddr/resolvers'\nimport { Circuit } from '@multiformats/multiaddr-matcher'\nimport { type ClearableSignal, anySignal } from 'any-signal'\nimport { fromString as uint8ArrayFromString } from 'uint8arrays/from-string'\nimport { codes } from '../errors.js'\nimport { getPeerAddress } from '../get-peer.js'\nimport {\n  DIAL_TIMEOUT,\n  MAX_PARALLEL_DIALS,\n  MAX_PEER_ADDRS_TO_DIAL,\n  LAST_DIAL_FAILURE_KEY,\n  MAX_DIAL_QUEUE_LENGTH\n} from './constants.js'\nimport { resolveMultiaddrs } from './utils.js'\nimport type { AddressSorter, AbortOptions, ComponentLogger, Logger, Connection, ConnectionGater, Metrics, PeerId, Address, PeerStore, PeerRouting, IsDialableOptions } from '@libp2p/interface'\nimport type { TransportManager } from '@libp2p/interface-internal'\nimport type { DNS } from '@multiformats/dns'\n\nexport interface PendingDialTarget {\n  resolve(value: any): void\n  reject(err: Error): void\n}\n\nexport interface DialOptions extends AbortOptions {\n  priority?: number\n  force?: boolean\n}\n\ninterface DialQueueJobOptions extends QueueAddOptions {\n  peerId?: PeerId\n  multiaddrs: Set<string>\n}\n\ninterface DialerInit {\n  addressSorter?: AddressSorter\n  maxParallelDials?: number\n  maxDialQueueLength?: number\n  maxPeerAddrsToDial?: number\n  dialTimeout?: number\n  resolvers?: Record<string, Resolver>\n  connections?: PeerMap<Connection[]>\n}\n\nconst defaultOptions = {\n  addressSorter: defaultAddressSort,\n  maxParallelDials: MAX_PARALLEL_DIALS,\n  maxDialQueueLength: MAX_DIAL_QUEUE_LENGTH,\n  maxPeerAddrsToDial: MAX_PEER_ADDRS_TO_DIAL,\n  dialTimeout: DIAL_TIMEOUT,\n  resolvers: {\n    dnsaddr: dnsaddrResolver\n  }\n}\n\ninterface DialQueueComponents {\n  peerId: PeerId\n  metrics?: Metrics\n  peerStore: PeerStore\n  peerRouting: PeerRouting\n  transportManager: TransportManager\n  connectionGater: ConnectionGater\n  logger: ComponentLogger\n  dns?: DNS\n}\n\nexport class DialQueue {\n  public queue: Queue<Connection, DialQueueJobOptions>\n  private readonly components: DialQueueComponents\n  private readonly addressSorter: AddressSorter\n  private readonly maxPeerAddrsToDial: number\n  private readonly maxDialQueueLength: number\n  private readonly dialTimeout: number\n  private shutDownController: AbortController\n  private readonly connections: PeerMap<Connection[]>\n  private readonly log: Logger\n\n  constructor (components: DialQueueComponents, init: DialerInit = {}) {\n    this.addressSorter = init.addressSorter ?? defaultOptions.addressSorter\n    this.maxPeerAddrsToDial = init.maxPeerAddrsToDial ?? defaultOptions.maxPeerAddrsToDial\n    this.maxDialQueueLength = init.maxDialQueueLength ?? defaultOptions.maxDialQueueLength\n    this.dialTimeout = init.dialTimeout ?? defaultOptions.dialTimeout\n    this.connections = init.connections ?? new PeerMap()\n    this.log = components.logger.forComponent('libp2p:connection-manager:dial-queue')\n    this.components = components\n\n    this.shutDownController = new AbortController()\n    setMaxListeners(Infinity, this.shutDownController.signal)\n\n    for (const [key, value] of Object.entries(init.resolvers ?? {})) {\n      resolvers.set(key, value)\n    }\n\n    // controls dial concurrency\n    this.queue = new Queue({\n      concurrency: init.maxParallelDials ?? defaultOptions.maxParallelDials,\n      metricName: 'libp2p_dial_queue',\n      metrics: components.metrics\n    })\n    // a started job errored\n    this.queue.addEventListener('error', (event) => {\n      this.log.error('error in dial queue', event.detail)\n    })\n  }\n\n  start (): void {\n    this.shutDownController = new AbortController()\n    setMaxListeners(Infinity, this.shutDownController.signal)\n  }\n\n  /**\n   * Clears any pending dials\n   */\n  stop (): void {\n    this.shutDownController.abort()\n    this.queue.abort()\n  }\n\n  /**\n   * Connects to a given peer, multiaddr or list of multiaddrs.\n   *\n   * If a peer is passed, all known multiaddrs will be tried. If a multiaddr or\n   * multiaddrs are passed only those will be dialled.\n   *\n   * Where a list of multiaddrs is passed, if any contain a peer id then all\n   * multiaddrs in the list must contain the same peer id.\n   *\n   * The dial to the first address that is successfully able to upgrade a\n   * connection will be used, all other dials will be aborted when that happens.\n   */\n  async dial (peerIdOrMultiaddr: PeerId | Multiaddr | Multiaddr[], options: DialOptions = {}): Promise<Connection> {\n    const { peerId, multiaddrs } = getPeerAddress(peerIdOrMultiaddr)\n\n    // make sure we don't have an existing connection to any of the addresses we\n    // are about to dial\n    const existingConnection = Array.from(this.connections.values()).flat().find(conn => {\n      if (options.force === true) {\n        return false\n      }\n\n      if (conn.remotePeer.equals(peerId)) {\n        return true\n      }\n\n      return multiaddrs.find(addr => {\n        return addr.equals(conn.remoteAddr)\n      })\n    })\n\n    if (existingConnection != null) {\n      this.log('already connected to %a', existingConnection.remoteAddr)\n      return existingConnection\n    }\n\n    // ready to dial, all async work finished - make sure we don't have any\n    // pending dials in progress for this peer or set of multiaddrs\n    const existingDial = this.queue.queue.find(job => {\n      if (peerId?.equals(job.options.peerId) === true) {\n        return true\n      }\n\n      // does the dial contain any of the target multiaddrs?\n      const addresses = job.options.multiaddrs\n\n      if (addresses == null) {\n        return false\n      }\n\n      for (const multiaddr of multiaddrs) {\n        if (addresses.has(multiaddr.toString())) {\n          return true\n        }\n      }\n\n      return false\n    })\n\n    if (existingDial != null) {\n      this.log('joining existing dial target for %p', peerId)\n\n      // add all multiaddrs to the dial target\n      for (const multiaddr of multiaddrs) {\n        existingDial.options.multiaddrs.add(multiaddr.toString())\n      }\n\n      return existingDial.join(options)\n    }\n\n    if (this.queue.size >= this.maxDialQueueLength) {\n      throw new CodeError('Dial queue is full', 'ERR_DIAL_QUEUE_FULL')\n    }\n\n    this.log('creating dial target for %p', peerId, multiaddrs.map(ma => ma.toString()))\n\n    return this.queue.add(async (options) => {\n      // create abort conditions - need to do this before `calculateMultiaddrs` as\n      // we may be about to resolve a dns addr which can time out\n      const signal = this.createDialAbortController(options?.signal)\n      let addrsToDial: Address[]\n\n      try {\n        // load addresses from address book, resolve and dnsaddrs, filter\n        // undiallables, add peer IDs, etc\n        addrsToDial = await this.calculateMultiaddrs(peerId, options?.multiaddrs, {\n          ...options,\n          signal\n        })\n\n        addrsToDial.map(({ multiaddr }) => multiaddr.toString()).forEach(addr => {\n          options?.multiaddrs.add(addr)\n        })\n      } catch (err) {\n        signal.clear()\n        throw err\n      }\n\n      try {\n        let dialed = 0\n        const errors: Error[] = []\n\n        for (const address of addrsToDial) {\n          if (dialed === this.maxPeerAddrsToDial) {\n            this.log('dialed maxPeerAddrsToDial (%d) addresses for %p, not trying any others', dialed, peerId)\n\n            throw new CodeError('Peer had more than maxPeerAddrsToDial', codes.ERR_TOO_MANY_ADDRESSES)\n          }\n\n          dialed++\n\n          try {\n            const conn = await this.components.transportManager.dial(address.multiaddr, {\n              ...options,\n              signal\n            })\n\n            this.log('dial to %a succeeded', address.multiaddr)\n\n            return conn\n          } catch (err: any) {\n            this.log.error('dial failed to %a', address.multiaddr, err)\n\n            if (peerId != null) {\n              // record the failed dial\n              try {\n                await this.components.peerStore.patch(peerId, {\n                  metadata: {\n                    [LAST_DIAL_FAILURE_KEY]: uint8ArrayFromString(Date.now().toString())\n                  }\n                })\n              } catch (err: any) {\n                this.log.error('could not update last dial failure key for %p', peerId, err)\n              }\n            }\n\n            // the user/dial timeout/shutdown controller signal aborted\n            if (signal.aborted) {\n              throw new CodeError(err.message, ERR_TIMEOUT)\n            }\n\n            errors.push(err)\n          }\n        }\n\n        if (errors.length === 1) {\n          throw errors[0]\n        }\n\n        throw new AggregateCodeError(errors, 'All multiaddr dials failed', codes.ERR_TRANSPORT_DIAL_FAILED)\n      } finally {\n        // clean up abort signals/controllers\n        signal.clear()\n      }\n    }, {\n      peerId,\n      priority: options.priority,\n      multiaddrs: new Set(multiaddrs.map(ma => ma.toString())),\n      signal: options.signal\n    })\n  }\n\n  private createDialAbortController (userSignal?: AbortSignal): ClearableSignal {\n    // let any signal abort the dial\n    const signal = anySignal([\n      AbortSignal.timeout(this.dialTimeout),\n      this.shutDownController.signal,\n      userSignal\n    ])\n\n    // This emitter gets listened to a lot\n    setMaxListeners(Infinity, signal)\n\n    return signal\n  }\n\n  // eslint-disable-next-line complexity\n  private async calculateMultiaddrs (peerId?: PeerId, multiaddrs: Set<string> = new Set<string>(), options: DialOptions = {}): Promise<Address[]> {\n    const addrs: Address[] = [...multiaddrs].map(ma => ({\n      multiaddr: multiaddr(ma),\n      isCertified: false\n    }))\n\n    // if a peer id or multiaddr(s) with a peer id, make sure it isn't our peer id and that we are allowed to dial it\n    if (peerId != null) {\n      if (this.components.peerId.equals(peerId)) {\n        throw new CodeError('Tried to dial self', codes.ERR_DIALED_SELF)\n      }\n\n      if ((await this.components.connectionGater.denyDialPeer?.(peerId)) === true) {\n        throw new CodeError('The dial request is blocked by gater.allowDialPeer', codes.ERR_PEER_DIAL_INTERCEPTED)\n      }\n\n      // if just a peer id was passed, load available multiaddrs for this peer\n      // from the peer store\n      if (addrs.length === 0) {\n        this.log('loading multiaddrs for %p', peerId)\n        try {\n          const peer = await this.components.peerStore.get(peerId)\n          addrs.push(...peer.addresses)\n          this.log('loaded multiaddrs for %p', peerId, addrs.map(({ multiaddr }) => multiaddr.toString()))\n        } catch (err: any) {\n          if (err.code !== codes.ERR_NOT_FOUND) {\n            throw err\n          }\n        }\n      }\n\n      // if we still don't have any addresses for this peer, try a lookup\n      // using the peer routing\n      if (addrs.length === 0) {\n        this.log('looking up multiaddrs for %p in the peer routing', peerId)\n\n        try {\n          const peerInfo = await this.components.peerRouting.findPeer(peerId)\n\n          this.log('found multiaddrs for %p in the peer routing', peerId, addrs.map(({ multiaddr }) => multiaddr.toString()))\n\n          addrs.push(...peerInfo.multiaddrs.map(multiaddr => ({\n            multiaddr,\n            isCertified: false\n          })))\n        } catch (err: any) {\n          if (err.code !== codes.ERR_NO_ROUTERS_AVAILABLE) {\n            this.log.error('looking up multiaddrs for %p in the peer routing failed', peerId, err)\n          }\n        }\n      }\n    }\n\n    // resolve addresses - this can result in a one-to-many translation when\n    // dnsaddrs are resolved\n    let resolvedAddresses = (await Promise.all(\n      addrs.map(async addr => {\n        const result = await resolveMultiaddrs(addr.multiaddr, {\n          dns: this.components.dns,\n          ...options,\n          log: this.log\n        })\n\n        if (result.length === 1 && result[0].equals(addr.multiaddr)) {\n          return addr\n        }\n\n        return result.map(multiaddr => ({\n          multiaddr,\n          isCertified: false\n        }))\n      })\n    ))\n      .flat()\n\n    // ensure the peer id is appended to the multiaddr\n    if (peerId != null) {\n      const peerIdMultiaddr = `/p2p/${peerId.toString()}`\n      resolvedAddresses = resolvedAddresses.map(addr => {\n        const lastProto = addr.multiaddr.protos().pop()\n\n        // do not append peer id to path multiaddrs\n        if (lastProto?.path === true) {\n          return addr\n        }\n\n        // append peer id to multiaddr if it is not already present\n        if (addr.multiaddr.getPeerId() == null) {\n          return {\n            multiaddr: addr.multiaddr.encapsulate(peerIdMultiaddr),\n            isCertified: addr.isCertified\n          }\n        }\n\n        return addr\n      })\n    }\n\n    const filteredAddrs = resolvedAddresses.filter(addr => {\n      // filter out any multiaddrs that we do not have transports for\n      if (this.components.transportManager.dialTransportForMultiaddr(addr.multiaddr) == null) {\n        return false\n      }\n\n      // if the resolved multiaddr has a PeerID but it's the wrong one, ignore it\n      // - this can happen with addresses like bootstrap.libp2p.io that resolve\n      // to multiple different peers\n      const addrPeerId = addr.multiaddr.getPeerId()\n      if (peerId != null && addrPeerId != null) {\n        return peerId.equals(addrPeerId)\n      }\n\n      return true\n    })\n\n    // deduplicate addresses\n    const dedupedAddrs = new Map<string, Address>()\n\n    for (const addr of filteredAddrs) {\n      const maStr = addr.multiaddr.toString()\n      const existing = dedupedAddrs.get(maStr)\n\n      if (existing != null) {\n        existing.isCertified = existing.isCertified || addr.isCertified || false\n        continue\n      }\n\n      dedupedAddrs.set(maStr, addr)\n    }\n\n    const dedupedMultiaddrs = [...dedupedAddrs.values()]\n\n    // make sure we actually have some addresses to dial\n    if (dedupedMultiaddrs.length === 0) {\n      throw new CodeError('The dial request has no valid addresses', codes.ERR_NO_VALID_ADDRESSES)\n    }\n\n    const gatedAdrs: Address[] = []\n\n    for (const addr of dedupedMultiaddrs) {\n      if (this.components.connectionGater.denyDialMultiaddr != null && await this.components.connectionGater.denyDialMultiaddr(addr.multiaddr)) {\n        continue\n      }\n\n      gatedAdrs.push(addr)\n    }\n\n    const sortedGatedAddrs = gatedAdrs.sort(this.addressSorter)\n\n    // make sure we actually have some addresses to dial\n    if (sortedGatedAddrs.length === 0) {\n      throw new CodeError('The connection gater denied all addresses in the dial request', codes.ERR_NO_VALID_ADDRESSES)\n    }\n\n    this.log.trace('addresses for %p before filtering', peerId ?? 'unknown peer', resolvedAddresses.map(({ multiaddr }) => multiaddr.toString()))\n    this.log.trace('addresses for %p after filtering', peerId ?? 'unknown peer', sortedGatedAddrs.map(({ multiaddr }) => multiaddr.toString()))\n\n    return sortedGatedAddrs\n  }\n\n  async isDialable (multiaddr: Multiaddr | Multiaddr[], options: IsDialableOptions = {}): Promise<boolean> {\n    if (!Array.isArray(multiaddr)) {\n      multiaddr = [multiaddr]\n    }\n\n    try {\n      const addresses = await this.calculateMultiaddrs(undefined, new Set(multiaddr.map(ma => ma.toString())), options)\n\n      if (options.runOnTransientConnection === false) {\n        // return true if any resolved multiaddrs are not relay addresses\n        return addresses.find(addr => {\n          return !Circuit.matches(addr.multiaddr)\n        }) != null\n      }\n\n      return true\n    } catch (err) {\n      this.log.trace('error calculating if multiaddr(s) were dialable', err)\n    }\n\n    return false\n  }\n}\n", "import { CodeError, KEEP_ALIVE } from '@libp2p/interface'\nimport { PeerMap } from '@libp2p/peer-collections'\nimport { defaultAddressSort } from '@libp2p/utils/address-sort'\nimport { RateLimiter } from '@libp2p/utils/rate-limiter'\nimport { type Multiaddr, type Resolver, multiaddr } from '@multiformats/multiaddr'\nimport { dnsaddrResolver } from '@multiformats/multiaddr/resolvers'\nimport { codes } from '../errors.js'\nimport { getPeerAddress } from '../get-peer.js'\nimport { AutoDial } from './auto-dial.js'\nimport { ConnectionPruner } from './connection-pruner.js'\nimport { AUTO_DIAL_CONCURRENCY, AUTO_DIAL_MAX_QUEUE_LENGTH, AUTO_DIAL_PRIORITY, DIAL_TIMEOUT, INBOUND_CONNECTION_THRESHOLD, MAX_CONNECTIONS, MAX_DIAL_QUEUE_LENGTH, MAX_INCOMING_PENDING_CONNECTIONS, MAX_PARALLEL_DIALS, MAX_PEER_ADDRS_TO_DIAL, MIN_CONNECTIONS } from './constants.js'\nimport { DialQueue } from './dial-queue.js'\nimport type { PendingDial, AddressSorter, Libp2pEvents, AbortOptions, ComponentLogger, Logger, Connection, MultiaddrConnection, ConnectionGater, TypedEventTarget, Metrics, PeerId, Peer, PeerStore, Startable, PendingDialStatus, PeerRouting, IsDialableOptions } from '@libp2p/interface'\nimport type { ConnectionManager, OpenConnectionOptions, TransportManager } from '@libp2p/interface-internal'\nimport type { JobStatus } from '@libp2p/utils/queue'\n\nconst DEFAULT_DIAL_PRIORITY = 50\n\nexport interface ConnectionManagerInit {\n  /**\n   * The maximum number of connections libp2p is willing to have before it starts\n   * pruning connections to reduce resource usage. (default: 300, 100 in browsers)\n   */\n  maxConnections?: number\n\n  /**\n   * The minimum number of connections below which libp2p will start to dial peers\n   * from the peer book. Setting this to 0 effectively disables this behaviour.\n   * (default: 50, 5 in browsers)\n   */\n  minConnections?: number\n\n  /**\n   * How long to wait between attempting to keep our number of concurrent connections\n   * above minConnections (default: 5000)\n   */\n  autoDialInterval?: number\n\n  /**\n   * When dialling peers from the peer book to keep the number of open connections\n   * above `minConnections`, add dials for this many peers to the dial queue\n   * at once. (default: 25)\n   */\n  autoDialConcurrency?: number\n\n  /**\n   * To allow user dials to take priority over auto dials, use this value as the\n   * dial priority. (default: 0)\n   */\n  autoDialPriority?: number\n\n  /**\n   * Limit the maximum number of peers to dial when trying to keep the number of\n   * open connections above `minConnections`. (default: 100)\n   */\n  autoDialMaxQueueLength?: number\n\n  /**\n   * When we've failed to dial a peer, do not autodial them again within this\n   * number of ms. (default: 1 minute, 7 minutes in browsers)\n   */\n  autoDialPeerRetryThreshold?: number\n\n  /**\n   * Newly discovered peers may be auto-dialed to increase the number of open\n   * connections, but they can be discovered in quick succession so add a small\n   * delay before attempting to dial them in case more peers have been\n   * discovered. (default: 10ms)\n   */\n  autoDialDiscoveredPeersDebounce?: number\n\n  /**\n   * Sort the known addresses of a peer before trying to dial, By default public\n   * addresses will be dialled before private (e.g. loopback or LAN) addresses.\n   */\n  addressSorter?: AddressSorter\n\n  /**\n   * The maximum number of dials across all peers to execute in parallel.\n   * (default: 100, 50 in browsers)\n   */\n  maxParallelDials?: number\n\n  /**\n   * The maximum size the dial queue is allowed to grow to. Promises returned\n   * when dialing peers after this limit is reached will not resolve until the\n   * queue size falls beneath this size.\n   *\n   * @default 500\n   */\n  maxDialQueueLength?: number\n\n  /**\n   * Maximum number of addresses allowed for a given peer before giving up\n   *\n   * @default 25\n   */\n  maxPeerAddrsToDial?: number\n\n  /**\n   * How long a dial attempt is allowed to take, including DNS resolution\n   * of the multiaddr, opening a socket and upgrading it to a Connection.\n   */\n  dialTimeout?: number\n\n  /**\n   * When a new inbound connection is opened, the upgrade process (e.g. protect,\n   * encrypt, multiplex etc) must complete within this number of ms. (default: 30s)\n   */\n  inboundUpgradeTimeout?: number\n\n  /**\n   * Multiaddr resolvers to use when dialling\n   */\n  resolvers?: Record<string, Resolver>\n\n  /**\n   * A list of multiaddrs that will always be allowed (except if they are in the\n   * deny list) to open connections to this node even if we've reached maxConnections\n   */\n  allow?: string[]\n\n  /**\n   * A list of multiaddrs that will never be allowed to open connections to\n   * this node under any circumstances\n   */\n  deny?: string[]\n\n  /**\n   * If more than this many connections are opened per second by a single\n   * host, reject subsequent connections. (default: 5)\n   */\n  inboundConnectionThreshold?: number\n\n  /**\n   * The maximum number of parallel incoming connections allowed that have yet to\n   * complete the connection upgrade - e.g. choosing connection encryption, muxer, etc.\n   * (default: 10)\n   */\n  maxIncomingPendingConnections?: number\n}\n\nconst defaultOptions = {\n  minConnections: MIN_CONNECTIONS,\n  maxConnections: MAX_CONNECTIONS,\n  inboundConnectionThreshold: INBOUND_CONNECTION_THRESHOLD,\n  maxIncomingPendingConnections: MAX_INCOMING_PENDING_CONNECTIONS,\n  autoDialConcurrency: AUTO_DIAL_CONCURRENCY,\n  autoDialPriority: AUTO_DIAL_PRIORITY,\n  autoDialMaxQueueLength: AUTO_DIAL_MAX_QUEUE_LENGTH\n}\n\nexport interface DefaultConnectionManagerComponents {\n  peerId: PeerId\n  metrics?: Metrics\n  peerStore: PeerStore\n  peerRouting: PeerRouting\n  transportManager: TransportManager\n  connectionGater: ConnectionGater\n  events: TypedEventTarget<Libp2pEvents>\n  logger: ComponentLogger\n}\n\n/**\n * Responsible for managing known connections.\n */\nexport class DefaultConnectionManager implements ConnectionManager, Startable {\n  private started: boolean\n  private readonly connections: PeerMap<Connection[]>\n  private readonly allow: Multiaddr[]\n  private readonly deny: Multiaddr[]\n  private readonly maxIncomingPendingConnections: number\n  private incomingPendingConnections: number\n  private readonly maxConnections: number\n\n  public readonly dialQueue: DialQueue\n  public readonly autoDial: AutoDial\n  public readonly connectionPruner: ConnectionPruner\n  private readonly inboundConnectionRateLimiter: RateLimiter\n  private readonly peerStore: PeerStore\n  private readonly metrics?: Metrics\n  private readonly events: TypedEventTarget<Libp2pEvents>\n  private readonly log: Logger\n\n  constructor (components: DefaultConnectionManagerComponents, init: ConnectionManagerInit = {}) {\n    this.maxConnections = init.maxConnections ?? defaultOptions.maxConnections\n    const minConnections = init.minConnections ?? defaultOptions.minConnections\n\n    if (this.maxConnections < minConnections) {\n      throw new CodeError('Connection Manager maxConnections must be greater than minConnections', codes.ERR_INVALID_PARAMETERS)\n    }\n\n    /**\n     * Map of connections per peer\n     */\n    this.connections = new PeerMap()\n\n    this.started = false\n    this.peerStore = components.peerStore\n    this.metrics = components.metrics\n    this.events = components.events\n    this.log = components.logger.forComponent('libp2p:connection-manager')\n\n    this.onConnect = this.onConnect.bind(this)\n    this.onDisconnect = this.onDisconnect.bind(this)\n    this.events.addEventListener('connection:open', this.onConnect)\n    this.events.addEventListener('connection:close', this.onDisconnect)\n\n    // allow/deny lists\n    this.allow = (init.allow ?? []).map(ma => multiaddr(ma))\n    this.deny = (init.deny ?? []).map(ma => multiaddr(ma))\n\n    this.incomingPendingConnections = 0\n    this.maxIncomingPendingConnections = init.maxIncomingPendingConnections ?? defaultOptions.maxIncomingPendingConnections\n\n    // controls individual peers trying to dial us too quickly\n    this.inboundConnectionRateLimiter = new RateLimiter({\n      points: init.inboundConnectionThreshold ?? defaultOptions.inboundConnectionThreshold,\n      duration: 1\n    })\n\n    // controls what happens when we don't have enough connections\n    this.autoDial = new AutoDial({\n      connectionManager: this,\n      peerStore: components.peerStore,\n      events: components.events,\n      logger: components.logger\n    }, {\n      minConnections,\n      autoDialConcurrency: init.autoDialConcurrency ?? defaultOptions.autoDialConcurrency,\n      autoDialPriority: init.autoDialPriority ?? defaultOptions.autoDialPriority,\n      maxQueueLength: init.autoDialMaxQueueLength ?? defaultOptions.autoDialMaxQueueLength\n    })\n\n    // controls what happens when we have too many connections\n    this.connectionPruner = new ConnectionPruner({\n      connectionManager: this,\n      peerStore: components.peerStore,\n      events: components.events,\n      logger: components.logger\n    }, {\n      maxConnections: this.maxConnections,\n      allow: this.allow\n    })\n\n    this.dialQueue = new DialQueue(components, {\n      addressSorter: init.addressSorter ?? defaultAddressSort,\n      maxParallelDials: init.maxParallelDials ?? MAX_PARALLEL_DIALS,\n      maxDialQueueLength: init.maxDialQueueLength ?? MAX_DIAL_QUEUE_LENGTH,\n      maxPeerAddrsToDial: init.maxPeerAddrsToDial ?? MAX_PEER_ADDRS_TO_DIAL,\n      dialTimeout: init.dialTimeout ?? DIAL_TIMEOUT,\n      resolvers: init.resolvers ?? {\n        dnsaddr: dnsaddrResolver\n      },\n      connections: this.connections\n    })\n  }\n\n  isStarted (): boolean {\n    return this.started\n  }\n\n  /**\n   * Starts the Connection Manager. If Metrics are not enabled on libp2p\n   * only event loop and connection limits will be monitored.\n   */\n  async start (): Promise<void> {\n    // track inbound/outbound connections\n    this.metrics?.registerMetricGroup('libp2p_connection_manager_connections', {\n      calculate: () => {\n        const metric = {\n          inbound: 0,\n          outbound: 0\n        }\n\n        for (const conns of this.connections.values()) {\n          for (const conn of conns) {\n            if (conn.direction === 'inbound') {\n              metric.inbound++\n            } else {\n              metric.outbound++\n            }\n          }\n        }\n\n        return metric\n      }\n    })\n\n    // track total number of streams per protocol\n    this.metrics?.registerMetricGroup('libp2p_protocol_streams_total', {\n      label: 'protocol',\n      calculate: () => {\n        const metric: Record<string, number> = {}\n\n        for (const conns of this.connections.values()) {\n          for (const conn of conns) {\n            for (const stream of conn.streams) {\n              const key = `${stream.direction} ${stream.protocol ?? 'unnegotiated'}`\n\n              metric[key] = (metric[key] ?? 0) + 1\n            }\n          }\n        }\n\n        return metric\n      }\n    })\n\n    // track 90th percentile of streams per protocol\n    this.metrics?.registerMetricGroup('libp2p_connection_manager_protocol_streams_per_connection_90th_percentile', {\n      label: 'protocol',\n      calculate: () => {\n        const allStreams: Record<string, number[]> = {}\n\n        for (const conns of this.connections.values()) {\n          for (const conn of conns) {\n            const streams: Record<string, number> = {}\n\n            for (const stream of conn.streams) {\n              const key = `${stream.direction} ${stream.protocol ?? 'unnegotiated'}`\n\n              streams[key] = (streams[key] ?? 0) + 1\n            }\n\n            for (const [protocol, count] of Object.entries(streams)) {\n              allStreams[protocol] = allStreams[protocol] ?? []\n              allStreams[protocol].push(count)\n            }\n          }\n        }\n\n        const metric: Record<string, number> = {}\n\n        for (let [protocol, counts] of Object.entries(allStreams)) {\n          counts = counts.sort((a, b) => a - b)\n\n          const index = Math.floor(counts.length * 0.9)\n          metric[protocol] = counts[index]\n        }\n\n        return metric\n      }\n    })\n\n    this.dialQueue.start()\n    this.autoDial.start()\n\n    this.started = true\n    this.log('started')\n  }\n\n  async afterStart (): Promise<void> {\n    // re-connect to any peers with the KEEP_ALIVE tag\n    void Promise.resolve()\n      .then(async () => {\n        const keepAlivePeers: Peer[] = await this.peerStore.all({\n          filters: [(peer) => {\n            return peer.tags.has(KEEP_ALIVE)\n          }]\n        })\n\n        await Promise.all(\n          keepAlivePeers.map(async peer => {\n            await this.openConnection(peer.id)\n              .catch(err => {\n                this.log.error(err)\n              })\n          })\n        )\n      })\n      .catch(err => {\n        this.log.error(err)\n      })\n\n    this.autoDial.afterStart()\n  }\n\n  /**\n   * Stops the Connection Manager\n   */\n  async stop (): Promise<void> {\n    this.dialQueue.stop()\n    this.autoDial.stop()\n\n    // Close all connections we're tracking\n    const tasks: Array<Promise<void>> = []\n    for (const connectionList of this.connections.values()) {\n      for (const connection of connectionList) {\n        tasks.push((async () => {\n          try {\n            await connection.close()\n          } catch (err) {\n            this.log.error(err)\n          }\n        })())\n      }\n    }\n\n    this.log('closing %d connections', tasks.length)\n    await Promise.all(tasks)\n    this.connections.clear()\n\n    this.log('stopped')\n  }\n\n  onConnect (evt: CustomEvent<Connection>): void {\n    void this._onConnect(evt).catch(err => {\n      this.log.error(err)\n    })\n  }\n\n  /**\n   * Tracks the incoming connection and check the connection limit\n   */\n  async _onConnect (evt: CustomEvent<Connection>): Promise<void> {\n    const { detail: connection } = evt\n\n    if (!this.started) {\n      // This can happen when we are in the process of shutting down the node\n      await connection.close()\n      return\n    }\n\n    const peerId = connection.remotePeer\n    const storedConns = this.connections.get(peerId)\n    let isNewPeer = false\n\n    if (storedConns != null) {\n      storedConns.push(connection)\n    } else {\n      isNewPeer = true\n      this.connections.set(peerId, [connection])\n    }\n\n    // only need to store RSA public keys, all other types are embedded in the peer id\n    if (peerId.publicKey != null && peerId.type === 'RSA') {\n      await this.peerStore.patch(peerId, {\n        publicKey: peerId.publicKey\n      })\n    }\n\n    if (isNewPeer) {\n      this.events.safeDispatchEvent('peer:connect', { detail: connection.remotePeer })\n    }\n  }\n\n  /**\n   * Removes the connection from tracking\n   */\n  onDisconnect (evt: CustomEvent<Connection>): void {\n    const { detail: connection } = evt\n\n    if (!this.started) {\n      // This can happen when we are in the process of shutting down the node\n      return\n    }\n\n    const peerId = connection.remotePeer\n    let storedConn = this.connections.get(peerId)\n\n    if (storedConn != null && storedConn.length > 1) {\n      storedConn = storedConn.filter((conn) => conn.id !== connection.id)\n      this.connections.set(peerId, storedConn)\n    } else if (storedConn != null) {\n      this.connections.delete(peerId)\n      this.events.safeDispatchEvent('peer:disconnect', { detail: connection.remotePeer })\n    }\n  }\n\n  getConnections (peerId?: PeerId): Connection[] {\n    if (peerId != null) {\n      return this.connections.get(peerId) ?? []\n    }\n\n    let conns: Connection[] = []\n\n    for (const c of this.connections.values()) {\n      conns = conns.concat(c)\n    }\n\n    return conns\n  }\n\n  getConnectionsMap (): PeerMap<Connection[]> {\n    return this.connections\n  }\n\n  async openConnection (peerIdOrMultiaddr: PeerId | Multiaddr | Multiaddr[], options: OpenConnectionOptions = {}): Promise<Connection> {\n    if (!this.isStarted()) {\n      throw new CodeError('Not started', codes.ERR_NODE_NOT_STARTED)\n    }\n\n    options.signal?.throwIfAborted()\n\n    const { peerId } = getPeerAddress(peerIdOrMultiaddr)\n\n    if (peerId != null && options.force !== true) {\n      this.log('dial %p', peerId)\n      const existingConnection = this.getConnections(peerId)\n        .find(conn => !conn.transient)\n\n      if (existingConnection != null) {\n        this.log('had an existing non-transient connection to %p', peerId)\n\n        return existingConnection\n      }\n    }\n\n    const connection = await this.dialQueue.dial(peerIdOrMultiaddr, {\n      ...options,\n      priority: options.priority ?? DEFAULT_DIAL_PRIORITY\n    })\n    let peerConnections = this.connections.get(connection.remotePeer)\n\n    if (peerConnections == null) {\n      peerConnections = []\n      this.connections.set(connection.remotePeer, peerConnections)\n    }\n\n    // we get notified of connections via the Upgrader emitting \"connection\"\n    // events, double check we aren't already tracking this connection before\n    // storing it\n    let trackedConnection = false\n\n    for (const conn of peerConnections) {\n      if (conn.id === connection.id) {\n        trackedConnection = true\n      }\n    }\n\n    if (!trackedConnection) {\n      peerConnections.push(connection)\n    }\n\n    return connection\n  }\n\n  async closeConnections (peerId: PeerId, options: AbortOptions = {}): Promise<void> {\n    const connections = this.connections.get(peerId) ?? []\n\n    await Promise.all(\n      connections.map(async connection => {\n        try {\n          await connection.close(options)\n        } catch (err: any) {\n          connection.abort(err)\n        }\n      })\n    )\n  }\n\n  async acceptIncomingConnection (maConn: MultiaddrConnection): Promise<boolean> {\n    // check deny list\n    const denyConnection = this.deny.some(ma => {\n      return maConn.remoteAddr.toString().startsWith(ma.toString())\n    })\n\n    if (denyConnection) {\n      this.log('connection from %a refused - connection remote address was in deny list', maConn.remoteAddr)\n      return false\n    }\n\n    // check allow list\n    const allowConnection = this.allow.some(ma => {\n      return maConn.remoteAddr.toString().startsWith(ma.toString())\n    })\n\n    if (allowConnection) {\n      this.incomingPendingConnections++\n\n      return true\n    }\n\n    // check pending connections\n    if (this.incomingPendingConnections === this.maxIncomingPendingConnections) {\n      this.log('connection from %a refused - incomingPendingConnections exceeded by host', maConn.remoteAddr)\n      return false\n    }\n\n    if (maConn.remoteAddr.isThinWaistAddress()) {\n      const host = maConn.remoteAddr.nodeAddress().address\n\n      try {\n        await this.inboundConnectionRateLimiter.consume(host, 1)\n      } catch {\n        this.log('connection from %a refused - inboundConnectionThreshold exceeded by host %s', maConn.remoteAddr, host)\n        return false\n      }\n    }\n\n    if (this.getConnections().length < this.maxConnections) {\n      this.incomingPendingConnections++\n\n      return true\n    }\n\n    this.log('connection from %a refused - maxConnections exceeded', maConn.remoteAddr)\n    return false\n  }\n\n  afterUpgradeInbound (): void {\n    this.incomingPendingConnections--\n  }\n\n  getDialQueue (): PendingDial[] {\n    const statusMap: Record<JobStatus, PendingDialStatus> = {\n      queued: 'queued',\n      running: 'active',\n      errored: 'error',\n      complete: 'success'\n    }\n\n    return this.dialQueue.queue.queue.map(job => {\n      return {\n        id: job.id,\n        status: statusMap[job.status],\n        peerId: job.options.peerId,\n        multiaddrs: [...job.options.multiaddrs].map(ma => multiaddr(ma))\n      }\n    })\n  }\n\n  async isDialable (multiaddr: Multiaddr | Multiaddr[], options: IsDialableOptions = {}): Promise<boolean> {\n    return this.dialQueue.isDialable(multiaddr, options)\n  }\n}\n", "import { CodeError } from '@libp2p/interface'\nimport { PeerSet } from '@libp2p/peer-collections'\nimport merge from 'it-merge'\nimport { codes, messages } from './errors.js'\nimport type { AbortOptions, ComponentLogger, ContentRouting, PeerInfo, PeerRouting, PeerStore, RoutingOptions, Startable } from '@libp2p/interface'\nimport type { CID } from 'multiformats/cid'\n\nexport interface CompoundContentRoutingInit {\n  routers: ContentRouting[]\n}\n\nexport interface CompoundContentRoutingComponents {\n  peerStore: PeerStore\n  peerRouting: PeerRouting\n  logger: ComponentLogger\n}\n\nexport class CompoundContentRouting implements ContentRouting, Startable {\n  private readonly routers: ContentRouting[]\n  private started: boolean\n  private readonly components: CompoundContentRoutingComponents\n\n  constructor (components: CompoundContentRoutingComponents, init: CompoundContentRoutingInit) {\n    this.routers = init.routers ?? []\n    this.started = false\n    this.components = components\n  }\n\n  isStarted (): boolean {\n    return this.started\n  }\n\n  async start (): Promise<void> {\n    this.started = true\n  }\n\n  async stop (): Promise<void> {\n    this.started = false\n  }\n\n  /**\n   * Iterates over all content routers in parallel to find providers of the given key\n   */\n  async * findProviders (key: CID, options: RoutingOptions = {}): AsyncIterable<PeerInfo> {\n    if (this.routers.length === 0) {\n      throw new CodeError('No content routers available', codes.ERR_NO_ROUTERS_AVAILABLE)\n    }\n\n    const self = this\n    const seen = new PeerSet()\n\n    for await (const peer of merge(\n      ...self.routers.map(router => router.findProviders(key, options))\n    )) {\n      // the peer was yielded by a content router without multiaddrs and we\n      // failed to load them\n      if (peer == null) {\n        continue\n      }\n\n      // store the addresses for the peer if found\n      if (peer.multiaddrs.length > 0) {\n        await this.components.peerStore.merge(peer.id, {\n          multiaddrs: peer.multiaddrs\n        })\n      }\n\n      // deduplicate peers\n      if (seen.has(peer.id)) {\n        continue\n      }\n\n      seen.add(peer.id)\n\n      yield peer\n    }\n  }\n\n  /**\n   * Iterates over all content routers in parallel to notify it is\n   * a provider of the given key\n   */\n  async provide (key: CID, options: AbortOptions = {}): Promise<void> {\n    if (this.routers.length === 0) {\n      throw new CodeError('No content routers available', codes.ERR_NO_ROUTERS_AVAILABLE)\n    }\n\n    await Promise.all(this.routers.map(async (router) => {\n      await router.provide(key, options)\n    }))\n  }\n\n  /**\n   * Store the given key/value pair in the available content routings\n   */\n  async put (key: Uint8Array, value: Uint8Array, options?: AbortOptions): Promise<void> {\n    if (!this.isStarted()) {\n      throw new CodeError(messages.NOT_STARTED_YET, codes.ERR_NODE_NOT_STARTED)\n    }\n\n    await Promise.all(this.routers.map(async (router) => {\n      await router.put(key, value, options)\n    }))\n  }\n\n  /**\n   * Get the value to the given key.\n   * Times out after 1 minute by default.\n   */\n  async get (key: Uint8Array, options?: AbortOptions): Promise<Uint8Array> {\n    if (!this.isStarted()) {\n      throw new CodeError(messages.NOT_STARTED_YET, codes.ERR_NODE_NOT_STARTED)\n    }\n\n    return Promise.any(this.routers.map(async (router) => {\n      return router.get(key, options)\n    }))\n  }\n}\n", "/**\n * @packageDocumentation\n *\n * Takes an (async) iterable that emits promise-returning functions, invokes them in parallel up to the concurrency limit and emits the results as they become available, optionally in the same order as the input\n *\n * @example\n *\n * ```javascript\n * import parallel from 'it-parallel'\n * import all from 'it-all'\n * import delay from 'delay'\n *\n * // This can also be an iterator, async iterator, generator, etc\n * const input = [\n *   async () => {\n *     console.info('start 1')\n *     await delay(500)\n *\n *     console.info('end 1')\n *     return 1\n *   },\n *   async () => {\n *     console.info('start 2')\n *     await delay(200)\n *\n *     console.info('end 2')\n *     return 2\n *   },\n *   async () => {\n *     console.info('start 3')\n *     await delay(100)\n *\n *     console.info('end 3')\n *     return 3\n *   }\n * ]\n *\n * const result = await all(parallel(input, {\n *   concurrency: 2\n * }))\n *\n * // output:\n * // start 1\n * // start 2\n * // end 2\n * // start 3\n * // end 3\n * // end 1\n *\n * console.info(result) // [2, 3, 1]\n * ```\n *\n * If order is important, pass `ordered: true` as an option:\n *\n * ```javascript\n * const result = await all(parallel(input, {\n *   concurrency: 2,\n *   ordered: true\n * }))\n *\n * // output:\n * // start 1\n * // start 2\n * // end 2\n * // start 3\n * // end 3\n * // end 1\n *\n * console.info(result) // [1, 2, 3]\n * ```\n */\n\nimport defer from 'p-defer'\n\ninterface Operation<T> {\n  done: boolean\n  ok: boolean\n  err: Error\n  value: T\n}\n\nconst CustomEvent = globalThis.CustomEvent ?? Event\n\nexport interface ParallelOptions {\n  /**\n   * How many jobs to execute in parallel (default: )\n   */\n  concurrency?: number\n  ordered?: boolean\n}\n\n/**\n * Takes an (async) iterator that emits promise-returning functions,\n * invokes them in parallel and emits the results as they become available but\n * in the same order as the input\n */\nexport default async function * parallel <T> (source: Iterable<() => Promise<T>> | AsyncIterable<() => Promise<T>>, options: ParallelOptions = {}): AsyncGenerator<T, void, undefined> {\n  let concurrency = options.concurrency ?? Infinity\n\n  if (concurrency < 1) {\n    concurrency = Infinity\n  }\n\n  const ordered = options.ordered == null ? false : options.ordered\n  const emitter = new EventTarget()\n\n  const ops: Array<Operation<T>> = []\n  let slotAvailable = defer()\n  let resultAvailable = defer()\n  let sourceFinished = false\n  let sourceErr: Error | undefined\n  let opErred = false\n\n  emitter.addEventListener('task-complete', () => {\n    resultAvailable.resolve()\n  })\n\n  void Promise.resolve().then(async () => {\n    try {\n      for await (const task of source) {\n        if (ops.length === concurrency) {\n          slotAvailable = defer()\n          await slotAvailable.promise\n        }\n\n        if (opErred) {\n          break\n        }\n\n        const op: any = {\n          done: false\n        }\n        ops.push(op)\n\n        task()\n          .then(result => {\n            op.done = true\n            op.ok = true\n            op.value = result\n            emitter.dispatchEvent(new CustomEvent('task-complete'))\n          }, err => {\n            op.done = true\n            op.err = err\n            emitter.dispatchEvent(new CustomEvent('task-complete'))\n          })\n      }\n\n      sourceFinished = true\n      emitter.dispatchEvent(new CustomEvent('task-complete'))\n    } catch (err: any) {\n      sourceErr = err\n      emitter.dispatchEvent(new CustomEvent('task-complete'))\n    }\n  })\n\n  function valuesAvailable (): boolean {\n    if (ordered) {\n      return ops[0]?.done\n    }\n\n    return Boolean(ops.find(op => op.done))\n  }\n\n  function * yieldOrderedValues (): Generator<T, void, unknown> {\n    while ((ops.length > 0) && ops[0].done) {\n      const op = ops[0]\n      ops.shift()\n\n      if (op.ok) {\n        yield op.value\n      } else {\n        // allow the source to exit\n        opErred = true\n        slotAvailable.resolve()\n\n        throw op.err\n      }\n\n      slotAvailable.resolve()\n    }\n  }\n\n  function * yieldUnOrderedValues (): Generator<T, void, unknown> {\n    // more values can become available while we wait for `yield`\n    // to return control to this function\n    while (valuesAvailable()) {\n      for (let i = 0; i < ops.length; i++) {\n        if (ops[i].done) {\n          const op = ops[i]\n          ops.splice(i, 1)\n          i--\n\n          if (op.ok) {\n            yield op.value\n          } else {\n            opErred = true\n            slotAvailable.resolve()\n\n            throw op.err\n          }\n\n          slotAvailable.resolve()\n        }\n      }\n    }\n  }\n\n  while (true) {\n    if (!valuesAvailable()) {\n      resultAvailable = defer()\n      await resultAvailable.promise\n    }\n\n    if (sourceErr != null) {\n      // the source threw an error, propagate it\n      throw sourceErr\n    }\n\n    if (ordered) {\n      yield * yieldOrderedValues()\n    } else {\n      yield * yieldUnOrderedValues()\n    }\n\n    if (sourceFinished && ops.length === 0) {\n      // not waiting for any results and no more tasks so we are done\n      break\n    }\n  }\n}\n", "import { CodeError } from '@libp2p/interface'\nimport { PeerSet } from '@libp2p/peer-collections'\nimport merge from 'it-merge'\nimport parallel from 'it-parallel'\nimport { codes, messages } from './errors.js'\nimport type { Logger, PeerId, PeerInfo, PeerRouting, PeerStore, RoutingOptions } from '@libp2p/interface'\nimport type { ComponentLogger } from '@libp2p/logger'\n\nexport interface PeerRoutingInit {\n  routers?: PeerRouting[]\n}\n\nexport interface DefaultPeerRoutingComponents {\n  peerId: PeerId\n  peerStore: PeerStore\n  logger: ComponentLogger\n}\n\nexport class DefaultPeerRouting implements PeerRouting {\n  private readonly log: Logger\n  private readonly peerId: PeerId\n  private readonly peerStore: PeerStore\n  private readonly routers: PeerRouting[]\n\n  constructor (components: DefaultPeerRoutingComponents, init: PeerRoutingInit = {}) {\n    this.log = components.logger.forComponent('libp2p:peer-routing')\n    this.peerId = components.peerId\n    this.peerStore = components.peerStore\n    this.routers = init.routers ?? []\n  }\n\n  /**\n   * Iterates over all peer routers in parallel to find the given peer\n   */\n  async findPeer (id: PeerId, options?: RoutingOptions): Promise<PeerInfo> {\n    if (this.routers.length === 0) {\n      throw new CodeError('No peer routers available', codes.ERR_NO_ROUTERS_AVAILABLE)\n    }\n\n    if (id.toString() === this.peerId.toString()) {\n      throw new CodeError('Should not try to find self', codes.ERR_FIND_SELF)\n    }\n\n    const self = this\n    const source = merge(\n      ...this.routers.map(router => (async function * () {\n        try {\n          yield await router.findPeer(id, options)\n        } catch (err) {\n          self.log.error(err)\n        }\n      })())\n    )\n\n    for await (const peer of source) {\n      if (peer == null) {\n        continue\n      }\n\n      // store the addresses for the peer if found\n      if (peer.multiaddrs.length > 0) {\n        await this.peerStore.merge(peer.id, {\n          multiaddrs: peer.multiaddrs\n        })\n      }\n\n      return peer\n    }\n\n    throw new CodeError(messages.NOT_FOUND, codes.ERR_NOT_FOUND)\n  }\n\n  /**\n   * Attempt to find the closest peers on the network to the given key\n   */\n  async * getClosestPeers (key: Uint8Array, options: RoutingOptions = {}): AsyncIterable<PeerInfo> {\n    if (this.routers.length === 0) {\n      throw new CodeError('No peer routers available', codes.ERR_NO_ROUTERS_AVAILABLE)\n    }\n\n    const self = this\n    const seen = new PeerSet()\n\n    for await (const peer of parallel(\n      async function * () {\n        const source = merge(\n          ...self.routers.map(router => router.getClosestPeers(key, options))\n        )\n\n        for await (let peer of source) {\n          yield async () => {\n            // find multiaddrs if they are missing\n            if (peer.multiaddrs.length === 0) {\n              try {\n                peer = await self.findPeer(peer.id, {\n                  ...options,\n                  useCache: false\n                })\n              } catch (err) {\n                self.log.error('could not find peer multiaddrs', err)\n                return\n              }\n            }\n\n            return peer\n          }\n        }\n      }()\n    )) {\n      if (peer == null) {\n        continue\n      }\n\n      // store the addresses for the peer if found\n      if (peer.multiaddrs.length > 0) {\n        await this.peerStore.merge(peer.id, {\n          multiaddrs: peer.multiaddrs\n        })\n      }\n\n      // deduplicate peers\n      if (seen.has(peer.id)) {\n        continue\n      }\n\n      seen.add(peer.id)\n\n      yield peer\n    }\n  }\n}\n", "import { randomBytes } from '@libp2p/crypto'\nimport { TypedEventEmitter, setMaxListeners } from '@libp2p/interface'\nimport { anySignal } from 'any-signal'\nimport pDefer, { type DeferredPromise } from 'p-defer'\nimport { raceEvent } from 'race-event'\nimport { raceSignal } from 'race-signal'\nimport type { AbortOptions, ComponentLogger, Logger, PeerInfo, PeerRouting, Startable } from '@libp2p/interface'\nimport type { RandomWalk as RandomWalkInterface } from '@libp2p/interface-internal'\n\nexport interface RandomWalkComponents {\n  peerRouting: PeerRouting\n  logger: ComponentLogger\n}\n\ninterface RandomWalkEvents {\n  'walk:peer': CustomEvent<PeerInfo>\n  'walk:error': CustomEvent<Error>\n}\n\nexport class RandomWalk extends TypedEventEmitter<RandomWalkEvents> implements RandomWalkInterface, Startable {\n  private readonly peerRouting: PeerRouting\n  private readonly log: Logger\n  private walking: boolean\n  private walkers: number\n  private shutdownController: AbortController\n  private walkController?: AbortController\n  private needNext?: DeferredPromise<void>\n\n  constructor (components: RandomWalkComponents) {\n    super()\n\n    this.log = components.logger.forComponent('libp2p:random-walk')\n    this.peerRouting = components.peerRouting\n    this.walkers = 0\n    this.walking = false\n\n    // stops any in-progress walks when the node is shut down\n    this.shutdownController = new AbortController()\n    setMaxListeners(Infinity, this.shutdownController.signal)\n  }\n\n  start (): void {\n    this.shutdownController = new AbortController()\n    setMaxListeners(Infinity, this.shutdownController.signal)\n  }\n\n  stop (): void {\n    this.shutdownController.abort()\n  }\n\n  async * walk (options?: AbortOptions): AsyncGenerator<PeerInfo> {\n    if (!this.walking) {\n      // start the query that causes walk:peer events to be emitted\n      this.startWalk()\n    }\n\n    this.walkers++\n    const signal = anySignal([this.shutdownController.signal, options?.signal])\n    setMaxListeners(Infinity, signal)\n\n    try {\n      while (true) {\n        // if another consumer has paused the query, start it again\n        this.needNext?.resolve()\n        this.needNext = pDefer()\n\n        // wait for a walk:peer or walk:error event\n        const event = await raceEvent<CustomEvent<PeerInfo>>(this, 'walk:peer', signal, {\n          errorEvent: 'walk:error'\n        })\n\n        yield event.detail\n      }\n    } finally {\n      signal.clear()\n      this.walkers--\n\n      // stop the walk if no more consumers are interested\n      if (this.walkers === 0) {\n        this.walkController?.abort()\n        this.walkController = undefined\n      }\n    }\n  }\n\n  private startWalk (): void {\n    this.walking = true\n\n    // the signal for this controller will be aborted if no more random peers\n    // are required\n    this.walkController = new AbortController()\n    setMaxListeners(Infinity, this.walkController.signal)\n\n    const signal = anySignal([this.walkController.signal, this.shutdownController.signal])\n    setMaxListeners(Infinity, signal)\n\n    const start = Date.now()\n    let found = 0\n\n    Promise.resolve().then(async () => {\n      this.log('start walk')\n\n      // find peers until no more consumers are interested\n      while (this.walkers > 0) {\n        try {\n          for await (const peer of this.peerRouting.getClosestPeers(randomBytes(32), { signal })) {\n            signal.throwIfAborted()\n\n            this.log('found peer %p', peer.id)\n            found++\n            this.safeDispatchEvent('walk:peer', {\n              detail: peer\n            })\n\n            // if we only have one consumer, pause the query until they request\n            // another random peer or they signal they are no longer interested\n            if (this.walkers === 1 && this.needNext != null) {\n              await raceSignal(this.needNext.promise, signal)\n            }\n          }\n        } catch (err) {\n          this.log.error('randomwalk errored', err)\n\n          this.safeDispatchEvent('walk:error', {\n            detail: err\n          })\n        }\n      }\n    })\n      .catch(err => {\n        this.log.error('randomwalk errored', err)\n      })\n      .finally(() => {\n        this.log('finished walk, found %d peers after %dms', found, Date.now() - start)\n        this.walking = false\n      })\n  }\n}\n", "import { CodeError } from '@libp2p/interface'\nimport merge from 'merge-options'\nimport { codes } from './errors.js'\nimport type { IdentifyResult, Libp2pEvents, Logger, PeerUpdate, TypedEventTarget, PeerId, PeerStore, Topology } from '@libp2p/interface'\nimport type { ConnectionManager, StreamHandlerOptions, StreamHandlerRecord, Registrar, StreamHandler } from '@libp2p/interface-internal'\nimport type { ComponentLogger } from '@libp2p/logger'\n\nexport const DEFAULT_MAX_INBOUND_STREAMS = 32\nexport const DEFAULT_MAX_OUTBOUND_STREAMS = 64\n\nexport interface RegistrarComponents {\n  peerId: PeerId\n  connectionManager: ConnectionManager\n  peerStore: PeerStore\n  events: TypedEventTarget<Libp2pEvents>\n  logger: ComponentLogger\n}\n\n/**\n * Responsible for notifying registered protocols of events in the network.\n */\nexport class DefaultRegistrar implements Registrar {\n  private readonly log: Logger\n  private readonly topologies: Map<string, Map<string, Topology>>\n  private readonly handlers: Map<string, StreamHandlerRecord>\n  private readonly components: RegistrarComponents\n\n  constructor (components: RegistrarComponents) {\n    this.log = components.logger.forComponent('libp2p:registrar')\n    this.topologies = new Map()\n    this.handlers = new Map()\n    this.components = components\n\n    this._onDisconnect = this._onDisconnect.bind(this)\n    this._onPeerUpdate = this._onPeerUpdate.bind(this)\n    this._onPeerIdentify = this._onPeerIdentify.bind(this)\n\n    this.components.events.addEventListener('peer:disconnect', this._onDisconnect)\n    this.components.events.addEventListener('peer:update', this._onPeerUpdate)\n    this.components.events.addEventListener('peer:identify', this._onPeerIdentify)\n  }\n\n  getProtocols (): string[] {\n    return Array.from(new Set<string>([\n      ...this.handlers.keys()\n    ])).sort()\n  }\n\n  getHandler (protocol: string): StreamHandlerRecord {\n    const handler = this.handlers.get(protocol)\n\n    if (handler == null) {\n      throw new CodeError(`No handler registered for protocol ${protocol}`, codes.ERR_NO_HANDLER_FOR_PROTOCOL)\n    }\n\n    return handler\n  }\n\n  getTopologies (protocol: string): Topology[] {\n    const topologies = this.topologies.get(protocol)\n\n    if (topologies == null) {\n      return []\n    }\n\n    return [\n      ...topologies.values()\n    ]\n  }\n\n  /**\n   * Registers the `handler` for each protocol\n   */\n  async handle (protocol: string, handler: StreamHandler, opts?: StreamHandlerOptions): Promise<void> {\n    if (this.handlers.has(protocol)) {\n      throw new CodeError(`Handler already registered for protocol ${protocol}`, codes.ERR_PROTOCOL_HANDLER_ALREADY_REGISTERED)\n    }\n\n    const options = merge.bind({ ignoreUndefined: true })({\n      maxInboundStreams: DEFAULT_MAX_INBOUND_STREAMS,\n      maxOutboundStreams: DEFAULT_MAX_OUTBOUND_STREAMS\n    }, opts)\n\n    this.handlers.set(protocol, {\n      handler,\n      options\n    })\n\n    // Add new protocol to self protocols in the peer store\n    await this.components.peerStore.merge(this.components.peerId, {\n      protocols: [protocol]\n    })\n  }\n\n  /**\n   * Removes the handler for each protocol. The protocol\n   * will no longer be supported on streams.\n   */\n  async unhandle (protocols: string | string[]): Promise<void> {\n    const protocolList = Array.isArray(protocols) ? protocols : [protocols]\n\n    protocolList.forEach(protocol => {\n      this.handlers.delete(protocol)\n    })\n\n    // Update self protocols in the peer store\n    await this.components.peerStore.patch(this.components.peerId, {\n      protocols: this.getProtocols()\n    })\n  }\n\n  /**\n   * Register handlers for a set of multicodecs given\n   */\n  async register (protocol: string, topology: Topology): Promise<string> {\n    if (topology == null) {\n      throw new CodeError('invalid topology', codes.ERR_INVALID_PARAMETERS)\n    }\n\n    // Create topology\n    const id = `${(Math.random() * 1e9).toString(36)}${Date.now()}`\n\n    let topologies = this.topologies.get(protocol)\n\n    if (topologies == null) {\n      topologies = new Map<string, Topology>()\n      this.topologies.set(protocol, topologies)\n    }\n\n    topologies.set(id, topology)\n\n    return id\n  }\n\n  /**\n   * Unregister topology\n   */\n  unregister (id: string): void {\n    for (const [protocol, topologies] of this.topologies.entries()) {\n      if (topologies.has(id)) {\n        topologies.delete(id)\n\n        if (topologies.size === 0) {\n          this.topologies.delete(protocol)\n        }\n      }\n    }\n  }\n\n  /**\n   * Remove a disconnected peer from the record\n   */\n  _onDisconnect (evt: CustomEvent<PeerId>): void {\n    const remotePeer = evt.detail\n\n    void this.components.peerStore.get(remotePeer)\n      .then(peer => {\n        for (const protocol of peer.protocols) {\n          const topologies = this.topologies.get(protocol)\n\n          if (topologies == null) {\n            // no topologies are interested in this protocol\n            continue\n          }\n\n          for (const topology of topologies.values()) {\n            topology.onDisconnect?.(remotePeer)\n          }\n        }\n      })\n      .catch(err => {\n        if (err.code === codes.ERR_NOT_FOUND) {\n          // peer has not completed identify so they are not in the peer store\n          return\n        }\n\n        this.log.error('could not inform topologies of disconnecting peer %p', remotePeer, err)\n      })\n  }\n\n  /**\n   * When a peer is updated, if they have removed supported protocols notify any\n   * topologies interested in the removed protocols.\n   */\n  _onPeerUpdate (evt: CustomEvent<PeerUpdate>): void {\n    const { peer, previous } = evt.detail\n    const removed = (previous?.protocols ?? []).filter(protocol => !peer.protocols.includes(protocol))\n\n    for (const protocol of removed) {\n      const topologies = this.topologies.get(protocol)\n\n      if (topologies == null) {\n        // no topologies are interested in this protocol\n        continue\n      }\n\n      for (const topology of topologies.values()) {\n        topology.onDisconnect?.(peer.id)\n      }\n    }\n  }\n\n  /**\n   * After identify has completed and we have received the list of supported\n   * protocols, notify any topologies interested in those protocols.\n   */\n  _onPeerIdentify (evt: CustomEvent<IdentifyResult>): void {\n    const protocols = evt.detail.protocols\n    const connection = evt.detail.connection\n    const peerId = evt.detail.peerId\n\n    for (const protocol of protocols) {\n      const topologies = this.topologies.get(protocol)\n\n      if (topologies == null) {\n        // no topologies are interested in this protocol\n        continue\n      }\n\n      for (const topology of topologies.values()) {\n        if (connection.transient && topology.notifyOnTransient !== true) {\n          continue\n        }\n\n        topology.onConnect?.(peerId, connection)\n      }\n    }\n  }\n}\n", "import type { Metric, Metrics } from '@libp2p/interface'\n\nexport interface TrackedMapInit {\n  name: string\n  metrics: Metrics\n}\n\nclass TrackedMap<K, V> extends Map<K, V> {\n  private readonly metric: Metric\n\n  constructor (init: TrackedMapInit) {\n    super()\n\n    const { name, metrics } = init\n\n    this.metric = metrics.registerMetric(name)\n    this.updateComponentMetric()\n  }\n\n  set (key: K, value: V): this {\n    super.set(key, value)\n    this.updateComponentMetric()\n    return this\n  }\n\n  delete (key: K): boolean {\n    const deleted = super.delete(key)\n    this.updateComponentMetric()\n    return deleted\n  }\n\n  clear (): void {\n    super.clear()\n    this.updateComponentMetric()\n  }\n\n  private updateComponentMetric (): void {\n    this.metric.update(this.size)\n  }\n}\n\nexport interface CreateTrackedMapInit {\n  /**\n   * The metric name to use\n   */\n  name: string\n\n  /**\n   * A metrics implementation\n   */\n  metrics?: Metrics\n}\n\nexport function trackedMap <K, V> (config: CreateTrackedMapInit): Map<K, V> {\n  const { name, metrics } = config\n  let map: Map<K, V>\n\n  if (metrics != null) {\n    map = new TrackedMap<K, V>({ name, metrics })\n  } else {\n    map = new Map<K, V>()\n  }\n\n  return map\n}\n", "import { CodeError, FaultTolerance } from '@libp2p/interface'\nimport { trackedMap } from '@libp2p/utils/tracked-map'\nimport { codes } from './errors.js'\nimport type { Libp2pEvents, AbortOptions, ComponentLogger, Logger, Connection, TypedEventTarget, Metrics, Startable, Listener, Transport, Upgrader } from '@libp2p/interface'\nimport type { AddressManager, TransportManager } from '@libp2p/interface-internal'\nimport type { Multiaddr } from '@multiformats/multiaddr'\n\nexport interface TransportManagerInit {\n  faultTolerance?: FaultTolerance\n}\n\nexport interface DefaultTransportManagerComponents {\n  metrics?: Metrics\n  addressManager: AddressManager\n  upgrader: Upgrader\n  events: TypedEventTarget<Libp2pEvents>\n  logger: ComponentLogger\n}\n\nexport class DefaultTransportManager implements TransportManager, Startable {\n  private readonly log: Logger\n  private readonly components: DefaultTransportManagerComponents\n  private readonly transports: Map<string, Transport>\n  private readonly listeners: Map<string, Listener[]>\n  private readonly faultTolerance: FaultTolerance\n  private started: boolean\n\n  constructor (components: DefaultTransportManagerComponents, init: TransportManagerInit = {}) {\n    this.log = components.logger.forComponent('libp2p:transports')\n    this.components = components\n    this.started = false\n    this.transports = new Map<string, Transport>()\n    this.listeners = trackedMap({\n      name: 'libp2p_transport_manager_listeners',\n      metrics: this.components.metrics\n    })\n    this.faultTolerance = init.faultTolerance ?? FaultTolerance.FATAL_ALL\n  }\n\n  /**\n   * Adds a `Transport` to the manager\n   */\n  add (transport: Transport): void {\n    const tag = transport[Symbol.toStringTag]\n\n    if (tag == null) {\n      throw new CodeError('Transport must have a valid tag', codes.ERR_INVALID_KEY)\n    }\n\n    if (this.transports.has(tag)) {\n      throw new CodeError(`There is already a transport with the tag ${tag}`, codes.ERR_DUPLICATE_TRANSPORT)\n    }\n\n    this.log('adding transport %s', tag)\n\n    this.transports.set(tag, transport)\n\n    if (!this.listeners.has(tag)) {\n      this.listeners.set(tag, [])\n    }\n  }\n\n  isStarted (): boolean {\n    return this.started\n  }\n\n  start (): void {\n    this.started = true\n  }\n\n  async afterStart (): Promise<void> {\n    // Listen on the provided transports for the provided addresses\n    const addrs = this.components.addressManager.getListenAddrs()\n\n    await this.listen(addrs)\n  }\n\n  /**\n   * Stops all listeners\n   */\n  async stop (): Promise<void> {\n    const tasks = []\n    for (const [key, listeners] of this.listeners) {\n      this.log('closing listeners for %s', key)\n      while (listeners.length > 0) {\n        const listener = listeners.pop()\n\n        if (listener == null) {\n          continue\n        }\n\n        tasks.push(listener.close())\n      }\n    }\n\n    await Promise.all(tasks)\n    this.log('all listeners closed')\n    for (const key of this.listeners.keys()) {\n      this.listeners.set(key, [])\n    }\n\n    this.started = false\n  }\n\n  /**\n   * Dials the given Multiaddr over it's supported transport\n   */\n  async dial (ma: Multiaddr, options?: AbortOptions): Promise<Connection> {\n    const transport = this.dialTransportForMultiaddr(ma)\n\n    if (transport == null) {\n      throw new CodeError(`No transport available for address ${String(ma)}`, codes.ERR_TRANSPORT_UNAVAILABLE)\n    }\n\n    try {\n      return await transport.dial(ma, {\n        ...options,\n        upgrader: this.components.upgrader\n      })\n    } catch (err: any) {\n      if (err.code == null) {\n        err.code = codes.ERR_TRANSPORT_DIAL_FAILED\n      }\n\n      throw err\n    }\n  }\n\n  /**\n   * Returns all Multiaddr's the listeners are using\n   */\n  getAddrs (): Multiaddr[] {\n    let addrs: Multiaddr[] = []\n    for (const listeners of this.listeners.values()) {\n      for (const listener of listeners) {\n        addrs = [...addrs, ...listener.getAddrs()]\n      }\n    }\n    return addrs\n  }\n\n  /**\n   * Returns all the transports instances\n   */\n  getTransports (): Transport[] {\n    return Array.of(...this.transports.values())\n  }\n\n  /**\n   * Returns all the listener instances\n   */\n  getListeners (): Listener[] {\n    return Array.of(...this.listeners.values()).flat()\n  }\n\n  /**\n   * Finds a transport that matches the given Multiaddr\n   */\n  dialTransportForMultiaddr (ma: Multiaddr): Transport | undefined {\n    for (const transport of this.transports.values()) {\n      const addrs = transport.dialFilter([ma])\n\n      if (addrs.length > 0) {\n        return transport\n      }\n    }\n  }\n\n  /**\n   * Finds a transport that matches the given Multiaddr\n   */\n  listenTransportForMultiaddr (ma: Multiaddr): Transport | undefined {\n    for (const transport of this.transports.values()) {\n      const addrs = transport.listenFilter([ma])\n\n      if (addrs.length > 0) {\n        return transport\n      }\n    }\n  }\n\n  /**\n   * Starts listeners for each listen Multiaddr\n   */\n  async listen (addrs: Multiaddr[]): Promise<void> {\n    if (!this.isStarted()) {\n      throw new CodeError('Not started', codes.ERR_NODE_NOT_STARTED)\n    }\n\n    if (addrs == null || addrs.length === 0) {\n      this.log('no addresses were provided for listening, this node is dial only')\n      return\n    }\n\n    const couldNotListen = []\n\n    for (const [key, transport] of this.transports.entries()) {\n      const supportedAddrs = transport.listenFilter(addrs)\n      const tasks = []\n\n      // For each supported multiaddr, create a listener\n      for (const addr of supportedAddrs) {\n        this.log('creating listener for %s on %a', key, addr)\n        const listener = transport.createListener({\n          upgrader: this.components.upgrader\n        })\n\n        let listeners: Listener[] = this.listeners.get(key) ?? []\n\n        if (listeners == null) {\n          listeners = []\n          this.listeners.set(key, listeners)\n        }\n\n        listeners.push(listener)\n\n        // Track listen/close events\n        listener.addEventListener('listening', () => {\n          this.components.events.safeDispatchEvent('transport:listening', {\n            detail: listener\n          })\n        })\n        listener.addEventListener('close', () => {\n          const index = listeners.findIndex(l => l === listener)\n\n          // remove the listener\n          listeners.splice(index, 1)\n\n          this.components.events.safeDispatchEvent('transport:close', {\n            detail: listener\n          })\n        })\n\n        // We need to attempt to listen on everything\n        tasks.push(listener.listen(addr))\n      }\n\n      // Keep track of transports we had no addresses for\n      if (tasks.length === 0) {\n        couldNotListen.push(key)\n        continue\n      }\n\n      const results = await Promise.allSettled(tasks)\n      // If we are listening on at least 1 address, succeed.\n      // TODO: we should look at adding a retry (`p-retry`) here to better support\n      // listening on remote addresses as they may be offline. We could then potentially\n      // just wait for any (`p-any`) listener to succeed on each transport before returning\n      const isListening = results.find(r => r.status === 'fulfilled')\n      if ((isListening == null) && this.faultTolerance !== FaultTolerance.NO_FATAL) {\n        throw new CodeError(`Transport (${key}) could not listen on any available address`, codes.ERR_NO_VALID_ADDRESSES)\n      }\n    }\n\n    // If no transports were able to listen, throw an error. This likely\n    // means we were given addresses we do not have transports for\n    if (couldNotListen.length === this.transports.size) {\n      const message = `no valid addresses were provided for transports [${couldNotListen.join(', ')}]`\n      if (this.faultTolerance === FaultTolerance.FATAL_ALL) {\n        throw new CodeError(message, codes.ERR_NO_VALID_ADDRESSES)\n      }\n      this.log(`libp2p in dial mode only: ${message}`)\n    }\n  }\n\n  /**\n   * Removes the given transport from the manager.\n   * If a transport has any running listeners, they will be closed.\n   */\n  async remove (key: string): Promise<void> {\n    const listeners = this.listeners.get(key) ?? []\n    this.log.trace('removing transport %s', key)\n\n    // Close any running listeners\n    const tasks = []\n    this.log.trace('closing listeners for %s', key)\n    while (listeners.length > 0) {\n      const listener = listeners.pop()\n\n      if (listener == null) {\n        continue\n      }\n\n      tasks.push(listener.close())\n    }\n    await Promise.all(tasks)\n\n    this.transports.delete(key)\n    this.listeners.delete(key)\n  }\n\n  /**\n   * Removes all transports from the manager.\n   * If any listeners are running, they will be closed.\n   *\n   * @async\n   */\n  async removeAll (): Promise<void> {\n    const tasks = []\n    for (const key of this.transports.keys()) {\n      tasks.push(this.remove(key))\n    }\n\n    await Promise.all(tasks)\n  }\n}\n", "export const PROTOCOL_ID = '/multistream/1.0.0'\n\n// Conforming to go-libp2p\n// See https://github.com/multiformats/go-multistream/blob/master/multistream.go#L297\nexport const MAX_PROTOCOL_LENGTH = 1024\n", "import { CodeError } from '@libp2p/interface'\nimport { type Uint8ArrayList } from 'uint8arraylist'\nimport { fromString as uint8ArrayFromString } from 'uint8arrays/from-string'\nimport { toString as uint8ArrayToString } from 'uint8arrays/to-string'\nimport type { AbortOptions, LoggerOptions } from '@libp2p/interface'\nimport type { LengthPrefixedStream } from 'it-length-prefixed-stream'\nimport type { Duplex, Source } from 'it-stream-types'\n\nconst NewLine = uint8ArrayFromString('\\n')\n\n/**\n * `write` encodes and writes a single buffer\n */\nexport async function write (writer: LengthPrefixedStream<Duplex<AsyncGenerator<Uint8Array | Uint8ArrayList>, Source<Uint8Array>>>, buffer: Uint8Array | Uint8ArrayList, options?: AbortOptions): Promise<void> {\n  await writer.write(buffer, options)\n}\n\n/**\n * `writeAll` behaves like `write`, except it encodes an array of items as a single write\n */\nexport async function writeAll (writer: LengthPrefixedStream<Duplex<AsyncGenerator<Uint8Array | Uint8ArrayList>, Source<Uint8Array>>>, buffers: Uint8Array[], options?: AbortOptions): Promise<void> {\n  await writer.writeV(buffers, options)\n}\n\n/**\n * Read a length-prefixed buffer from the passed stream, stripping the final newline character\n */\nexport async function read (reader: LengthPrefixedStream<Duplex<AsyncGenerator<Uint8Array | Uint8ArrayList>, Source<Uint8Array>>>, options: AbortOptions & LoggerOptions): Promise<Uint8ArrayList> {\n  const buf = await reader.read(options)\n\n  if (buf.byteLength === 0 || buf.get(buf.byteLength - 1) !== NewLine[0]) {\n    options.log.error('Invalid mss message - missing newline', buf)\n    throw new CodeError('missing newline', 'ERR_INVALID_MULTISTREAM_SELECT_MESSAGE')\n  }\n\n  return buf.sublist(0, -1) // Remove newline\n}\n\n/**\n * Read a length-prefixed string from the passed stream, stripping the final newline character\n */\nexport async function readString (reader: LengthPrefixedStream<Duplex<AsyncGenerator<Uint8Array | Uint8ArrayList>, Source<Uint8Array>>>, options: AbortOptions & LoggerOptions): Promise<string> {\n  const buf = await read(reader, options)\n\n  return uint8ArrayToString(buf.subarray())\n}\n", "import { CodeError } from '@libp2p/interface'\nimport { lpStream } from 'it-length-prefixed-stream'\nimport pDefer from 'p-defer'\nimport { raceSignal } from 'race-signal'\nimport * as varint from 'uint8-varint'\nimport { Uint8ArrayList } from 'uint8arraylist'\nimport { fromString as uint8ArrayFromString } from 'uint8arrays/from-string'\nimport { MAX_PROTOCOL_LENGTH } from './constants.js'\nimport * as multistream from './multistream.js'\nimport { PROTOCOL_ID } from './index.js'\nimport type { MultistreamSelectInit, ProtocolStream } from './index.js'\nimport type { AbortOptions } from '@libp2p/interface'\nimport type { Duplex } from 'it-stream-types'\n\nexport interface SelectStream extends Duplex<any, any, any> {\n  readStatus?: string\n  closeWrite?(options?: AbortOptions): Promise<void>\n  closeRead?(options?: AbortOptions): Promise<void>\n  close?(options?: AbortOptions): Promise<void>\n}\n\n/**\n * Negotiate a protocol to use from a list of protocols.\n *\n * @param stream - A duplex iterable stream to dial on\n * @param protocols - A list of protocols (or single protocol) to negotiate with. Protocols are attempted in order until a match is made.\n * @param options - An options object containing an AbortSignal and an optional boolean `writeBytes` - if this is true, `Uint8Array`s will be written into `duplex`, otherwise `Uint8ArrayList`s will\n * @returns A stream for the selected protocol and the protocol that was selected from the list of protocols provided to `select`.\n * @example\n *\n * ```TypeScript\n * import { pipe } from 'it-pipe'\n * import * as mss from '@libp2p/multistream-select'\n * import { Mplex } from '@libp2p/mplex'\n *\n * const muxer = new Mplex()\n * const muxedStream = muxer.newStream()\n *\n * // mss.select(protocol(s))\n * // Select from one of the passed protocols (in priority order)\n * // Returns selected stream and protocol\n * const { stream: dhtStream, protocol } = await mss.select(muxedStream, [\n *   // This might just be different versions of DHT, but could be different impls\n *   '/ipfs-dht/2.0.0', // Most of the time this will probably just be one item.\n *   '/ipfs-dht/1.0.0'\n * ])\n *\n * // Typically this stream will be passed back to the caller of libp2p.dialProtocol\n * //\n * // ...it might then do something like this:\n * // try {\n * //   await pipe(\n * //     [uint8ArrayFromString('Some DHT data')]\n * //     dhtStream,\n * //     async source => {\n * //       for await (const chunk of source)\n * //         // DHT response data\n * //     }\n * //   )\n * // } catch (err) {\n * //   // Error in stream\n * // }\n * ```\n */\nexport async function select <Stream extends SelectStream> (stream: Stream, protocols: string | string[], options: MultistreamSelectInit): Promise<ProtocolStream<Stream>> {\n  protocols = Array.isArray(protocols) ? [...protocols] : [protocols]\n\n  if (protocols.length === 1 && options.negotiateFully === false) {\n    return optimisticSelect(stream, protocols[0], options)\n  }\n\n  const lp = lpStream(stream, {\n    ...options,\n    maxDataLength: MAX_PROTOCOL_LENGTH\n  })\n  const protocol = protocols.shift()\n\n  if (protocol == null) {\n    throw new Error('At least one protocol must be specified')\n  }\n\n  options.log.trace('select: write [\"%s\", \"%s\"]', PROTOCOL_ID, protocol)\n  const p1 = uint8ArrayFromString(`${PROTOCOL_ID}\\n`)\n  const p2 = uint8ArrayFromString(`${protocol}\\n`)\n  await multistream.writeAll(lp, [p1, p2], options)\n\n  options.log.trace('select: reading multistream-select header')\n  let response = await multistream.readString(lp, options)\n  options.log.trace('select: read \"%s\"', response)\n\n  // Read the protocol response if we got the protocolId in return\n  if (response === PROTOCOL_ID) {\n    options.log.trace('select: reading protocol response')\n    response = await multistream.readString(lp, options)\n    options.log.trace('select: read \"%s\"', response)\n  }\n\n  // We're done\n  if (response === protocol) {\n    return { stream: lp.unwrap(), protocol }\n  }\n\n  // We haven't gotten a valid ack, try the other protocols\n  for (const protocol of protocols) {\n    options.log.trace('select: write \"%s\"', protocol)\n    await multistream.write(lp, uint8ArrayFromString(`${protocol}\\n`), options)\n    options.log.trace('select: reading protocol response')\n    const response = await multistream.readString(lp, options)\n    options.log.trace('select: read \"%s\" for \"%s\"', response, protocol)\n\n    if (response === protocol) {\n      return { stream: lp.unwrap(), protocol }\n    }\n  }\n\n  throw new CodeError('protocol selection failed', 'ERR_UNSUPPORTED_PROTOCOL')\n}\n\n/**\n * Optimistically negotiates a protocol.\n *\n * It *does not* block writes waiting for the other end to respond. Instead, it\n * simply assumes the negotiation went successfully and starts writing data.\n *\n * Use when it is known that the receiver supports the desired protocol.\n */\nfunction optimisticSelect <Stream extends SelectStream> (stream: Stream, protocol: string, options: MultistreamSelectInit): ProtocolStream<Stream> {\n  const originalSink = stream.sink.bind(stream)\n  const originalSource = stream.source\n\n  let negotiated = false\n  let negotiating = false\n  const doneNegotiating = pDefer()\n\n  let sentProtocol = false\n  let sendingProtocol = false\n  const doneSendingProtocol = pDefer()\n\n  let readProtocol = false\n  let readingProtocol = false\n  const doneReadingProtocol = pDefer()\n\n  const lp = lpStream({\n    sink: originalSink,\n    source: originalSource\n  }, {\n    ...options,\n    maxDataLength: MAX_PROTOCOL_LENGTH\n  })\n\n  stream.sink = async source => {\n    const { sink } = lp.unwrap()\n\n    await sink(async function * () {\n      let sentData = false\n\n      for await (const buf of source) {\n        // started reading before the source yielded, wait for protocol send\n        if (sendingProtocol) {\n          await doneSendingProtocol.promise\n        }\n\n        // writing before reading, send the protocol and the first chunk of data\n        if (!sentProtocol) {\n          sendingProtocol = true\n\n          options.log.trace('optimistic: write [\"%s\", \"%s\", data(%d)] in sink', PROTOCOL_ID, protocol, buf.byteLength)\n\n          const protocolString = `${protocol}\\n`\n\n          // send protocols in first chunk of data written to transport\n          yield new Uint8ArrayList(\n            Uint8Array.from([19]), // length of PROTOCOL_ID plus newline\n            uint8ArrayFromString(`${PROTOCOL_ID}\\n`),\n            varint.encode(protocolString.length),\n            uint8ArrayFromString(protocolString),\n            buf\n          ).subarray()\n\n          options.log.trace('optimistic: wrote [\"%s\", \"%s\", data(%d)] in sink', PROTOCOL_ID, protocol, buf.byteLength)\n\n          sentProtocol = true\n          sendingProtocol = false\n          doneSendingProtocol.resolve()\n\n          // read the negotiation response but don't block more sending\n          negotiate()\n            .catch(err => {\n              options.log.error('could not finish optimistic protocol negotiation of %s', protocol, err)\n            })\n        } else {\n          yield buf\n        }\n\n        sentData = true\n      }\n\n      // special case - the source passed to the sink has ended but we didn't\n      // negotiated the protocol yet so do it now\n      if (!sentData) {\n        await negotiate()\n      }\n    }())\n  }\n\n  async function negotiate (): Promise<void> {\n    if (negotiating) {\n      options.log.trace('optimistic: already negotiating %s stream', protocol)\n      await doneNegotiating.promise\n      return\n    }\n\n    negotiating = true\n\n    try {\n      // we haven't sent the protocol yet, send it now\n      if (!sentProtocol) {\n        options.log.trace('optimistic: doing send protocol for %s stream', protocol)\n        await doSendProtocol()\n      }\n\n      // if we haven't read the protocol response yet, do it now\n      if (!readProtocol) {\n        options.log.trace('optimistic: doing read protocol for %s stream', protocol)\n        await doReadProtocol()\n      }\n    } finally {\n      negotiating = false\n      negotiated = true\n      doneNegotiating.resolve()\n    }\n  }\n\n  async function doSendProtocol (): Promise<void> {\n    if (sendingProtocol) {\n      await doneSendingProtocol.promise\n      return\n    }\n\n    sendingProtocol = true\n\n    try {\n      options.log.trace('optimistic: write [\"%s\", \"%s\", data] in source', PROTOCOL_ID, protocol)\n      await lp.writeV([\n        uint8ArrayFromString(`${PROTOCOL_ID}\\n`),\n        uint8ArrayFromString(`${protocol}\\n`)\n      ])\n      options.log.trace('optimistic: wrote [\"%s\", \"%s\", data] in source', PROTOCOL_ID, protocol)\n    } finally {\n      sentProtocol = true\n      sendingProtocol = false\n      doneSendingProtocol.resolve()\n    }\n  }\n\n  async function doReadProtocol (): Promise<void> {\n    if (readingProtocol) {\n      await doneReadingProtocol.promise\n      return\n    }\n\n    readingProtocol = true\n\n    try {\n      options.log.trace('optimistic: reading multistream select header')\n      let response = await multistream.readString(lp, options)\n      options.log.trace('optimistic: read multistream select header \"%s\"', response)\n\n      if (response === PROTOCOL_ID) {\n        response = await multistream.readString(lp, options)\n      }\n\n      options.log.trace('optimistic: read protocol \"%s\", expecting \"%s\"', response, protocol)\n\n      if (response !== protocol) {\n        throw new CodeError('protocol selection failed', 'ERR_UNSUPPORTED_PROTOCOL')\n      }\n    } finally {\n      readProtocol = true\n      readingProtocol = false\n      doneReadingProtocol.resolve()\n    }\n  }\n\n  stream.source = (async function * () {\n    // make sure we've done protocol negotiation before we read stream data\n    await negotiate()\n\n    options.log.trace('optimistic: reading data from \"%s\" stream', protocol)\n    yield * lp.unwrap().source\n  })()\n\n  if (stream.closeRead != null) {\n    const originalCloseRead = stream.closeRead.bind(stream)\n\n    stream.closeRead = async (opts) => {\n      // we need to read & write to negotiate the protocol so ensure we've done\n      // this before closing the readable end of the stream\n      if (!negotiated) {\n        await negotiate().catch(err => {\n          options.log.error('could not negotiate protocol before close read', err)\n        })\n      }\n\n      // protocol has been negotiated, ok to close the readable end\n      await originalCloseRead(opts)\n    }\n  }\n\n  if (stream.closeWrite != null) {\n    const originalCloseWrite = stream.closeWrite.bind(stream)\n\n    stream.closeWrite = async (opts) => {\n      // we need to read & write to negotiate the protocol so ensure we've done\n      // this before closing the writable end of the stream\n      if (!negotiated) {\n        await negotiate().catch(err => {\n          options.log.error('could not negotiate protocol before close write', err)\n        })\n      }\n\n      // protocol has been negotiated, ok to close the writable end\n      await originalCloseWrite(opts)\n    }\n  }\n\n  if (stream.close != null) {\n    const originalClose = stream.close.bind(stream)\n\n    stream.close = async (opts) => {\n      // if we are in the process of negotiation, let it finish before closing\n      // because we may have unsent early data\n      const tasks = []\n\n      if (sendingProtocol) {\n        tasks.push(doneSendingProtocol.promise)\n      }\n\n      if (readingProtocol) {\n        tasks.push(doneReadingProtocol.promise)\n      }\n\n      if (tasks.length > 0) {\n        // let the in-flight protocol negotiation finish gracefully\n        await raceSignal(\n          Promise.all(tasks),\n          opts?.signal\n        )\n      } else {\n        // no protocol negotiation attempt has occurred so don't start one\n        negotiated = true\n        negotiating = false\n        doneNegotiating.resolve()\n      }\n\n      // protocol has been negotiated, ok to close the writable end\n      await originalClose(opts)\n    }\n  }\n\n  return {\n    stream,\n    protocol\n  }\n}\n", "import { encode } from 'it-length-prefixed'\nimport { lpStream } from 'it-length-prefixed-stream'\nimport { Uint8ArrayList } from 'uint8arraylist'\nimport { fromString as uint8ArrayFromString } from 'uint8arrays/from-string'\nimport { MAX_PROTOCOL_LENGTH, PROTOCOL_ID } from './constants.js'\nimport * as multistream from './multistream.js'\nimport type { MultistreamSelectInit, ProtocolStream } from './index.js'\nimport type { Duplex } from 'it-stream-types'\n\n/**\n * Handle multistream protocol selections for the given list of protocols.\n *\n * Note that after a protocol is handled `listener` can no longer be used.\n *\n * @param stream - A duplex iterable stream to listen on\n * @param protocols - A list of protocols (or single protocol) that this listener is able to speak.\n * @param options - an options object containing an AbortSignal and an optional boolean `writeBytes` - if this is true, `Uint8Array`s will be written into `duplex`, otherwise `Uint8ArrayList`s will\n * @returns A stream for the selected protocol and the protocol that was selected from the list of protocols provided to `select`\n * @example\n *\n * ```TypeScript\n * import { pipe } from 'it-pipe'\n * import * as mss from '@libp2p/multistream-select'\n * import { Mplex } from '@libp2p/mplex'\n *\n * const muxer = new Mplex({\n *   async onStream (muxedStream) {\n *   // mss.handle(handledProtocols)\n *   // Returns selected stream and protocol\n *   const { stream, protocol } = await mss.handle(muxedStream, [\n *     '/ipfs-dht/1.0.0',\n *     '/ipfs-bitswap/1.0.0'\n *   ])\n *\n *   // Typically here we'd call the handler function that was registered in\n *   // libp2p for the given protocol:\n *   // e.g. handlers[protocol].handler(stream)\n *   //\n *   // If protocol was /ipfs-dht/1.0.0 it might do something like this:\n *   // try {\n *   //   await pipe(\n *   //     dhtStream,\n *   //     source => (async function * () {\n *   //       for await (const chunk of source)\n *   //         // Incoming DHT data -> process and yield to respond\n *   //     })(),\n *   //     dhtStream\n *   //   )\n *   // } catch (err) {\n *   //   // Error in stream\n *   // }\n *   }\n * })\n * ```\n */\nexport async function handle <Stream extends Duplex<any, any, any>> (stream: Stream, protocols: string | string[], options: MultistreamSelectInit): Promise<ProtocolStream<Stream>> {\n  protocols = Array.isArray(protocols) ? protocols : [protocols]\n  options.log.trace('handle: available protocols %s', protocols)\n\n  const lp = lpStream(stream, {\n    ...options,\n    maxDataLength: MAX_PROTOCOL_LENGTH,\n    maxLengthLength: 2 // 2 bytes is enough to length-prefix MAX_PROTOCOL_LENGTH\n  })\n\n  while (true) {\n    options.log.trace('handle: reading incoming string')\n    const protocol = await multistream.readString(lp, options)\n    options.log.trace('handle: read \"%s\"', protocol)\n\n    if (protocol === PROTOCOL_ID) {\n      options.log.trace('handle: respond with \"%s\" for \"%s\"', PROTOCOL_ID, protocol)\n      await multistream.write(lp, uint8ArrayFromString(`${PROTOCOL_ID}\\n`), options)\n      options.log.trace('handle: responded with \"%s\" for \"%s\"', PROTOCOL_ID, protocol)\n      continue\n    }\n\n    if (protocols.includes(protocol)) {\n      options.log.trace('handle: respond with \"%s\" for \"%s\"', protocol, protocol)\n      await multistream.write(lp, uint8ArrayFromString(`${protocol}\\n`), options)\n      options.log.trace('handle: responded with \"%s\" for \"%s\"', protocol, protocol)\n\n      return { stream: lp.unwrap(), protocol }\n    }\n\n    if (protocol === 'ls') {\n      // <varint-msg-len><varint-proto-name-len><proto-name>\\n<varint-proto-name-len><proto-name>\\n\\n\n      const protos = new Uint8ArrayList(\n        ...protocols.map(p => encode.single(uint8ArrayFromString(`${p}\\n`))),\n        uint8ArrayFromString('\\n')\n      )\n\n      options.log.trace('handle: respond with \"%s\" for %s', protocols, protocol)\n      await multistream.write(lp, protos, options)\n      options.log.trace('handle: responded with \"%s\" for %s', protocols, protocol)\n      continue\n    }\n\n    options.log('handle: respond with \"na\" for \"%s\"', protocol)\n    await multistream.write(lp, uint8ArrayFromString('na\\n'), options)\n    options.log('handle: responded with \"na\" for \"%s\"', protocol)\n  }\n}\n", "import { connectionSymbol, CodeError, setMaxListeners } from '@libp2p/interface'\nimport type { AbortOptions, Logger, ComponentLogger, Direction, Connection, Stream, ConnectionTimeline, ConnectionStatus, NewStreamOptions, PeerId } from '@libp2p/interface'\nimport type { Multiaddr } from '@multiformats/multiaddr'\n\nconst CLOSE_TIMEOUT = 500\n\ninterface ConnectionInit {\n  remoteAddr: Multiaddr\n  remotePeer: PeerId\n  newStream(protocols: string[], options?: AbortOptions): Promise<Stream>\n  close(options?: AbortOptions): Promise<void>\n  abort(err: Error): void\n  getStreams(): Stream[]\n  status: ConnectionStatus\n  direction: Direction\n  timeline: ConnectionTimeline\n  multiplexer?: string\n  encryption?: string\n  transient?: boolean\n  logger: ComponentLogger\n}\n\n/**\n * An implementation of the js-libp2p connection.\n * Any libp2p transport should use an upgrader to return this connection.\n */\nexport class ConnectionImpl implements Connection {\n  /**\n   * Connection identifier.\n   */\n  public readonly id: string\n\n  /**\n   * Observed multiaddr of the remote peer\n   */\n  public readonly remoteAddr: Multiaddr\n\n  /**\n   * Remote peer id\n   */\n  public readonly remotePeer: PeerId\n\n  public direction: Direction\n  public timeline: ConnectionTimeline\n  public multiplexer?: string\n  public encryption?: string\n  public status: ConnectionStatus\n  public transient: boolean\n  public readonly log: Logger\n\n  /**\n   * User provided tags\n   *\n   */\n  public tags: string[]\n\n  /**\n   * Reference to the new stream function of the multiplexer\n   */\n  private readonly _newStream: (protocols: string[], options?: NewStreamOptions) => Promise<Stream>\n\n  /**\n   * Reference to the close function of the raw connection\n   */\n  private readonly _close: (options?: AbortOptions) => Promise<void>\n\n  private readonly _abort: (err: Error) => void\n\n  /**\n   * Reference to the getStreams function of the muxer\n   */\n  private readonly _getStreams: () => Stream[]\n\n  /**\n   * An implementation of the js-libp2p connection.\n   * Any libp2p transport should use an upgrader to return this connection.\n   */\n  constructor (init: ConnectionInit) {\n    const { remoteAddr, remotePeer, newStream, close, abort, getStreams } = init\n\n    this.id = `${(parseInt(String(Math.random() * 1e9))).toString(36)}${Date.now()}`\n    this.remoteAddr = remoteAddr\n    this.remotePeer = remotePeer\n    this.direction = init.direction\n    this.status = 'open'\n    this.timeline = init.timeline\n    this.multiplexer = init.multiplexer\n    this.encryption = init.encryption\n    this.transient = init.transient ?? false\n    this.log = init.logger.forComponent(`libp2p:connection:${this.direction}:${this.id}`)\n\n    if (this.remoteAddr.getPeerId() == null) {\n      this.remoteAddr = this.remoteAddr.encapsulate(`/p2p/${this.remotePeer}`)\n    }\n\n    this._newStream = newStream\n    this._close = close\n    this._abort = abort\n    this._getStreams = getStreams\n    this.tags = []\n  }\n\n  readonly [Symbol.toStringTag] = 'Connection'\n\n  readonly [connectionSymbol] = true\n\n  /**\n   * Get all the streams of the muxer\n   */\n  get streams (): Stream[] {\n    return this._getStreams()\n  }\n\n  /**\n   * Create a new stream from this connection\n   */\n  async newStream (protocols: string | string[], options?: NewStreamOptions): Promise<Stream> {\n    if (this.status === 'closing') {\n      throw new CodeError('the connection is being closed', 'ERR_CONNECTION_BEING_CLOSED')\n    }\n\n    if (this.status === 'closed') {\n      throw new CodeError('the connection is closed', 'ERR_CONNECTION_CLOSED')\n    }\n\n    if (!Array.isArray(protocols)) {\n      protocols = [protocols]\n    }\n\n    if (this.transient && options?.runOnTransientConnection !== true) {\n      throw new CodeError('Cannot open protocol stream on transient connection', 'ERR_TRANSIENT_CONNECTION')\n    }\n\n    const stream = await this._newStream(protocols, options)\n\n    stream.direction = 'outbound'\n\n    return stream\n  }\n\n  /**\n   * Close the connection\n   */\n  async close (options: AbortOptions = {}): Promise<void> {\n    if (this.status === 'closed' || this.status === 'closing') {\n      return\n    }\n\n    this.log('closing connection to %a', this.remoteAddr)\n\n    this.status = 'closing'\n\n    if (options.signal == null) {\n      const signal = AbortSignal.timeout(CLOSE_TIMEOUT)\n      setMaxListeners(Infinity, signal)\n\n      options = {\n        ...options,\n        signal\n      }\n    }\n\n    try {\n      this.log.trace('closing all streams')\n\n      // close all streams gracefully - this can throw if we're not multiplexed\n      await Promise.all(\n        this.streams.map(async s => s.close(options))\n      )\n\n      this.log.trace('closing underlying transport')\n\n      // close raw connection\n      await this._close(options)\n\n      this.log.trace('updating timeline with close time')\n\n      this.status = 'closed'\n      this.timeline.close = Date.now()\n    } catch (err: any) {\n      this.log.error('error encountered during graceful close of connection to %a', this.remoteAddr, err)\n      this.abort(err)\n    }\n  }\n\n  abort (err: Error): void {\n    this.log.error('aborting connection to %a due to error', this.remoteAddr, err)\n\n    this.status = 'closing'\n    this.streams.forEach(s => { s.abort(err) })\n\n    this.log.error('all streams aborted', this.streams.length)\n\n    // Abort raw connection\n    this._abort(err)\n\n    this.timeline.close = Date.now()\n    this.status = 'closed'\n  }\n}\n\nexport function createConnection (init: ConnectionInit): Connection {\n  return new ConnectionImpl(init)\n}\n", "import { CodeError, ERR_TIMEOUT, setMaxListeners } from '@libp2p/interface'\nimport * as mss from '@libp2p/multistream-select'\nimport { peerIdFromString } from '@libp2p/peer-id'\nimport { createConnection } from './connection/index.js'\nimport { INBOUND_UPGRADE_TIMEOUT } from './connection-manager/constants.js'\nimport { codes } from './errors.js'\nimport { DEFAULT_MAX_INBOUND_STREAMS, DEFAULT_MAX_OUTBOUND_STREAMS } from './registrar.js'\nimport type { Libp2pEvents, AbortOptions, ComponentLogger, MultiaddrConnection, Connection, Stream, ConnectionProtector, NewStreamOptions, ConnectionEncrypter, SecuredConnection, ConnectionGater, TypedEventTarget, Metrics, PeerId, PeerStore, StreamMuxer, StreamMuxerFactory, Upgrader, UpgraderOptions } from '@libp2p/interface'\nimport type { ConnectionManager, Registrar } from '@libp2p/interface-internal'\n\nconst DEFAULT_PROTOCOL_SELECT_TIMEOUT = 30000\n\ninterface CreateConnectionOptions {\n  cryptoProtocol: string\n  direction: 'inbound' | 'outbound'\n  maConn: MultiaddrConnection\n  upgradedConn: MultiaddrConnection\n  remotePeer: PeerId\n  muxerFactory?: StreamMuxerFactory\n  transient?: boolean\n}\n\ninterface OnStreamOptions {\n  connection: Connection\n  stream: Stream\n  protocol: string\n}\n\nexport interface CryptoResult extends SecuredConnection<MultiaddrConnection> {\n  protocol: string\n}\n\nexport interface UpgraderInit {\n  connectionEncryption: ConnectionEncrypter[]\n  muxers: StreamMuxerFactory[]\n\n  /**\n   * An amount of ms by which an inbound connection upgrade\n   * must complete\n   */\n  inboundUpgradeTimeout?: number\n}\n\nfunction findIncomingStreamLimit (protocol: string, registrar: Registrar): number | undefined {\n  try {\n    const { options } = registrar.getHandler(protocol)\n\n    return options.maxInboundStreams\n  } catch (err: any) {\n    if (err.code !== codes.ERR_NO_HANDLER_FOR_PROTOCOL) {\n      throw err\n    }\n  }\n\n  return DEFAULT_MAX_INBOUND_STREAMS\n}\n\nfunction findOutgoingStreamLimit (protocol: string, registrar: Registrar, options: NewStreamOptions = {}): number {\n  try {\n    const { options } = registrar.getHandler(protocol)\n\n    if (options.maxOutboundStreams != null) {\n      return options.maxOutboundStreams\n    }\n  } catch (err: any) {\n    if (err.code !== codes.ERR_NO_HANDLER_FOR_PROTOCOL) {\n      throw err\n    }\n  }\n\n  return options.maxOutboundStreams ?? DEFAULT_MAX_OUTBOUND_STREAMS\n}\n\nfunction countStreams (protocol: string, direction: 'inbound' | 'outbound', connection: Connection): number {\n  let streamCount = 0\n\n  connection.streams.forEach(stream => {\n    if (stream.direction === direction && stream.protocol === protocol) {\n      streamCount++\n    }\n  })\n\n  return streamCount\n}\n\nexport interface DefaultUpgraderComponents {\n  peerId: PeerId\n  metrics?: Metrics\n  connectionManager: ConnectionManager\n  connectionGater: ConnectionGater\n  connectionProtector?: ConnectionProtector\n  registrar: Registrar\n  peerStore: PeerStore\n  events: TypedEventTarget<Libp2pEvents>\n  logger: ComponentLogger\n}\n\ntype ConnectionDeniedType = keyof Pick<ConnectionGater, 'denyOutboundConnection' | 'denyInboundEncryptedConnection' | 'denyOutboundEncryptedConnection' | 'denyInboundUpgradedConnection' | 'denyOutboundUpgradedConnection'>\n\nexport class DefaultUpgrader implements Upgrader {\n  private readonly components: DefaultUpgraderComponents\n  private readonly connectionEncryption: Map<string, ConnectionEncrypter>\n  private readonly muxers: Map<string, StreamMuxerFactory>\n  private readonly inboundUpgradeTimeout: number\n  private readonly events: TypedEventTarget<Libp2pEvents>\n\n  constructor (components: DefaultUpgraderComponents, init: UpgraderInit) {\n    this.components = components\n    this.connectionEncryption = new Map()\n\n    init.connectionEncryption.forEach(encrypter => {\n      this.connectionEncryption.set(encrypter.protocol, encrypter)\n    })\n\n    this.muxers = new Map()\n\n    init.muxers.forEach(muxer => {\n      this.muxers.set(muxer.protocol, muxer)\n    })\n\n    this.inboundUpgradeTimeout = init.inboundUpgradeTimeout ?? INBOUND_UPGRADE_TIMEOUT\n    this.events = components.events\n  }\n\n  async shouldBlockConnection (remotePeer: PeerId, maConn: MultiaddrConnection, connectionType: ConnectionDeniedType): Promise<void> {\n    const connectionGater = this.components.connectionGater[connectionType]\n\n    if (connectionGater !== undefined) {\n      if (await connectionGater(remotePeer, maConn)) {\n        throw new CodeError(`The multiaddr connection is blocked by gater.${connectionType}`, codes.ERR_CONNECTION_INTERCEPTED)\n      }\n    }\n  }\n\n  /**\n   * Upgrades an inbound connection\n   */\n  async upgradeInbound (maConn: MultiaddrConnection, opts?: UpgraderOptions): Promise<Connection> {\n    const accept = await this.components.connectionManager.acceptIncomingConnection(maConn)\n\n    if (!accept) {\n      throw new CodeError('connection denied', codes.ERR_CONNECTION_DENIED)\n    }\n\n    let encryptedConn: MultiaddrConnection\n    let remotePeer\n    let upgradedConn: MultiaddrConnection\n    let muxerFactory: StreamMuxerFactory | undefined\n    let cryptoProtocol\n\n    const signal = AbortSignal.timeout(this.inboundUpgradeTimeout)\n\n    const onAbort = (): void => {\n      maConn.abort(new CodeError('inbound upgrade timeout', ERR_TIMEOUT))\n    }\n\n    signal.addEventListener('abort', onAbort, { once: true })\n\n    setMaxListeners(Infinity, signal)\n\n    try {\n      if ((await this.components.connectionGater.denyInboundConnection?.(maConn)) === true) {\n        throw new CodeError('The multiaddr connection is blocked by gater.acceptConnection', codes.ERR_CONNECTION_INTERCEPTED)\n      }\n\n      this.components.metrics?.trackMultiaddrConnection(maConn)\n\n      maConn.log('starting the inbound connection upgrade')\n\n      // Protect\n      let protectedConn = maConn\n\n      if (opts?.skipProtection !== true) {\n        const protector = this.components.connectionProtector\n\n        if (protector != null) {\n          maConn.log('protecting the inbound connection')\n          protectedConn = await protector.protect(maConn)\n        }\n      }\n\n      try {\n        // Encrypt the connection\n        encryptedConn = protectedConn\n        if (opts?.skipEncryption !== true) {\n          ({\n            conn: encryptedConn,\n            remotePeer,\n            protocol: cryptoProtocol\n          } = await this._encryptInbound(protectedConn))\n\n          const maConn: MultiaddrConnection = {\n            ...protectedConn,\n            ...encryptedConn\n          }\n\n          await this.shouldBlockConnection(remotePeer, maConn, 'denyInboundEncryptedConnection')\n        } else {\n          const idStr = maConn.remoteAddr.getPeerId()\n\n          if (idStr == null) {\n            throw new CodeError('inbound connection that skipped encryption must have a peer id', codes.ERR_INVALID_MULTIADDR)\n          }\n\n          const remotePeerId = peerIdFromString(idStr)\n\n          cryptoProtocol = 'native'\n          remotePeer = remotePeerId\n        }\n\n        upgradedConn = encryptedConn\n        if (opts?.muxerFactory != null) {\n          muxerFactory = opts.muxerFactory\n        } else if (this.muxers.size > 0) {\n          // Multiplex the connection\n          const multiplexed = await this._multiplexInbound({\n            ...protectedConn,\n            ...encryptedConn\n          }, this.muxers)\n          muxerFactory = multiplexed.muxerFactory\n          upgradedConn = multiplexed.stream\n        }\n      } catch (err: any) {\n        maConn.log.error('failed to upgrade inbound connection', err)\n        throw err\n      }\n\n      await this.shouldBlockConnection(remotePeer, maConn, 'denyInboundUpgradedConnection')\n\n      maConn.log('successfully upgraded inbound connection')\n\n      return this._createConnection({\n        cryptoProtocol,\n        direction: 'inbound',\n        maConn,\n        upgradedConn,\n        muxerFactory,\n        remotePeer,\n        transient: opts?.transient\n      })\n    } finally {\n      signal.removeEventListener('abort', onAbort)\n\n      this.components.connectionManager.afterUpgradeInbound()\n    }\n  }\n\n  /**\n   * Upgrades an outbound connection\n   */\n  async upgradeOutbound (maConn: MultiaddrConnection, opts?: UpgraderOptions): Promise<Connection> {\n    const idStr = maConn.remoteAddr.getPeerId()\n    let remotePeerId: PeerId | undefined\n\n    if (idStr != null) {\n      remotePeerId = peerIdFromString(idStr)\n\n      await this.shouldBlockConnection(remotePeerId, maConn, 'denyOutboundConnection')\n    }\n\n    let encryptedConn: MultiaddrConnection\n    let remotePeer: PeerId\n    let upgradedConn: MultiaddrConnection\n    let cryptoProtocol\n    let muxerFactory\n\n    this.components.metrics?.trackMultiaddrConnection(maConn)\n\n    maConn.log('starting the outbound connection upgrade')\n\n    // If the transport natively supports encryption, skip connection\n    // protector and encryption\n\n    // Protect\n    let protectedConn = maConn\n    if (opts?.skipProtection !== true) {\n      const protector = this.components.connectionProtector\n\n      if (protector != null) {\n        protectedConn = await protector.protect(maConn)\n      }\n    }\n\n    try {\n      // Encrypt the connection\n      encryptedConn = protectedConn\n      if (opts?.skipEncryption !== true) {\n        ({\n          conn: encryptedConn,\n          remotePeer,\n          protocol: cryptoProtocol\n        } = await this._encryptOutbound(protectedConn, remotePeerId))\n\n        const maConn: MultiaddrConnection = {\n          ...protectedConn,\n          ...encryptedConn\n        }\n\n        await this.shouldBlockConnection(remotePeer, maConn, 'denyOutboundEncryptedConnection')\n      } else {\n        if (remotePeerId == null) {\n          throw new CodeError('Encryption was skipped but no peer id was passed', codes.ERR_INVALID_PEER)\n        }\n\n        cryptoProtocol = 'native'\n        remotePeer = remotePeerId\n      }\n\n      upgradedConn = encryptedConn\n      if (opts?.muxerFactory != null) {\n        muxerFactory = opts.muxerFactory\n      } else if (this.muxers.size > 0) {\n        // Multiplex the connection\n        const multiplexed = await this._multiplexOutbound({\n          ...protectedConn,\n          ...encryptedConn\n        }, this.muxers)\n        muxerFactory = multiplexed.muxerFactory\n        upgradedConn = multiplexed.stream\n      }\n    } catch (err: any) {\n      maConn.log.error('failed to upgrade outbound connection', err)\n      await maConn.close(err)\n      throw err\n    }\n\n    await this.shouldBlockConnection(remotePeer, maConn, 'denyOutboundUpgradedConnection')\n\n    maConn.log('successfully upgraded outbound connection')\n\n    return this._createConnection({\n      cryptoProtocol,\n      direction: 'outbound',\n      maConn,\n      upgradedConn,\n      muxerFactory,\n      remotePeer,\n      transient: opts?.transient\n    })\n  }\n\n  /**\n   * A convenience method for generating a new `Connection`\n   */\n  _createConnection (opts: CreateConnectionOptions): Connection {\n    const {\n      cryptoProtocol,\n      direction,\n      maConn,\n      upgradedConn,\n      remotePeer,\n      muxerFactory,\n      transient\n    } = opts\n\n    let muxer: StreamMuxer | undefined\n    let newStream: ((multicodecs: string[], options?: AbortOptions) => Promise<Stream>) | undefined\n    let connection: Connection // eslint-disable-line prefer-const\n\n    if (muxerFactory != null) {\n      // Create the muxer\n      muxer = muxerFactory.createStreamMuxer({\n        direction,\n        // Run anytime a remote stream is created\n        onIncomingStream: muxedStream => {\n          if (connection == null) {\n            return\n          }\n\n          void Promise.resolve()\n            .then(async () => {\n              const protocols = this.components.registrar.getProtocols()\n              const { stream, protocol } = await mss.handle(muxedStream, protocols, {\n                log: muxedStream.log,\n                yieldBytes: false\n              })\n\n              if (connection == null) {\n                return\n              }\n\n              connection.log('incoming stream opened on %s', protocol)\n\n              const incomingLimit = findIncomingStreamLimit(protocol, this.components.registrar)\n              const streamCount = countStreams(protocol, 'inbound', connection)\n\n              if (streamCount === incomingLimit) {\n                const err = new CodeError(`Too many inbound protocol streams for protocol \"${protocol}\" - limit ${incomingLimit}`, codes.ERR_TOO_MANY_INBOUND_PROTOCOL_STREAMS)\n                muxedStream.abort(err)\n\n                throw err\n              }\n\n              // after the handshake the returned stream can have early data so override\n              // the souce/sink\n              muxedStream.source = stream.source\n              muxedStream.sink = stream.sink\n              muxedStream.protocol = protocol\n\n              // allow closing the write end of a not-yet-negotiated stream\n              if (stream.closeWrite != null) {\n                muxedStream.closeWrite = stream.closeWrite\n              }\n\n              // allow closing the read end of a not-yet-negotiated stream\n              if (stream.closeRead != null) {\n                muxedStream.closeRead = stream.closeRead\n              }\n\n              // make sure we don't try to negotiate a stream we are closing\n              if (stream.close != null) {\n                muxedStream.close = stream.close\n              }\n\n              // If a protocol stream has been successfully negotiated and is to be passed to the application,\n              // the peerstore should ensure that the peer is registered with that protocol\n              await this.components.peerStore.merge(remotePeer, {\n                protocols: [protocol]\n              })\n\n              this.components.metrics?.trackProtocolStream(muxedStream, connection)\n\n              this._onStream({ connection, stream: muxedStream, protocol })\n            })\n            .catch(async err => {\n              connection.log.error('error handling incoming stream id %s', muxedStream.id, err.message, err.code, err.stack)\n\n              if (muxedStream.timeline.close == null) {\n                await muxedStream.close()\n              }\n            })\n        }\n      })\n\n      newStream = async (protocols: string[], options: NewStreamOptions = {}): Promise<Stream> => {\n        if (muxer == null) {\n          throw new CodeError('Stream is not multiplexed', codes.ERR_MUXER_UNAVAILABLE)\n        }\n\n        connection.log('starting new stream for protocols %s', protocols)\n        const muxedStream = await muxer.newStream()\n        connection.log.trace('started new stream %s for protocols %s', muxedStream.id, protocols)\n\n        try {\n          if (options.signal == null) {\n            muxedStream.log('no abort signal was passed while trying to negotiate protocols %s falling back to default timeout', protocols)\n\n            const signal = AbortSignal.timeout(DEFAULT_PROTOCOL_SELECT_TIMEOUT)\n            setMaxListeners(Infinity, signal)\n\n            options = {\n              ...options,\n              signal\n            }\n          }\n\n          muxedStream.log.trace('selecting protocol from protocols %s', protocols)\n\n          const {\n            stream,\n            protocol\n          } = await mss.select(muxedStream, protocols, {\n            ...options,\n            log: muxedStream.log,\n            yieldBytes: true\n          })\n\n          muxedStream.log('selected protocol %s', protocol)\n\n          const outgoingLimit = findOutgoingStreamLimit(protocol, this.components.registrar, options)\n          const streamCount = countStreams(protocol, 'outbound', connection)\n\n          if (streamCount >= outgoingLimit) {\n            const err = new CodeError(`Too many outbound protocol streams for protocol \"${protocol}\" - ${streamCount}/${outgoingLimit}`, codes.ERR_TOO_MANY_OUTBOUND_PROTOCOL_STREAMS)\n            muxedStream.abort(err)\n\n            throw err\n          }\n\n          // If a protocol stream has been successfully negotiated and is to be passed to the application,\n          // the peerstore should ensure that the peer is registered with that protocol\n          await this.components.peerStore.merge(remotePeer, {\n            protocols: [protocol]\n          })\n\n          // after the handshake the returned stream can have early data so override\n          // the souce/sink\n          muxedStream.source = stream.source\n          muxedStream.sink = stream.sink\n          muxedStream.protocol = protocol\n\n          // allow closing the write end of a not-yet-negotiated stream\n          if (stream.closeWrite != null) {\n            muxedStream.closeWrite = stream.closeWrite\n          }\n\n          // allow closing the read end of a not-yet-negotiated stream\n          if (stream.closeRead != null) {\n            muxedStream.closeRead = stream.closeRead\n          }\n\n          // make sure we don't try to negotiate a stream we are closing\n          if (stream.close != null) {\n            muxedStream.close = stream.close\n          }\n\n          this.components.metrics?.trackProtocolStream(muxedStream, connection)\n\n          return muxedStream\n        } catch (err: any) {\n          connection.log.error('could not create new stream for protocols %s', protocols, err)\n\n          if (muxedStream.timeline.close == null) {\n            muxedStream.abort(err)\n          }\n\n          if (err.code != null) {\n            throw err\n          }\n\n          throw new CodeError(String(err), codes.ERR_UNSUPPORTED_PROTOCOL)\n        }\n      }\n\n      // Pipe all data through the muxer\n      void Promise.all([\n        muxer.sink(upgradedConn.source),\n        upgradedConn.sink(muxer.source)\n      ]).catch(err => {\n        connection.log.error('error piping data through muxer', err)\n      })\n    }\n\n    const _timeline = maConn.timeline\n    maConn.timeline = new Proxy(_timeline, {\n      set: (...args) => {\n        if (connection != null && args[1] === 'close' && args[2] != null && _timeline.close == null) {\n          // Wait for close to finish before notifying of the closure\n          (async () => {\n            try {\n              if (connection.status === 'open') {\n                await connection.close()\n              }\n            } catch (err: any) {\n              connection.log.error('error closing connection after timeline close', err)\n            } finally {\n              this.events.safeDispatchEvent('connection:close', {\n                detail: connection\n              })\n            }\n          })().catch(err => {\n            connection.log.error('error thrown while dispatching connection:close event', err)\n          })\n        }\n\n        return Reflect.set(...args)\n      }\n    })\n    maConn.timeline.upgraded = Date.now()\n\n    const errConnectionNotMultiplexed = (): any => {\n      throw new CodeError('connection is not multiplexed', codes.ERR_CONNECTION_NOT_MULTIPLEXED)\n    }\n\n    // Create the connection\n    connection = createConnection({\n      remoteAddr: maConn.remoteAddr,\n      remotePeer,\n      status: 'open',\n      direction,\n      timeline: maConn.timeline,\n      multiplexer: muxer?.protocol,\n      encryption: cryptoProtocol,\n      transient,\n      logger: this.components.logger,\n      newStream: newStream ?? errConnectionNotMultiplexed,\n      getStreams: () => { if (muxer != null) { return muxer.streams } else { return [] } },\n      close: async (options?: AbortOptions) => {\n        // Ensure remaining streams are closed gracefully\n        if (muxer != null) {\n          connection.log.trace('close muxer')\n          await muxer.close(options)\n        }\n\n        connection.log.trace('close maconn')\n        // close the underlying transport\n        await maConn.close(options)\n        connection.log.trace('closed maconn')\n      },\n      abort: (err) => {\n        maConn.abort(err)\n        // Ensure remaining streams are aborted\n        if (muxer != null) {\n          muxer.abort(err)\n        }\n      }\n    })\n\n    this.events.safeDispatchEvent('connection:open', {\n      detail: connection\n    })\n\n    return connection\n  }\n\n  /**\n   * Routes incoming streams to the correct handler\n   */\n  _onStream (opts: OnStreamOptions): void {\n    const { connection, stream, protocol } = opts\n    const { handler, options } = this.components.registrar.getHandler(protocol)\n\n    if (connection.transient && options.runOnTransientConnection !== true) {\n      throw new CodeError('Cannot open protocol stream on transient connection', 'ERR_TRANSIENT_CONNECTION')\n    }\n\n    handler({ connection, stream })\n  }\n\n  /**\n   * Attempts to encrypt the incoming `connection` with the provided `cryptos`\n   */\n  async _encryptInbound (connection: MultiaddrConnection): Promise<CryptoResult> {\n    const protocols = Array.from(this.connectionEncryption.keys())\n    connection.log('handling inbound crypto protocol selection', protocols)\n\n    try {\n      const { stream, protocol } = await mss.handle(connection, protocols, {\n        log: connection.log\n      })\n      const encrypter = this.connectionEncryption.get(protocol)\n\n      if (encrypter == null) {\n        throw new Error(`no crypto module found for ${protocol}`)\n      }\n\n      connection.log('encrypting inbound connection using', protocol)\n\n      return {\n        ...await encrypter.secureInbound(this.components.peerId, stream),\n        protocol\n      }\n    } catch (err: any) {\n      connection.log.error('encrypting inbound connection to %p failed', err)\n      throw new CodeError(err.message, codes.ERR_ENCRYPTION_FAILED)\n    }\n  }\n\n  /**\n   * Attempts to encrypt the given `connection` with the provided connection encrypters.\n   * The first `ConnectionEncrypter` module to succeed will be used\n   */\n  async _encryptOutbound (connection: MultiaddrConnection, remotePeerId?: PeerId): Promise<CryptoResult> {\n    const protocols = Array.from(this.connectionEncryption.keys())\n    connection.log('selecting outbound crypto protocol', protocols)\n\n    try {\n      connection.log.trace('selecting encrypter from %s', protocols)\n\n      const {\n        stream,\n        protocol\n      } = await mss.select(connection, protocols, {\n        log: connection.log,\n        yieldBytes: true\n      })\n\n      const encrypter = this.connectionEncryption.get(protocol)\n\n      if (encrypter == null) {\n        throw new Error(`no crypto module found for ${protocol}`)\n      }\n\n      connection.log('encrypting outbound connection to %p using %s', remotePeerId, encrypter)\n\n      return {\n        ...await encrypter.secureOutbound(this.components.peerId, stream, remotePeerId),\n        protocol\n      }\n    } catch (err: any) {\n      connection.log.error('encrypting outbound connection to %p failed', err)\n      throw new CodeError(err.message, codes.ERR_ENCRYPTION_FAILED)\n    }\n  }\n\n  /**\n   * Selects one of the given muxers via multistream-select. That\n   * muxer will be used for all future streams on the connection.\n   */\n  async _multiplexOutbound (connection: MultiaddrConnection, muxers: Map<string, StreamMuxerFactory>): Promise<{ stream: MultiaddrConnection, muxerFactory?: StreamMuxerFactory }> {\n    const protocols = Array.from(muxers.keys())\n    connection.log('outbound selecting muxer %s', protocols)\n    try {\n      connection.log.trace('selecting stream muxer from %s', protocols)\n\n      const {\n        stream,\n        protocol\n      } = await mss.select(connection, protocols, {\n        log: connection.log,\n        yieldBytes: true\n      })\n\n      connection.log('selected %s as muxer protocol', protocol)\n      const muxerFactory = muxers.get(protocol)\n\n      return { stream, muxerFactory }\n    } catch (err: any) {\n      connection.log.error('error multiplexing outbound connection', err)\n      throw new CodeError(String(err), codes.ERR_MUXER_UNAVAILABLE)\n    }\n  }\n\n  /**\n   * Registers support for one of the given muxers via multistream-select. The\n   * selected muxer will be used for all future streams on the connection.\n   */\n  async _multiplexInbound (connection: MultiaddrConnection, muxers: Map<string, StreamMuxerFactory>): Promise<{ stream: MultiaddrConnection, muxerFactory?: StreamMuxerFactory }> {\n    const protocols = Array.from(muxers.keys())\n    connection.log('inbound handling muxers %s', protocols)\n    try {\n      const { stream, protocol } = await mss.handle(connection, protocols, {\n        log: connection.log\n      })\n      const muxerFactory = muxers.get(protocol)\n\n      return { stream, muxerFactory }\n    } catch (err: any) {\n      connection.log.error('error multiplexing inbound connection', err)\n      throw new CodeError(String(err), codes.ERR_MUXER_UNAVAILABLE)\n    }\n  }\n}\n", "export const version = '1.5.1'\nexport const name = 'libp2p'\n", "import { unmarshalPrivateKey, unmarshalPublicKey } from '@libp2p/crypto/keys'\nimport { contentRoutingSymbol, CodeError, TypedEventEmitter, CustomEvent, setMaxListeners, peerDiscoverySymbol, peerRoutingSymbol } from '@libp2p/interface'\nimport { defaultLogger } from '@libp2p/logger'\nimport { PeerSet } from '@libp2p/peer-collections'\nimport { peerIdFromString } from '@libp2p/peer-id'\nimport { createEd25519PeerId } from '@libp2p/peer-id-factory'\nimport { PersistentPeerStore } from '@libp2p/peer-store'\nimport { isMultiaddr, type Multiaddr } from '@multiformats/multiaddr'\nimport { MemoryDatastore } from 'datastore-core/memory'\nimport { concat as uint8ArrayConcat } from 'uint8arrays/concat'\nimport { fromString as uint8ArrayFromString } from 'uint8arrays/from-string'\nimport { DefaultAddressManager } from './address-manager/index.js'\nimport { defaultComponents } from './components.js'\nimport { connectionGater } from './config/connection-gater.js'\nimport { validateConfig } from './config.js'\nimport { DefaultConnectionManager } from './connection-manager/index.js'\nimport { CompoundContentRouting } from './content-routing.js'\nimport { codes } from './errors.js'\nimport { DefaultPeerRouting } from './peer-routing.js'\nimport { RandomWalk } from './random-walk.js'\nimport { DefaultRegistrar } from './registrar.js'\nimport { DefaultTransportManager } from './transport-manager.js'\nimport { DefaultUpgrader } from './upgrader.js'\nimport * as pkg from './version.js'\nimport type { Components } from './components.js'\nimport type { Libp2p, Libp2pInit, Libp2pOptions } from './index.js'\nimport type { PeerRouting, ContentRouting, Libp2pEvents, PendingDial, ServiceMap, AbortOptions, ComponentLogger, Logger, Connection, NewStreamOptions, Stream, Metrics, PeerId, PeerInfo, PeerStore, Topology, Libp2pStatus, IsDialableOptions } from '@libp2p/interface'\nimport type { StreamHandler, StreamHandlerOptions } from '@libp2p/interface-internal'\n\nexport class Libp2pNode<T extends ServiceMap = Record<string, unknown>> extends TypedEventEmitter<Libp2pEvents> implements Libp2p<T> {\n  public peerId: PeerId\n  public peerStore: PeerStore\n  public contentRouting: ContentRouting\n  public peerRouting: PeerRouting\n  public metrics?: Metrics\n  public services: T\n  public logger: ComponentLogger\n  public status: Libp2pStatus\n\n  public components: Components\n  private readonly log: Logger\n\n  constructor (init: Libp2pInit<T>) {\n    super()\n\n    this.status = 'stopped'\n\n    // event bus - components can listen to this emitter to be notified of system events\n    // and also cause them to be emitted\n    const events = new TypedEventEmitter<Libp2pEvents>()\n    const originalDispatch = events.dispatchEvent.bind(events)\n    events.dispatchEvent = (evt: any) => {\n      const internalResult = originalDispatch(evt)\n      const externalResult = this.dispatchEvent(\n        new CustomEvent(evt.type, { detail: evt.detail })\n      )\n\n      return internalResult || externalResult\n    }\n\n    // This emitter gets listened to a lot\n    setMaxListeners(Infinity, events)\n\n    this.peerId = init.peerId\n    this.logger = init.logger ?? defaultLogger()\n    this.log = this.logger.forComponent('libp2p')\n    // @ts-expect-error {} may not be of type T\n    this.services = {}\n    const components = this.components = defaultComponents({\n      peerId: init.peerId,\n      privateKey: init.privateKey,\n      nodeInfo: init.nodeInfo ?? {\n        name: pkg.name,\n        version: pkg.version\n      },\n      logger: this.logger,\n      events,\n      datastore: init.datastore ?? new MemoryDatastore(),\n      connectionGater: connectionGater(init.connectionGater),\n      dns: init.dns\n    })\n\n    this.peerStore = this.configureComponent('peerStore', new PersistentPeerStore(components, {\n      addressFilter: this.components.connectionGater.filterMultiaddrForPeer,\n      ...init.peerStore\n    }))\n\n    // Create Metrics\n    if (init.metrics != null) {\n      this.metrics = this.configureComponent('metrics', init.metrics(this.components))\n    }\n\n    components.events.addEventListener('peer:update', evt => {\n      // if there was no peer previously in the peer store this is a new peer\n      if (evt.detail.previous == null) {\n        const peerInfo: PeerInfo = {\n          id: evt.detail.peer.id,\n          multiaddrs: evt.detail.peer.addresses.map(a => a.multiaddr)\n        }\n\n        components.events.safeDispatchEvent('peer:discovery', { detail: peerInfo })\n      }\n    })\n\n    // Set up connection protector if configured\n    if (init.connectionProtector != null) {\n      this.configureComponent('connectionProtector', init.connectionProtector(components))\n    }\n\n    // Set up the Upgrader\n    this.components.upgrader = new DefaultUpgrader(this.components, {\n      connectionEncryption: (init.connectionEncryption ?? []).map((fn, index) => this.configureComponent(`connection-encryption-${index}`, fn(this.components))),\n      muxers: (init.streamMuxers ?? []).map((fn, index) => this.configureComponent(`stream-muxers-${index}`, fn(this.components))),\n      inboundUpgradeTimeout: init.connectionManager.inboundUpgradeTimeout\n    })\n\n    // Setup the transport manager\n    this.configureComponent('transportManager', new DefaultTransportManager(this.components, init.transportManager))\n\n    // Create the Connection Manager\n    this.configureComponent('connectionManager', new DefaultConnectionManager(this.components, init.connectionManager))\n\n    // Create the Registrar\n    this.configureComponent('registrar', new DefaultRegistrar(this.components))\n\n    // Addresses {listen, announce, noAnnounce}\n    this.configureComponent('addressManager', new DefaultAddressManager(this.components, init.addresses))\n\n    // Peer routers\n    const peerRouters: PeerRouting[] = (init.peerRouters ?? []).map((fn, index) => this.configureComponent(`peer-router-${index}`, fn(this.components)))\n    this.peerRouting = this.components.peerRouting = this.configureComponent('peerRouting', new DefaultPeerRouting(this.components, {\n      routers: peerRouters\n    }))\n\n    // Content routers\n    const contentRouters: ContentRouting[] = (init.contentRouters ?? []).map((fn, index) => this.configureComponent(`content-router-${index}`, fn(this.components)))\n    this.contentRouting = this.components.contentRouting = this.configureComponent('contentRouting', new CompoundContentRouting(this.components, {\n      routers: contentRouters\n    }))\n\n    // Random walk\n    this.configureComponent('randomWalk', new RandomWalk(this.components))\n\n    // Discovery modules\n    ;(init.peerDiscovery ?? []).forEach((fn, index) => {\n      const service = this.configureComponent(`peer-discovery-${index}`, fn(this.components))\n\n      service.addEventListener('peer', (evt) => {\n        this.#onDiscoveryPeer(evt)\n      })\n    })\n\n    // Transport modules\n    init.transports?.forEach((fn, index) => {\n      this.components.transportManager.add(this.configureComponent(`transport-${index}`, fn(this.components)))\n    })\n\n    // User defined modules\n    if (init.services != null) {\n      for (const name of Object.keys(init.services)) {\n        const createService = init.services[name]\n        const service: any = createService(this.components)\n\n        if (service == null) {\n          this.log.error('service factory %s returned null or undefined instance', name)\n          continue\n        }\n\n        this.services[name as keyof T] = service\n        this.configureComponent(name, service)\n\n        if (service[contentRoutingSymbol] != null) {\n          this.log('registering service %s for content routing', name)\n          contentRouters.push(service[contentRoutingSymbol])\n        }\n\n        if (service[peerRoutingSymbol] != null) {\n          this.log('registering service %s for peer routing', name)\n          peerRouters.push(service[peerRoutingSymbol])\n        }\n\n        if (service[peerDiscoverySymbol] != null) {\n          this.log('registering service %s for peer discovery', name)\n          service[peerDiscoverySymbol].addEventListener?.('peer', (evt: CustomEvent<PeerInfo>) => {\n            this.#onDiscoveryPeer(evt)\n          })\n        }\n      }\n    }\n  }\n\n  private configureComponent <T> (name: string, component: T): T {\n    if (component == null) {\n      this.log.error('component %s was null or undefined', name)\n    }\n\n    this.components[name] = component\n\n    return component\n  }\n\n  /**\n   * Starts the libp2p node and all its subsystems\n   */\n  async start (): Promise<void> {\n    if (this.status !== 'stopped') {\n      return\n    }\n\n    this.status = 'starting'\n\n    this.log('libp2p is starting')\n\n    try {\n      await this.components.beforeStart?.()\n      await this.components.start()\n      await this.components.afterStart?.()\n\n      this.status = 'started'\n      this.safeDispatchEvent('start', { detail: this })\n      this.log('libp2p has started')\n    } catch (err: any) {\n      this.log.error('An error occurred starting libp2p', err)\n      // set status to 'started' so this.stop() will stop any running components\n      this.status = 'started'\n      await this.stop()\n      throw err\n    }\n  }\n\n  /**\n   * Stop the libp2p node by closing its listeners and open connections\n   */\n  async stop (): Promise<void> {\n    if (this.status !== 'started') {\n      return\n    }\n\n    this.log('libp2p is stopping')\n\n    this.status = 'stopping'\n\n    await this.components.beforeStop?.()\n    await this.components.stop()\n    await this.components.afterStop?.()\n\n    this.status = 'stopped'\n    this.safeDispatchEvent('stop', { detail: this })\n    this.log('libp2p has stopped')\n  }\n\n  getConnections (peerId?: PeerId): Connection[] {\n    return this.components.connectionManager.getConnections(peerId)\n  }\n\n  getDialQueue (): PendingDial[] {\n    return this.components.connectionManager.getDialQueue()\n  }\n\n  getPeers (): PeerId[] {\n    const peerSet = new PeerSet()\n\n    for (const conn of this.components.connectionManager.getConnections()) {\n      peerSet.add(conn.remotePeer)\n    }\n\n    return Array.from(peerSet)\n  }\n\n  async dial (peer: PeerId | Multiaddr | Multiaddr[], options: AbortOptions = {}): Promise<Connection> {\n    return this.components.connectionManager.openConnection(peer, {\n      // ensure any userland dials take top priority in the queue\n      priority: 75,\n      ...options\n    })\n  }\n\n  async dialProtocol (peer: PeerId | Multiaddr | Multiaddr[], protocols: string | string[], options: NewStreamOptions = {}): Promise<Stream> {\n    if (protocols == null) {\n      throw new CodeError('no protocols were provided to open a stream', codes.ERR_INVALID_PROTOCOLS_FOR_STREAM)\n    }\n\n    protocols = Array.isArray(protocols) ? protocols : [protocols]\n\n    if (protocols.length === 0) {\n      throw new CodeError('no protocols were provided to open a stream', codes.ERR_INVALID_PROTOCOLS_FOR_STREAM)\n    }\n\n    const connection = await this.dial(peer, options)\n\n    return connection.newStream(protocols, options)\n  }\n\n  getMultiaddrs (): Multiaddr[] {\n    return this.components.addressManager.getAddresses()\n  }\n\n  getProtocols (): string[] {\n    return this.components.registrar.getProtocols()\n  }\n\n  async hangUp (peer: PeerId | Multiaddr, options: AbortOptions = {}): Promise<void> {\n    if (isMultiaddr(peer)) {\n      peer = peerIdFromString(peer.getPeerId() ?? '')\n    }\n\n    await this.components.connectionManager.closeConnections(peer, options)\n  }\n\n  /**\n   * Get the public key for the given peer id\n   */\n  async getPublicKey (peer: PeerId, options: AbortOptions = {}): Promise<Uint8Array> {\n    this.log('getPublicKey %p', peer)\n\n    if (peer.publicKey != null) {\n      return peer.publicKey\n    }\n\n    try {\n      const peerInfo = await this.peerStore.get(peer)\n\n      if (peerInfo.id.publicKey != null) {\n        return peerInfo.id.publicKey\n      }\n    } catch (err: any) {\n      if (err.code !== codes.ERR_NOT_FOUND) {\n        throw err\n      }\n    }\n\n    const peerKey = uint8ArrayConcat([\n      uint8ArrayFromString('/pk/'),\n      peer.multihash.digest\n    ])\n\n    // search any available content routing methods\n    const bytes = await this.contentRouting.get(peerKey, options)\n\n    // ensure the returned key is valid\n    unmarshalPublicKey(bytes)\n\n    await this.peerStore.patch(peer, {\n      publicKey: bytes\n    })\n\n    return bytes\n  }\n\n  async handle (protocols: string | string[], handler: StreamHandler, options?: StreamHandlerOptions): Promise<void> {\n    if (!Array.isArray(protocols)) {\n      protocols = [protocols]\n    }\n\n    await Promise.all(\n      protocols.map(async protocol => {\n        await this.components.registrar.handle(protocol, handler, options)\n      })\n    )\n  }\n\n  async unhandle (protocols: string[] | string): Promise<void> {\n    if (!Array.isArray(protocols)) {\n      protocols = [protocols]\n    }\n\n    await Promise.all(\n      protocols.map(async protocol => {\n        await this.components.registrar.unhandle(protocol)\n      })\n    )\n  }\n\n  async register (protocol: string, topology: Topology): Promise<string> {\n    return this.components.registrar.register(protocol, topology)\n  }\n\n  unregister (id: string): void {\n    this.components.registrar.unregister(id)\n  }\n\n  async isDialable (multiaddr: Multiaddr, options: IsDialableOptions = {}): Promise<boolean> {\n    return this.components.connectionManager.isDialable(multiaddr, options)\n  }\n\n  /**\n   * Called whenever peer discovery services emit `peer` events and adds peers\n   * to the peer store.\n   */\n  #onDiscoveryPeer (evt: CustomEvent<PeerInfo>): void {\n    const { detail: peer } = evt\n\n    if (peer.id.toString() === this.peerId.toString()) {\n      this.log.error(new Error(codes.ERR_DISCOVERED_SELF))\n      return\n    }\n\n    void this.components.peerStore.merge(peer.id, {\n      multiaddrs: peer.multiaddrs\n    })\n      .catch(err => { this.log.error(err) })\n  }\n}\n\n/**\n * Returns a new Libp2pNode instance - this exposes more of the internals than the\n * libp2p interface and is useful for testing and debugging.\n */\nexport async function createLibp2pNode <T extends ServiceMap = Record<string, unknown>> (options: Libp2pOptions<T> = {}): Promise<Libp2pNode<T>> {\n  const peerId = options.peerId ??= await createEd25519PeerId()\n\n  if (peerId.privateKey == null) {\n    throw new CodeError('peer id was missing private key', 'ERR_MISSING_PRIVATE_KEY')\n  }\n\n  options.privateKey ??= await unmarshalPrivateKey(peerId.privateKey as Uint8Array)\n\n  return new Libp2pNode(await validateConfig(options))\n}\n", "/**\n * @packageDocumentation\n *\n * Use the `createLibp2p` function to create a libp2p node.\n *\n * @example\n *\n * ```typescript\n * import { createLibp2p } from 'libp2p'\n *\n * const node = await createLibp2p({\n *   // ...other options\n * })\n * ```\n */\n\nimport { createLibp2pNode } from './libp2p.js'\nimport type { AddressManagerInit } from './address-manager/index.js'\nimport type { Components } from './components.js'\nimport type { ConnectionManagerInit } from './connection-manager/index.js'\nimport type { TransportManagerInit } from './transport-manager.js'\nimport type { Libp2p, ServiceMap, RecursivePartial, ComponentLogger, NodeInfo, ConnectionProtector, ConnectionEncrypter, ConnectionGater, ContentRouting, Metrics, PeerDiscovery, PeerId, PeerRouting, StreamMuxerFactory, Transport, PrivateKey } from '@libp2p/interface'\nimport type { PersistentPeerStoreInit } from '@libp2p/peer-store'\nimport type { DNS } from '@multiformats/dns'\nimport type { Datastore } from 'interface-datastore'\n\nexport type ServiceFactoryMap<T extends Record<string, unknown> = Record<string, unknown>> = {\n  [Property in keyof T]: (components: Components) => T[Property]\n}\n\n/**\n * For Libp2p configurations and modules details read the [Configuration Document](https://github.com/libp2p/js-libp2p/tree/main/doc/CONFIGURATION.md).\n */\nexport interface Libp2pInit<T extends ServiceMap = { x: Record<string, unknown> }> {\n  /**\n   * peerId instance (it will be created if not provided)\n   */\n  peerId: PeerId\n\n  /**\n   * Private key associated with the peerId\n   */\n  privateKey: PrivateKey\n\n  /**\n   * Metadata about the node - implementation name, version number, etc\n   */\n  nodeInfo: NodeInfo\n\n  /**\n   * Addresses for transport listening and to advertise to the network\n   */\n  addresses: AddressManagerInit\n\n  /**\n   * libp2p Connection Manager configuration\n   */\n  connectionManager: ConnectionManagerInit\n\n  /**\n   * A connection gater can deny new connections based on user criteria\n   */\n  connectionGater: ConnectionGater\n\n  /**\n   * libp2p transport manager configuration\n   */\n  transportManager: TransportManagerInit\n\n  /**\n   * An optional datastore to persist peer information, DHT records, etc.\n   *\n   * An in-memory datastore will be used if one is not provided.\n   */\n  datastore: Datastore\n\n  /**\n   * libp2p PeerStore configuration\n   */\n  peerStore: PersistentPeerStoreInit\n\n  /**\n   * An array that must include at least 1 compliant transport\n   */\n  transports?: Array<(components: Components) => Transport>\n  streamMuxers?: Array<(components: Components) => StreamMuxerFactory>\n  connectionEncryption?: Array<(components: Components) => ConnectionEncrypter>\n  peerDiscovery?: Array<(components: Components) => PeerDiscovery>\n  peerRouters?: Array<(components: Components) => PeerRouting>\n  contentRouters?: Array<(components: Components) => ContentRouting>\n\n  /**\n   * A Metrics implementation can be supplied to collect metrics on this node\n   */\n  metrics?(components: Components): Metrics\n\n  /**\n   * A ConnectionProtector can be used to create a secure overlay on top of the network using pre-shared keys\n   */\n  connectionProtector?(components: Components): ConnectionProtector\n\n  /**\n   * Arbitrary libp2p modules\n   */\n  services: ServiceFactoryMap<T>\n\n  /**\n   * An optional logging implementation that can be used to write runtime logs.\n   *\n   * Set the `DEBUG` env var or the `debug` key on LocalStorage to see logs.\n   *\n   * @example\n   *\n   * Node.js:\n   *\n   * ```console\n   * $ DEBUG=\"*libp2p:*\" node myscript.js\n   * ```\n   *\n   * Browsers:\n   *\n   * ```TypeScript\n   * localStorage.setItem('debug', '*libp2p:*')\n   * ```\n   */\n  logger?: ComponentLogger\n\n  /**\n   * An optional DNS resolver configuration. If omitted the default DNS resolver\n   * for the platform will be used which means `node:dns` on Node.js and\n   * DNS-JSON-over-HTTPS for browsers using Google and Cloudflare servers.\n   */\n  dns?: DNS\n}\n\nexport type { Libp2p }\n\nexport type Libp2pOptions<T extends ServiceMap = Record<string, unknown>> = RecursivePartial<Libp2pInit<T>> & { start?: boolean }\n\n/**\n * Returns a new instance of the Libp2p interface, generating a new PeerId\n * if one is not passed as part of the options.\n *\n * The node will be started unless `start: false` is passed as an option.\n *\n * @example\n *\n * ```TypeScript\n * import { createLibp2p } from 'libp2p'\n * import { tcp } from '@libp2p/tcp'\n * import { mplex } from '@libp2p/mplex'\n * import { noise } from '@chainsafe/libp2p-noise'\n * import { yamux } from '@chainsafe/libp2p-yamux'\n *\n * // specify options\n * const options = {\n *   transports: [tcp()],\n *   streamMuxers: [yamux(), mplex()],\n *   connectionEncryption: [noise()]\n * }\n *\n * // create libp2p\n * const libp2p = await createLibp2p(options)\n * ```\n */\nexport async function createLibp2p <T extends ServiceMap = { x: Record<string, unknown> }> (options: Libp2pOptions<T> = {}): Promise<Libp2p<T>> {\n  const node = await createLibp2pNode(options)\n\n  if (options.start !== false) {\n    await node.start()\n  }\n\n  return node\n}\n"],
  "mappings": "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",
  "names": ["name", "debug", "name", "EventEmitter", "events", "name", "cache", "name", "globalThis", "debug", "logger", "name", "debug", "PeerIdProto", "arr", "src_default", "EventEmitter", "filter", "src_default", "event", "name", "src_default", "name", "defaultOptions", "Peer", "Peer$metadataEntry", "_codec", "Peer$tagsEntry", "Address", "Tag", "filter", "multiaddr", "multiaddr", "cache", "src_default", "multiaddr", "isAsyncIterable", "src_default", "isAsyncIterable", "src_default", "isAsyncIterable", "src_default", "isAsyncIterable", "src_default", "src_default", "it", "errCode", "multiaddr", "response", "hashlru", "resolvers", "RecordType", "dnsaddrResolver", "ma", "import_index", "mergeOptions", "messages", "codes", "codes", "codes", "defaultOptions", "debounce", "numConnections", "defaultOptions", "ma", "defaultOptions", "multiaddr", "options", "codes", "err", "defaultOptions", "codes", "multiaddr", "codes", "src_default", "CustomEvent", "codes", "src_default", "peer", "codes", "name", "codes", "message", "protocol", "response", "encode", "codes", "options", "connectionGater", "maConn", "events", "name", "codes", "multiaddr"]
}
