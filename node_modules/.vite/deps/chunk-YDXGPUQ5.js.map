{
  "version": 3,
  "sources": ["../../@multiformats/multiaddr/src/codec.ts", "../../@multiformats/multiaddr/src/multiaddr.ts", "../../@multiformats/multiaddr/src/filter/multiaddr-filter.ts", "../../@multiformats/multiaddr/src/index.ts"],
  "sourcesContent": ["import * as varint from 'uint8-varint'\nimport { concat as uint8ArrayConcat } from 'uint8arrays/concat'\nimport { toString as uint8ArrayToString } from 'uint8arrays/to-string'\nimport { convertToBytes, convertToString } from './convert.js'\nimport { getProtocol } from './protocols-table.js'\nimport type { StringTuple, Tuple, Protocol } from './index.js'\n\nexport interface MultiaddrParts {\n  bytes: Uint8Array\n  string: string\n  tuples: Tuple[]\n  stringTuples: StringTuple[]\n  path: string | null\n}\n\nexport function stringToMultiaddrParts (str: string): MultiaddrParts {\n  str = cleanPath(str)\n  const tuples: Tuple[] = []\n  const stringTuples: StringTuple[] = []\n  let path: string | null = null\n\n  const parts = str.split('/').slice(1)\n  if (parts.length === 1 && parts[0] === '') {\n    return {\n      bytes: new Uint8Array(),\n      string: '/',\n      tuples: [],\n      stringTuples: [],\n      path: null\n    }\n  }\n\n  for (let p = 0; p < parts.length; p++) {\n    const part = parts[p]\n    const proto = getProtocol(part)\n\n    if (proto.size === 0) {\n      tuples.push([proto.code])\n      stringTuples.push([proto.code])\n      // eslint-disable-next-line no-continue\n      continue\n    }\n\n    p++ // advance addr part\n    if (p >= parts.length) {\n      throw ParseError('invalid address: ' + str)\n    }\n\n    // if it's a path proto, take the rest\n    if (proto.path === true) {\n      // should we need to check each path part to see if it's a proto?\n      // This would allow for other protocols to be added after a unix path,\n      // however it would have issues if the path had a protocol name in the path\n      path = cleanPath(parts.slice(p).join('/'))\n      tuples.push([proto.code, convertToBytes(proto.code, path)])\n      stringTuples.push([proto.code, path])\n      break\n    }\n\n    const bytes = convertToBytes(proto.code, parts[p])\n    tuples.push([proto.code, bytes])\n    stringTuples.push([proto.code, convertToString(proto.code, bytes)])\n  }\n\n  return {\n    string: stringTuplesToString(stringTuples),\n    bytes: tuplesToBytes(tuples),\n    tuples,\n    stringTuples,\n    path\n  }\n}\n\nexport function bytesToMultiaddrParts (bytes: Uint8Array): MultiaddrParts {\n  const tuples: Tuple[] = []\n  const stringTuples: StringTuple[] = []\n  let path: string | null = null\n\n  let i = 0\n  while (i < bytes.length) {\n    const code = varint.decode(bytes, i)\n    const n = varint.encodingLength(code)\n\n    const p = getProtocol(code)\n\n    const size = sizeForAddr(p, bytes.slice(i + n))\n\n    if (size === 0) {\n      tuples.push([code])\n      stringTuples.push([code])\n      i += n\n      // eslint-disable-next-line no-continue\n      continue\n    }\n\n    const addr = bytes.slice(i + n, i + n + size)\n\n    i += (size + n)\n\n    if (i > bytes.length) { // did not end _exactly_ at buffer.length\n      throw ParseError('Invalid address Uint8Array: ' + uint8ArrayToString(bytes, 'base16'))\n    }\n\n    // ok, tuple seems good.\n    tuples.push([code, addr])\n    const stringAddr = convertToString(code, addr)\n    stringTuples.push([code, stringAddr])\n    if (p.path === true) {\n      // should we need to check each path part to see if it's a proto?\n      // This would allow for other protocols to be added after a unix path,\n      // however it would have issues if the path had a protocol name in the path\n      path = stringAddr\n      break\n    }\n  }\n\n  return {\n    bytes: Uint8Array.from(bytes),\n    string: stringTuplesToString(stringTuples),\n    tuples,\n    stringTuples,\n    path\n  }\n}\n\n/**\n * [[str name, str addr]... ] -> string\n */\nfunction stringTuplesToString (tuples: StringTuple[]): string {\n  const parts: string[] = []\n  tuples.map((tup) => {\n    const proto = getProtocol(tup[0])\n    parts.push(proto.name)\n    if (tup.length > 1 && tup[1] != null) {\n      parts.push(tup[1])\n    }\n    return null\n  })\n\n  return cleanPath(parts.join('/'))\n}\n\n/**\n * [[int code, Uint8Array ]... ] -> Uint8Array\n */\nexport function tuplesToBytes (tuples: Tuple[]): Uint8Array {\n  return uint8ArrayConcat(tuples.map((tup) => {\n    const proto = getProtocol(tup[0])\n    let buf = Uint8Array.from(varint.encode(proto.code))\n\n    if (tup.length > 1 && tup[1] != null) {\n      buf = uint8ArrayConcat([buf, tup[1]]) // add address buffer\n    }\n\n    return buf\n  }))\n}\n\n/**\n * For the passed address, return the serialized size\n */\nfunction sizeForAddr (p: Protocol, addr: Uint8Array | number[]): number {\n  if (p.size > 0) {\n    return p.size / 8\n  } else if (p.size === 0) {\n    return 0\n  } else {\n    const size = varint.decode(addr instanceof Uint8Array ? addr : Uint8Array.from(addr))\n    return size + varint.encodingLength(size)\n  }\n}\n\nexport function bytesToTuples (buf: Uint8Array): Tuple[] {\n  const tuples: Array<[number, Uint8Array?]> = []\n  let i = 0\n  while (i < buf.length) {\n    const code = varint.decode(buf, i)\n    const n = varint.encodingLength(code)\n\n    const p = getProtocol(code)\n\n    const size = sizeForAddr(p, buf.slice(i + n))\n\n    if (size === 0) {\n      tuples.push([code])\n      i += n\n      // eslint-disable-next-line no-continue\n      continue\n    }\n\n    const addr = buf.slice(i + n, i + n + size)\n\n    i += (size + n)\n\n    if (i > buf.length) { // did not end _exactly_ at buffer.length\n      throw ParseError('Invalid address Uint8Array: ' + uint8ArrayToString(buf, 'base16'))\n    }\n\n    // ok, tuple seems good.\n    tuples.push([code, addr])\n  }\n\n  return tuples\n}\n\nexport function cleanPath (str: string): string {\n  return '/' + str.trim().split('/').filter((a) => a).join('/')\n}\n\nexport function ParseError (str: string): Error {\n  return new Error('Error parsing address: ' + str)\n}\n", "/**\n * @packageDocumentation\n *\n * An implementation of a Multiaddr in JavaScript\n *\n * @example\n *\n * ```js\n * import { multiaddr } from '@multiformats/multiaddr'\n *\n * const ma = multiaddr('/ip4/127.0.0.1/tcp/1234')\n * ```\n */\n\nimport { CodeError } from '@libp2p/interface'\nimport { base58btc } from 'multiformats/bases/base58'\nimport { CID } from 'multiformats/cid'\nimport { equals as uint8ArrayEquals } from 'uint8arrays/equals'\nimport { toString as uint8ArrayToString } from 'uint8arrays/to-string'\nimport { bytesToMultiaddrParts, stringToMultiaddrParts, type MultiaddrParts, tuplesToBytes } from './codec.js'\nimport { getProtocol, names } from './protocols-table.js'\nimport { isMultiaddr, multiaddr, resolvers } from './index.js'\nimport type { MultiaddrInput, Multiaddr as MultiaddrInterface, MultiaddrObject, Protocol, StringTuple, Tuple, NodeAddress, ResolveOptions } from './index.js'\n\nconst inspect = Symbol.for('nodejs.util.inspect.custom')\nexport const symbol = Symbol.for('@multiformats/js-multiaddr/multiaddr')\n\nconst DNS_CODES = [\n  getProtocol('dns').code,\n  getProtocol('dns4').code,\n  getProtocol('dns6').code,\n  getProtocol('dnsaddr').code\n]\n\n/**\n * Creates a {@link Multiaddr} from a {@link MultiaddrInput}\n */\nexport class Multiaddr implements MultiaddrInterface {\n  public bytes: Uint8Array\n  #string: string\n  #tuples: Tuple[]\n  #stringTuples: StringTuple[]\n  #path: string | null\n\n  [symbol]: boolean = true\n\n  constructor (addr?: MultiaddrInput) {\n    // default\n    if (addr == null) {\n      addr = ''\n    }\n\n    let parts: MultiaddrParts\n    if (addr instanceof Uint8Array) {\n      parts = bytesToMultiaddrParts(addr)\n    } else if (typeof addr === 'string') {\n      if (addr.length > 0 && addr.charAt(0) !== '/') {\n        throw new Error(`multiaddr \"${addr}\" must start with a \"/\"`)\n      }\n      parts = stringToMultiaddrParts(addr)\n    } else if (isMultiaddr(addr)) { // Multiaddr\n      parts = bytesToMultiaddrParts(addr.bytes)\n    } else {\n      throw new Error('addr must be a string, Buffer, or another Multiaddr')\n    }\n\n    this.bytes = parts.bytes\n    this.#string = parts.string\n    this.#tuples = parts.tuples\n    this.#stringTuples = parts.stringTuples\n    this.#path = parts.path\n  }\n\n  toString (): string {\n    return this.#string\n  }\n\n  toJSON (): string {\n    return this.toString()\n  }\n\n  toOptions (): MultiaddrObject {\n    let family: 4 | 6 | undefined\n    let transport: string | undefined\n    let host: string | undefined\n    let port: number | undefined\n    let zone = ''\n\n    const tcp = getProtocol('tcp')\n    const udp = getProtocol('udp')\n    const ip4 = getProtocol('ip4')\n    const ip6 = getProtocol('ip6')\n    const dns6 = getProtocol('dns6')\n    const ip6zone = getProtocol('ip6zone')\n\n    for (const [code, value] of this.stringTuples()) {\n      if (code === ip6zone.code) {\n        zone = `%${value ?? ''}`\n      }\n\n      // default to https when protocol & port are omitted from DNS addrs\n      if (DNS_CODES.includes(code)) {\n        transport = tcp.name\n        port = 443\n        host = `${value ?? ''}${zone}`\n        family = code === dns6.code ? 6 : 4\n      }\n\n      if (code === tcp.code || code === udp.code) {\n        transport = getProtocol(code).name\n        port = parseInt(value ?? '')\n      }\n\n      if (code === ip4.code || code === ip6.code) {\n        transport = getProtocol(code).name\n        host = `${value ?? ''}${zone}`\n        family = code === ip6.code ? 6 : 4\n      }\n    }\n\n    if (family == null || transport == null || host == null || port == null) {\n      throw new Error('multiaddr must have a valid format: \"/{ip4, ip6, dns4, dns6, dnsaddr}/{address}/{tcp, udp}/{port}\".')\n    }\n\n    const opts: MultiaddrObject = {\n      family,\n      host,\n      transport,\n      port\n    }\n\n    return opts\n  }\n\n  protos (): Protocol[] {\n    return this.#tuples.map(([code]) => Object.assign({}, getProtocol(code)))\n  }\n\n  protoCodes (): number[] {\n    return this.#tuples.map(([code]) => code)\n  }\n\n  protoNames (): string[] {\n    return this.#tuples.map(([code]) => getProtocol(code).name)\n  }\n\n  tuples (): Array<[number, Uint8Array?]> {\n    return this.#tuples\n  }\n\n  stringTuples (): Array<[number, string?]> {\n    return this.#stringTuples\n  }\n\n  encapsulate (addr: MultiaddrInput): Multiaddr {\n    addr = new Multiaddr(addr)\n    return new Multiaddr(this.toString() + addr.toString())\n  }\n\n  decapsulate (addr: Multiaddr | string): Multiaddr {\n    const addrString = addr.toString()\n    const s = this.toString()\n    const i = s.lastIndexOf(addrString)\n    if (i < 0) {\n      throw new Error(`Address ${this.toString()} does not contain subaddress: ${addr.toString()}`)\n    }\n    return new Multiaddr(s.slice(0, i))\n  }\n\n  decapsulateCode (code: number): Multiaddr {\n    const tuples = this.tuples()\n    for (let i = tuples.length - 1; i >= 0; i--) {\n      if (tuples[i][0] === code) {\n        return new Multiaddr(tuplesToBytes(tuples.slice(0, i)))\n      }\n    }\n    return this\n  }\n\n  getPeerId (): string | null {\n    try {\n      let tuples: Array<[number, string | undefined]> = []\n\n      this.stringTuples().forEach(([code, name]) => {\n        if (code === names.p2p.code) {\n          tuples.push([code, name])\n        }\n\n        // if this is a p2p-circuit address, return the target peer id if present\n        // not the peer id of the relay\n        if (code === names['p2p-circuit'].code) {\n          tuples = []\n        }\n      })\n\n      // Get the last ipfs tuple ['p2p', 'peerid string']\n      const tuple = tuples.pop()\n      if (tuple?.[1] != null) {\n        const peerIdStr = tuple[1]\n\n        // peer id is base58btc encoded string but not multibase encoded so add the `z`\n        // prefix so we can validate that it is correctly encoded\n        if (peerIdStr[0] === 'Q' || peerIdStr[0] === '1') {\n          return uint8ArrayToString(base58btc.decode(`z${peerIdStr}`), 'base58btc')\n        }\n\n        // try to parse peer id as CID\n        return uint8ArrayToString(CID.parse(peerIdStr).multihash.bytes, 'base58btc')\n      }\n\n      return null\n    } catch (e) {\n      return null\n    }\n  }\n\n  getPath (): string | null {\n    return this.#path\n  }\n\n  equals (addr: { bytes: Uint8Array }): boolean {\n    return uint8ArrayEquals(this.bytes, addr.bytes)\n  }\n\n  async resolve (options?: ResolveOptions): Promise<MultiaddrInterface[]> {\n    const resolvableProto = this.protos().find((p) => p.resolvable)\n\n    // Multiaddr is not resolvable?\n    if (resolvableProto == null) {\n      return [this]\n    }\n\n    const resolver = resolvers.get(resolvableProto.name)\n    if (resolver == null) {\n      throw new CodeError(`no available resolver for ${resolvableProto.name}`, 'ERR_NO_AVAILABLE_RESOLVER')\n    }\n\n    const result = await resolver(this, options)\n\n    return result.map(str => multiaddr(str))\n  }\n\n  nodeAddress (): NodeAddress {\n    const options = this.toOptions()\n\n    if (options.transport !== 'tcp' && options.transport !== 'udp') {\n      throw new Error(`multiaddr must have a valid format - no protocol with name: \"${options.transport}\". Must have a valid transport protocol: \"{tcp, udp}\"`)\n    }\n\n    return {\n      family: options.family,\n      address: options.host,\n      port: options.port\n    }\n  }\n\n  isThinWaistAddress (addr?: Multiaddr): boolean {\n    const protos = (addr ?? this).protos()\n\n    if (protos.length !== 2) {\n      return false\n    }\n\n    if (protos[0].code !== 4 && protos[0].code !== 41) {\n      return false\n    }\n    if (protos[1].code !== 6 && protos[1].code !== 273) {\n      return false\n    }\n    return true\n  }\n\n  /**\n   * Returns Multiaddr as a human-readable string\n   * https://nodejs.org/api/util.html#utilinspectcustom\n   *\n   * @example\n   * ```js\n   * import { multiaddr } from '@multiformats/multiaddr'\n   *\n   * console.info(multiaddr('/ip4/127.0.0.1/tcp/4001'))\n   * // 'Multiaddr(/ip4/127.0.0.1/tcp/4001)'\n   * ```\n   */\n  [inspect] (): string {\n    return `Multiaddr(${this.#string})`\n  }\n}\n", "import { convertToIpNet } from '../convert.js'\nimport { multiaddr, type Multiaddr, type MultiaddrInput } from '../index.js'\nimport type { IpNet } from '@chainsafe/netmask'\n\n/**\n * A utility class to determine if a Multiaddr contains another\n * multiaddr.\n *\n * This can be used with ipcidr ranges to determine if a given\n * multiaddr is in a ipcidr range.\n *\n * @example\n *\n * ```js\n * import { multiaddr, MultiaddrFilter } from '@multiformats/multiaddr'\n *\n * const range = multiaddr('/ip4/192.168.10.10/ipcidr/24')\n * const filter = new MultiaddrFilter(range)\n *\n * const input = multiaddr('/ip4/192.168.10.2/udp/60')\n * console.info(filter.contains(input)) // true\n * ```\n */\nexport class MultiaddrFilter {\n  private readonly multiaddr: Multiaddr\n  private readonly netmask: IpNet\n\n  public constructor (input: MultiaddrInput) {\n    this.multiaddr = multiaddr(input)\n    this.netmask = convertToIpNet(this.multiaddr)\n  }\n\n  public contains (input: MultiaddrInput): boolean {\n    if (input == null) return false\n    const m = multiaddr(input)\n    let ip\n    for (const [code, value] of m.stringTuples()) {\n      if (code === 4 || code === 41) {\n        ip = value\n        break\n      }\n    }\n    if (ip === undefined) return false\n    return this.netmask.contains(ip)\n  }\n}\n", "/**\n * @packageDocumentation\n *\n * A standard way to represent addresses that\n *\n * - support any standard network protocol\n * - are self-describing\n * - have a binary packed format\n * - have a nice string representation\n * - encapsulate well\n *\n * @example\n *\n * ```TypeScript\n * import { multiaddr } from '@multiformats/multiaddr'\n * const addr =  multiaddr(\"/ip4/127.0.0.1/udp/1234\")\n * // Multiaddr(/ip4/127.0.0.1/udp/1234)\n *\n * const addr = multiaddr(\"/ip4/127.0.0.1/udp/1234\")\n * // Multiaddr(/ip4/127.0.0.1/udp/1234)\n *\n * addr.bytes\n * // <Uint8Array 04 7f 00 00 01 11 04 d2>\n *\n * addr.toString()\n * // '/ip4/127.0.0.1/udp/1234'\n *\n * addr.protos()\n * // [\n * //   {code: 4, name: 'ip4', size: 32},\n * //   {code: 273, name: 'udp', size: 16}\n * // ]\n *\n * // gives you an object that is friendly with what Node.js core modules expect for addresses\n * addr.nodeAddress()\n * // {\n * //   family: 4,\n * //   port: 1234,\n * //   address: \"127.0.0.1\"\n * // }\n *\n * addr.encapsulate('/sctp/5678')\n * // Multiaddr(/ip4/127.0.0.1/udp/1234/sctp/5678)\n * ```\n *\n * ## Resolving DNSADDR addresses\n *\n * [DNSADDR](https://github.com/multiformats/multiaddr/blob/master/protocols/DNSADDR.md) is a spec that allows storing a TXT DNS record that contains a Multiaddr.\n *\n * To resolve DNSADDR addresses, call the `.resolve()` function the multiaddr, optionally passing a `DNS` resolver.\n *\n * DNSADDR addresses can resolve to multiple multiaddrs, since there is no limit to the number of TXT records that can be stored.\n *\n * @example Resolving DNSADDR Multiaddrs\n *\n * ```TypeScript\n * import { multiaddr, resolvers } from '@multiformats/multiaddr'\n * import { dnsaddr } from '@multiformats/multiaddr/resolvers'\n *\n * resolvers.set('dnsaddr', dnsaddr)\n *\n * const ma = multiaddr('/dnsaddr/bootstrap.libp2p.io')\n *\n * // resolve with a 5s timeout\n * const resolved = await ma.resolve({\n *   signal: AbortSignal.timeout(5000)\n * })\n *\n * console.info(await ma.resolve(resolved)\n * // [Multiaddr('/ip4/147.75...'), Multiaddr('/ip4/147.75...'), Multiaddr('/ip4/147.75...')...]\n * ```\n *\n * @example Using a custom DNS resolver to resolve DNSADDR Multiaddrs\n *\n * See the docs for [@multiformats/dns](https://www.npmjs.com/package/@multiformats/dns) for a full breakdown of how to specify multiple resolvers or resolvers that can be used for specific TLDs.\n *\n * ```TypeScript\n * import { multiaddr } from '@multiformats/multiaddr'\n * import { dns } from '@multiformats/dns'\n * import { dnsJsonOverHttps } from '@multiformats/dns/resolvers'\n *\n * const resolver = dns({\n *   '.': dnsJsonOverHttps('https://cloudflare-dns.com/dns-query')\n * })\n *\n * const ma = multiaddr('/dnsaddr/bootstrap.libp2p.io')\n * const resolved = await ma.resolve({\n *  dns: resolver\n * })\n *\n * console.info(resolved)\n * // [Multiaddr('/ip4/147.75...'), Multiaddr('/ip4/147.75...'), Multiaddr('/ip4/147.75...')...]\n * ```\n */\n\nimport { Multiaddr as MultiaddrClass, symbol } from './multiaddr.js'\nimport { getProtocol } from './protocols-table.js'\nimport type { Resolver } from './resolvers/index.js'\nimport type { DNS } from '@multiformats/dns'\n\n/**\n * Protocols are present in the protocol table\n */\nexport interface Protocol {\n  code: number\n  size: number\n  name: string\n  resolvable?: boolean | undefined\n  path?: boolean | undefined\n}\n\n/**\n * A plain JavaScript object representation of a {@link Multiaddr}\n */\nexport interface MultiaddrObject {\n  family: 4 | 6\n  host: string\n  transport: string\n  port: number\n}\n\n/**\n * A NodeAddress is an IPv4/IPv6 address/TCP port combination\n */\nexport interface NodeAddress {\n  family: 4 | 6\n  address: string\n  port: number\n}\n\n/**\n * These types can be parsed into a {@link Multiaddr} object\n */\nexport type MultiaddrInput = string | Multiaddr | Uint8Array | null\n\n/**\n * A code/value pair\n */\nexport type Tuple = [number, Uint8Array?]\n\n/**\n * A code/value pair with the value as a string\n */\nexport type StringTuple = [number, string?]\n\n/**\n * Allows aborting long-lived operations\n */\nexport interface AbortOptions {\n  signal?: AbortSignal\n}\n\n/**\n * All configured {@link Resolver}s\n */\nexport const resolvers = new Map<string, Resolver>()\n\nexport type { Resolver }\n\nexport { MultiaddrFilter } from './filter/multiaddr-filter.js'\n\nexport interface ResolveOptions extends AbortOptions {\n  /**\n   * An optional DNS resolver\n   */\n  dns?: DNS\n\n  /**\n   * When resolving DNSADDR Multiaddrs that resolve to other DNSADDR Multiaddrs,\n   * limit how many times we will recursively resolve them.\n   *\n   * @default 32\n   */\n  maxRecursiveDepth?: number\n}\n\nexport interface Multiaddr {\n  bytes: Uint8Array\n\n  /**\n   * Returns Multiaddr as a String\n   *\n   * @example\n   * ```js\n   * import { multiaddr } from '@multiformats/multiaddr'\n   *\n   * multiaddr('/ip4/127.0.0.1/tcp/4001').toString()\n   * // '/ip4/127.0.0.1/tcp/4001'\n   * ```\n   */\n  toString(): string\n\n  /**\n   * Returns Multiaddr as a JSON encoded object\n   *\n   * @example\n   * ```js\n   * import { multiaddr } from '@multiformats/multiaddr'\n   *\n   * JSON.stringify(multiaddr('/ip4/127.0.0.1/tcp/4001'))\n   * // '/ip4/127.0.0.1/tcp/4001'\n   * ```\n   */\n  toJSON(): string\n\n  /**\n   * Returns Multiaddr as a convinient options object to be used with net.createConnection\n   *\n   * @example\n   * ```js\n   * import { multiaddr } from '@multiformats/multiaddr'\n   *\n   * multiaddr('/ip4/127.0.0.1/tcp/4001').toOptions()\n   * // { family: 4, host: '127.0.0.1', transport: 'tcp', port: 4001 }\n   * ```\n   */\n  toOptions(): MultiaddrObject\n\n  /**\n   * Returns the protocols the Multiaddr is defined with, as an array of objects, in\n   * left-to-right order. Each object contains the protocol code, protocol name,\n   * and the size of its address space in bits.\n   * [See list of protocols](https://github.com/multiformats/multiaddr/blob/master/protocols.csv)\n   *\n   * @example\n   * ```js\n   * import { multiaddr } from '@multiformats/multiaddr'\n   *\n   * multiaddr('/ip4/127.0.0.1/tcp/4001').protos()\n   * // [ { code: 4, size: 32, name: 'ip4' },\n   * //   { code: 6, size: 16, name: 'tcp' } ]\n   * ```\n   */\n  protos(): Protocol[]\n\n  /**\n   * Returns the codes of the protocols in left-to-right order.\n   * [See list of protocols](https://github.com/multiformats/multiaddr/blob/master/protocols.csv)\n   *\n   * @example\n   * ```js\n   * import { multiaddr } from '@multiformats/multiaddr'\n   *\n   * multiaddr('/ip4/127.0.0.1/tcp/4001').protoCodes()\n   * // [ 4, 6 ]\n   * ```\n   */\n  protoCodes(): number[]\n\n  /**\n   * Returns the names of the protocols in left-to-right order.\n   * [See list of protocols](https://github.com/multiformats/multiaddr/blob/master/protocols.csv)\n   *\n   * @example\n   * ```js\n   * import { multiaddr } from '@multiformats/multiaddr'\n   *\n   * multiaddr('/ip4/127.0.0.1/tcp/4001').protoNames()\n   * // [ 'ip4', 'tcp' ]\n   * ```\n   */\n  protoNames(): string[]\n\n  /**\n   * Returns a tuple of parts\n   *\n   * @example\n   * ```js\n   * import { multiaddr } from '@multiformats/multiaddr'\n   *\n   * multiaddr('/ip4/127.0.0.1/tcp/4001').tuples()\n   * // [ [ 4, <Buffer 7f 00 00 01> ], [ 6, <Buffer 0f a1> ] ]\n   * ```\n   */\n  tuples(): Tuple[]\n\n  /**\n   * Returns a tuple of string/number parts\n   * - tuples[][0] = code of protocol\n   * - tuples[][1] = contents of address\n   *\n   * @example\n   * ```js\n   * import { multiaddr } from '@multiformats/multiaddr'\n   *\n   * multiaddr('/ip4/127.0.0.1/tcp/4001').stringTuples()\n   * // [ [ 4, '127.0.0.1' ], [ 6, '4001' ] ]\n   * ```\n   */\n  stringTuples(): StringTuple[]\n\n  /**\n   * Encapsulates a Multiaddr in another Multiaddr\n   *\n   * @example\n   * ```js\n   * import { multiaddr } from '@multiformats/multiaddr'\n   *\n   * const mh1 = multiaddr('/ip4/8.8.8.8/tcp/1080')\n   * // Multiaddr(/ip4/8.8.8.8/tcp/1080)\n   *\n   * const mh2 = multiaddr('/ip4/127.0.0.1/tcp/4001')\n   * // Multiaddr(/ip4/127.0.0.1/tcp/4001)\n   *\n   * const mh3 = mh1.encapsulate(mh2)\n   * // Multiaddr(/ip4/8.8.8.8/tcp/1080/ip4/127.0.0.1/tcp/4001)\n   *\n   * mh3.toString()\n   * // '/ip4/8.8.8.8/tcp/1080/ip4/127.0.0.1/tcp/4001'\n   * ```\n   *\n   * @param {MultiaddrInput} addr - Multiaddr to add into this Multiaddr\n   */\n  encapsulate(addr: MultiaddrInput): Multiaddr\n\n  /**\n   * Decapsulates a Multiaddr from another Multiaddr\n   *\n   * @example\n   * ```js\n   * import { multiaddr } from '@multiformats/multiaddr'\n   *\n   * const mh1 = multiaddr('/ip4/8.8.8.8/tcp/1080')\n   * // Multiaddr(/ip4/8.8.8.8/tcp/1080)\n   *\n   * const mh2 = multiaddr('/ip4/127.0.0.1/tcp/4001')\n   * // Multiaddr(/ip4/127.0.0.1/tcp/4001)\n   *\n   * const mh3 = mh1.encapsulate(mh2)\n   * // Multiaddr(/ip4/8.8.8.8/tcp/1080/ip4/127.0.0.1/tcp/4001)\n   *\n   * mh3.decapsulate(mh2).toString()\n   * // '/ip4/8.8.8.8/tcp/1080'\n   * ```\n   *\n   * @param {Multiaddr | string} addr - Multiaddr to remove from this Multiaddr\n   */\n  decapsulate(addr: Multiaddr | string): Multiaddr\n\n  /**\n   * A more reliable version of `decapsulate` if you are targeting a\n   * specific code, such as 421 (the `p2p` protocol code). The last index of the code\n   * will be removed from the `Multiaddr`, and a new instance will be returned.\n   * If the code is not present, the original `Multiaddr` is returned.\n   *\n   * @example\n   * ```js\n   * import { multiaddr } from '@multiformats/multiaddr'\n   *\n   * const addr = multiaddr('/ip4/0.0.0.0/tcp/8080/p2p/QmcgpsyWgH8Y8ajJz1Cu72KnS5uo2Aa2LpzU7kinSupNKC')\n   * // Multiaddr(/ip4/0.0.0.0/tcp/8080/p2p/QmcgpsyWgH8Y8ajJz1Cu72KnS5uo2Aa2LpzU7kinSupNKC)\n   *\n   * addr.decapsulateCode(421).toString()\n   * // '/ip4/0.0.0.0/tcp/8080'\n   *\n   * multiaddr('/ip4/127.0.0.1/tcp/8080').decapsulateCode(421).toString()\n   * // '/ip4/127.0.0.1/tcp/8080'\n   * ```\n   */\n  decapsulateCode(code: number): Multiaddr\n\n  /**\n   * Extract the peerId if the multiaddr contains one\n   *\n   * @example\n   * ```js\n   * import { multiaddr } from '@multiformats/multiaddr'\n   *\n   * const mh1 = multiaddr('/ip4/8.8.8.8/tcp/1080/ipfs/QmValidBase58string')\n   * // Multiaddr(/ip4/8.8.8.8/tcp/1080/ipfs/QmValidBase58string)\n   *\n   * // should return QmValidBase58string or null if the id is missing or invalid\n   * const peerId = mh1.getPeerId()\n   * ```\n   */\n  getPeerId(): string | null\n\n  /**\n   * Extract the path if the multiaddr contains one\n   *\n   * @example\n   * ```js\n   * import { multiaddr } from '@multiformats/multiaddr'\n   *\n   * const mh1 = multiaddr('/ip4/8.8.8.8/tcp/1080/unix/tmp/p2p.sock')\n   * // Multiaddr(/ip4/8.8.8.8/tcp/1080/unix/tmp/p2p.sock)\n   *\n   * // should return utf8 string or null if the id is missing or invalid\n   * const path = mh1.getPath()\n   * ```\n   */\n  getPath(): string | null\n\n  /**\n   * Checks if two Multiaddrs are the same\n   *\n   * @example\n   * ```js\n   * import { multiaddr } from '@multiformats/multiaddr'\n   *\n   * const mh1 = multiaddr('/ip4/8.8.8.8/tcp/1080')\n   * // Multiaddr(/ip4/8.8.8.8/tcp/1080)\n   *\n   * const mh2 = multiaddr('/ip4/127.0.0.1/tcp/4001')\n   * // Multiaddr(/ip4/127.0.0.1/tcp/4001)\n   *\n   * mh1.equals(mh1)\n   * // true\n   *\n   * mh1.equals(mh2)\n   * // false\n   * ```\n   */\n  equals(addr: { bytes: Uint8Array }): boolean\n\n  /**\n   * Resolve multiaddr if containing resolvable hostname.\n   *\n   * @example\n   * ```js\n   * import { multiaddr, resolvers } from '@multiformats/multiaddr'\n   *\n   * resolvers.set('dnsaddr', resolverFunction)\n   * const mh1 = multiaddr('/dnsaddr/bootstrap.libp2p.io/p2p/QmbLHAnMoJPWSCR5Zhtx6BHJX9KiKNN6tpvbUcqanj75Nb')\n   * const resolvedMultiaddrs = await mh1.resolve()\n   * // [\n   * //   Multiaddr(/ip4/147.75.83.83/tcp/4001/p2p/QmbLHAnMoJPWSCR5Zhtx6BHJX9KiKNN6tpvbUcqanj75Nb),\n   * //   Multiaddr(/ip4/147.75.83.83/tcp/443/wss/p2p/QmbLHAnMoJPWSCR5Zhtx6BHJX9KiKNN6tpvbUcqanj75Nb),\n   * //   Multiaddr(/ip4/147.75.83.83/udp/4001/quic/p2p/QmbLHAnMoJPWSCR5Zhtx6BHJX9KiKNN6tpvbUcqanj75Nb)\n   * // ]\n   * ```\n   */\n  resolve(options?: ResolveOptions): Promise<Multiaddr[]>\n\n  /**\n   * Gets a Multiaddrs node-friendly address object. Note that protocol information\n   * is left out: in Node (and most network systems) the protocol is unknowable\n   * given only the address.\n   *\n   * Has to be a ThinWaist Address, otherwise throws error\n   *\n   * @example\n   * ```js\n   * import { multiaddr } from '@multiformats/multiaddr'\n   *\n   * multiaddr('/ip4/127.0.0.1/tcp/4001').nodeAddress()\n   * // {family: 4, address: '127.0.0.1', port: 4001}\n   * ```\n   */\n  nodeAddress(): NodeAddress\n\n  /**\n   * Returns if a Multiaddr is a Thin Waist address or not.\n   *\n   * Thin Waist is if a Multiaddr adheres to the standard combination of:\n   *\n   * `{IPv4, IPv6}/{TCP, UDP}`\n   *\n   * @example\n   * ```js\n   * import { multiaddr } from '@multiformats/multiaddr'\n   *\n   * const mh1 = multiaddr('/ip4/127.0.0.1/tcp/4001')\n   * // Multiaddr(/ip4/127.0.0.1/tcp/4001)\n   * const mh2 = multiaddr('/ip4/192.168.2.1/tcp/5001')\n   * // Multiaddr(/ip4/192.168.2.1/tcp/5001)\n   * const mh3 = mh1.encapsulate(mh2)\n   * // Multiaddr(/ip4/127.0.0.1/tcp/4001/ip4/192.168.2.1/tcp/5001)\n   * const mh4 = multiaddr('/ip4/127.0.0.1/tcp/2000/wss/p2p-webrtc-star/p2p/QmcgpsyWgH8Y8ajJz1Cu72KnS5uo2Aa2LpzU7kinSooo2a')\n   * // Multiaddr(/ip4/127.0.0.1/tcp/2000/wss/p2p-webrtc-star/p2p/QmcgpsyWgH8Y8ajJz1Cu72KnS5uo2Aa2LpzU7kinSooo2a)\n   * mh1.isThinWaistAddress()\n   * // true\n   * mh2.isThinWaistAddress()\n   * // true\n   * mh3.isThinWaistAddress()\n   * // false\n   * mh4.isThinWaistAddress()\n   * // false\n   * ```\n   */\n  isThinWaistAddress(addr?: Multiaddr): boolean\n}\n\n/**\n * Creates a Multiaddr from a node-friendly address object\n *\n * @example\n * ```js\n * import { fromNodeAddress } from '@multiformats/multiaddr'\n *\n * fromNodeAddress({address: '127.0.0.1', port: '4001'}, 'tcp')\n * // Multiaddr(/ip4/127.0.0.1/tcp/4001)\n * ```\n */\nexport function fromNodeAddress (addr: NodeAddress, transport: string): Multiaddr {\n  if (addr == null) {\n    throw new Error('requires node address object')\n  }\n  if (transport == null) {\n    throw new Error('requires transport protocol')\n  }\n  let ip: string | undefined\n  let host = addr.address\n  switch (addr.family) {\n    case 4:\n      ip = 'ip4'\n      break\n    case 6:\n      ip = 'ip6'\n\n      if (host.includes('%')) {\n        const parts = host.split('%')\n\n        if (parts.length !== 2) {\n          throw Error('Multiple ip6 zones in multiaddr')\n        }\n\n        host = parts[0]\n        const zone = parts[1]\n        ip = `/ip6zone/${zone}/ip6`\n      }\n      break\n    default:\n      throw Error('Invalid addr family, should be 4 or 6.')\n  }\n  return new MultiaddrClass('/' + [ip, host, transport, addr.port].join('/'))\n}\n\n/**\n * Returns if something is a {@link Multiaddr} that is a resolvable name\n *\n * @example\n *\n * ```js\n * import { isName, multiaddr } from '@multiformats/multiaddr'\n *\n * isName(multiaddr('/ip4/127.0.0.1'))\n * // false\n * isName(multiaddr('/dns/ipfs.io'))\n * // true\n * ```\n */\nexport function isName (addr: Multiaddr): boolean {\n  if (!isMultiaddr(addr)) {\n    return false\n  }\n\n  // if a part of the multiaddr is resolvable, then return true\n  return addr.protos().some((proto) => proto.resolvable)\n}\n\n/**\n * Check if object is a {@link Multiaddr} instance\n *\n * @example\n *\n * ```js\n * import { isMultiaddr, multiaddr } from '@multiformats/multiaddr'\n *\n * isMultiaddr(5)\n * // false\n * isMultiaddr(multiaddr('/ip4/127.0.0.1'))\n * // true\n * ```\n */\nexport function isMultiaddr (value: any): value is Multiaddr {\n  return Boolean(value?.[symbol])\n}\n\n/**\n * A function that takes a {@link MultiaddrInput} and returns a {@link Multiaddr}\n *\n * @example\n * ```js\n * import { multiaddr } from '@libp2p/multiaddr'\n *\n * multiaddr('/ip4/127.0.0.1/tcp/4001')\n * // Multiaddr(/ip4/127.0.0.1/tcp/4001)\n * ```\n *\n * @param {MultiaddrInput} [addr] - If String or Uint8Array, needs to adhere to the address format of a [multiaddr](https://github.com/multiformats/multiaddr#string-format)\n */\nexport function multiaddr (addr?: MultiaddrInput): Multiaddr {\n  return new MultiaddrClass(addr)\n}\n\nexport { getProtocol as protocols }\n"],
  "mappings": "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",
  "names": []
}
