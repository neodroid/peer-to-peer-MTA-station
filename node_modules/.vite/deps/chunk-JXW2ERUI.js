import {
  DNS,
  WebSockets,
  WebSocketsSecure
} from "./chunk-ZK5ERHC6.js";

// node_modules/@libp2p/websockets/dist/src/constants.js
var CODE_P2P = 421;
var CODE_CIRCUIT = 290;
var CODE_TCP = 6;
var CODE_WS = 477;
var CODE_WSS = 478;
var CLOSE_TIMEOUT = 500;

// node_modules/@libp2p/websockets/dist/src/filters.js
function all(multiaddrs) {
  return multiaddrs.filter((ma) => {
    if (ma.protoCodes().includes(CODE_CIRCUIT)) {
      return false;
    }
    const testMa = ma.decapsulateCode(CODE_P2P);
    return WebSockets.matches(testMa) || WebSocketsSecure.matches(testMa);
  });
}
function wss(multiaddrs) {
  return multiaddrs.filter((ma) => {
    if (ma.protoCodes().includes(CODE_CIRCUIT)) {
      return false;
    }
    const testMa = ma.decapsulateCode(CODE_P2P);
    return WebSocketsSecure.matches(testMa);
  });
}
function dnsWss(multiaddrs) {
  return multiaddrs.filter((ma) => {
    if (ma.protoCodes().includes(CODE_CIRCUIT)) {
      return false;
    }
    const testMa = ma.decapsulateCode(CODE_P2P);
    return WebSocketsSecure.matches(testMa) && DNS.matches(testMa.decapsulateCode(CODE_TCP).decapsulateCode(CODE_WSS));
  });
}
function dnsWsOrWss(multiaddrs) {
  return multiaddrs.filter((ma) => {
    if (ma.protoCodes().includes(CODE_CIRCUIT)) {
      return false;
    }
    const testMa = ma.decapsulateCode(CODE_P2P);
    if (WebSockets.matches(testMa)) {
      return DNS.matches(testMa.decapsulateCode(CODE_TCP).decapsulateCode(CODE_WS));
    }
    return WebSocketsSecure.matches(testMa) && DNS.matches(testMa.decapsulateCode(CODE_TCP).decapsulateCode(CODE_WSS));
  });
}

export {
  CLOSE_TIMEOUT,
  all,
  wss,
  dnsWss,
  dnsWsOrWss
};
//# sourceMappingURL=chunk-JXW2ERUI.js.map
