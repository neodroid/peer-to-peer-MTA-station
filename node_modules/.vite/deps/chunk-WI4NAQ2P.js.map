{
  "version": 3,
  "sources": ["../../it-byte-stream/src/pushable.ts", "../../it-byte-stream/src/index.ts", "../../it-length-prefixed-stream/src/index.ts"],
  "sourcesContent": ["import deferred, { type DeferredPromise } from 'p-defer'\nimport { raceSignal, type RaceSignalOptions } from 'race-signal'\nimport { type AbortOptions } from './index.js'\n\nexport interface Pushable<T> extends AsyncGenerator<T, void, unknown> {\n  /**\n   * End the iterable after all values in the buffer (if any) have been yielded. If an\n   * error is passed the buffer is cleared immediately and the next iteration will\n   * throw the passed error\n   */\n  end(err?: Error, options?: AbortOptions & RaceSignalOptions): Promise<void>\n\n  /**\n   * Push a value into the iterable. Values are yielded from the iterable in the order\n   * they are pushed. Values not yet consumed from the iterable are buffered.\n   */\n  push(value: T, options?: AbortOptions & RaceSignalOptions): Promise<void>\n}\n\nclass QueuelessPushable <T> implements Pushable<T> {\n  private readNext: DeferredPromise<void>\n  private haveNext: DeferredPromise<void>\n  private ended: boolean\n  private nextResult: IteratorResult<T> | undefined\n\n  constructor () {\n    this.ended = false\n\n    this.readNext = deferred()\n    this.haveNext = deferred()\n  }\n\n  [Symbol.asyncIterator] (): AsyncGenerator<T, void, unknown> {\n    return this\n  }\n\n  async next (): Promise<IteratorResult<T, void>> {\n    if (this.nextResult == null) {\n      // wait for the supplier to push a value\n      await this.haveNext.promise\n    }\n\n    if (this.nextResult == null) {\n      throw new Error('HaveNext promise resolved but nextResult was undefined')\n    }\n\n    const nextResult = this.nextResult\n    this.nextResult = undefined\n\n    // signal to the supplier that we read the value\n    this.readNext.resolve()\n    this.readNext = deferred()\n\n    return nextResult\n  }\n\n  async throw (err?: Error): Promise<IteratorReturnResult<undefined>> {\n    this.ended = true\n\n    if (err != null) {\n      this.haveNext.reject(err)\n    }\n\n    const result: IteratorReturnResult<undefined> = {\n      done: true,\n      value: undefined\n    }\n\n    return result\n  }\n\n  async return (): Promise<IteratorResult<T>> {\n    const result: IteratorReturnResult<undefined> = {\n      done: true,\n      value: undefined\n    }\n\n    await this._push(undefined)\n\n    return result\n  }\n\n  async push (value: T, options?: AbortOptions & RaceSignalOptions): Promise<void> {\n    await this._push(value, options)\n  }\n\n  async end (err?: Error, options?: AbortOptions & RaceSignalOptions): Promise<void> {\n    if (err != null) {\n      await this.throw(err)\n    } else {\n      // abortable return\n      await this._push(undefined, options)\n    }\n  }\n\n  private async _push (value?: T, options?: AbortOptions & RaceSignalOptions): Promise<void> {\n    if (value != null && this.ended) {\n      throw new Error('Cannot push value onto an ended pushable')\n    }\n\n    // already have a value, wait for it to be read\n    if (this.nextResult != null) {\n      await this.readNext.promise\n\n      if (this.nextResult != null) {\n        throw new Error('NeedNext promise resolved but nextResult was not consumed')\n      }\n    }\n\n    if (value != null) {\n      this.nextResult = { done: false, value }\n    } else {\n      this.ended = true\n      this.nextResult = { done: true, value: undefined }\n    }\n\n    // let the consumer know we have a new value\n    this.haveNext.resolve()\n    this.haveNext = deferred()\n\n    // wait for the consumer to have finished processing the value and requested\n    // the next one or for the passed signal to abort the waiting\n    await raceSignal(\n      this.readNext.promise,\n      options?.signal,\n      options\n    )\n  }\n}\n\nexport function pushable <T> (): Pushable<T> {\n  return new QueuelessPushable<T>()\n}\n", "/**\n * @packageDocumentation\n *\n * This module makes it easy to send and receive bytes over streams.\n *\n * @example\n *\n * ```typescript\n * import { byteStream } from 'it-byte-stream'\n *\n * const stream = byteStream(duplex)\n *\n * // read the next chunk\n * const bytes = await stream.read()\n *\n * // read the next five bytes\n * const fiveBytes = await stream.read(5)\n *\n * // write bytes into the stream\n * await stream.write(Uint8Array.from([0, 1, 2, 3, 4]))\n * ```\n */\n\nimport { Uint8ArrayList } from 'uint8arraylist'\nimport { pushable } from './pushable.js'\nimport type { Duplex } from 'it-stream-types'\n\nexport class CodeError extends Error {\n  public readonly code: string\n\n  constructor (message: string, code: string) {\n    super(message)\n    this.code = code\n  }\n}\n\nexport class AbortError extends CodeError {\n  public readonly type: string\n\n  constructor (message: string) {\n    super(message, 'ABORT_ERR')\n    this.type = 'aborted'\n  }\n}\n\nexport interface AbortOptions {\n  signal?: AbortSignal\n}\n\nexport interface ByteStream <Stream = unknown> {\n  /**\n   * Read a set number of bytes from the stream\n   */\n  read(bytes?: number, options?: AbortOptions): Promise<Uint8ArrayList>\n\n  /**\n   * Write the passed bytes to the stream\n   */\n  write(input: Uint8Array | Uint8ArrayList, options?: AbortOptions): Promise<void>\n\n  /**\n   * Returns the underlying stream\n   */\n  unwrap(): Stream\n}\n\nexport interface ByteStreamOpts {\n  /**\n   * After the stream is unwrapped, any bytes that have been read from the\n   * incoming stream will be yielded in-order as `Uint8Array`(s).\n   *\n   * To yield a single `Uint8ArrayList` with all unread bytes instead, pass\n   * `false` here.\n   */\n  yieldBytes?: boolean\n}\n\nexport function byteStream <Stream extends Duplex<any, any, any>> (duplex: Stream, opts?: ByteStreamOpts): ByteStream<Stream> {\n  const write = pushable()\n\n  duplex.sink(write).catch(async (err: Error) => {\n    await write.end(err)\n  })\n\n  duplex.sink = async (source: any) => {\n    for await (const buf of source) {\n      await write.push(buf)\n    }\n\n    await write.end()\n  }\n\n  let source = duplex.source\n\n  if (duplex.source[Symbol.iterator] != null) {\n    source = duplex.source[Symbol.iterator]()\n  } else if (duplex.source[Symbol.asyncIterator] != null) {\n    source = duplex.source[Symbol.asyncIterator]()\n  }\n\n  const readBuffer = new Uint8ArrayList()\n\n  const W: ByteStream<Stream> = {\n    read: async (bytes?: number, options?: AbortOptions) => {\n      options?.signal?.throwIfAborted()\n\n      let listener: EventListener | undefined\n\n      const abortPromise = new Promise((resolve, reject) => {\n        listener = () => {\n          reject(new AbortError('Read aborted'))\n        }\n\n        options?.signal?.addEventListener('abort', listener)\n      })\n\n      try {\n        if (bytes == null) {\n          // just read whatever arrives\n          const { done, value } = await Promise.race([\n            source.next(),\n            abortPromise\n          ])\n\n          if (done === true) {\n            return new Uint8ArrayList()\n          }\n\n          return value\n        }\n\n        while (readBuffer.byteLength < bytes) {\n          const { value, done } = await Promise.race([\n            source.next(),\n            abortPromise\n          ])\n\n          if (done === true) {\n            throw new CodeError('unexpected end of input', 'ERR_UNEXPECTED_EOF')\n          }\n\n          readBuffer.append(value)\n        }\n\n        const buf = readBuffer.sublist(0, bytes)\n        readBuffer.consume(bytes)\n\n        return buf\n      } finally {\n        if (listener != null) {\n          options?.signal?.removeEventListener('abort', listener)\n        }\n      }\n    },\n    write: async (data, options?: AbortOptions) => {\n      options?.signal?.throwIfAborted()\n\n      // just write\n      if (data instanceof Uint8Array) {\n        await write.push(data, options)\n      } else {\n        await write.push(data.subarray(), options)\n      }\n    },\n    unwrap: () => {\n      if (readBuffer.byteLength > 0) {\n        const originalStream = duplex.source\n        duplex.source = (async function * () {\n          if (opts?.yieldBytes === false) {\n            yield readBuffer\n          } else {\n            yield * readBuffer\n          }\n\n          yield * originalStream\n        }())\n      }\n\n      return duplex\n    }\n  }\n\n  return W\n}\n", "/**\n * @packageDocumentation\n *\n * This module makes it easy to send and receive length-prefixed byte arrays over streams.\n *\n * @example\n *\n * ```typescript\n * import { lpStream } from 'it-length-prefixed-stream'\n *\n * const stream = lpStream(duplex)\n *\n * // read the next length-prefixed chunk\n * const bytes = await stream.read()\n *\n * // write a length-prefixed chunk\n * await stream.write(Uint8Array.from([0, 1, 2, 3, 4]))\n *\n * // write several chunks, all individually length-prefixed\n * await stream.writeV([\n *   Uint8Array.from([0, 1, 2, 3, 4]),\n *   Uint8Array.from([5, 6, 7, 8, 9])\n * ])\n * ```\n */\nimport { byteStream, type ByteStreamOpts } from 'it-byte-stream'\nimport * as varint from 'uint8-varint'\nimport { Uint8ArrayList } from 'uint8arraylist'\nimport type { Duplex } from 'it-stream-types'\n\nclass CodeError extends Error {\n  public readonly code: string\n\n  constructor (message: string, code: string) {\n    super(message)\n    this.code = code\n  }\n}\n\nexport interface AbortOptions {\n  signal?: AbortSignal\n}\n\nexport interface LengthPrefixedStream <Stream = unknown> {\n  /**\n   * Read the next length-prefixed number of bytes from the stream\n   */\n  read(options?: AbortOptions): Promise<Uint8ArrayList>\n\n  /**\n   * Write the passed bytes to the stream prefixed by their length\n   */\n  write(input: Uint8Array | Uint8ArrayList, options?: AbortOptions): Promise<void>\n\n  /**\n   * Write passed list of bytes, prefix by their individual lengths to the stream as a single write\n   */\n  writeV(input: Array<Uint8Array | Uint8ArrayList>, options?: AbortOptions): Promise<void>\n\n  /**\n   * Returns the underlying stream\n   */\n  unwrap(): Stream\n}\n\nexport interface LengthPrefixedStreamOpts extends ByteStreamOpts {\n  // encoding opts\n  lengthEncoder (value: number): Uint8ArrayList | Uint8Array\n\n  // decoding opts\n  lengthDecoder (data: Uint8ArrayList): number\n  maxLengthLength: number\n  maxDataLength: number\n}\n\nexport function lpStream <Stream extends Duplex<any, any, any>> (duplex: Stream, opts: Partial<LengthPrefixedStreamOpts> = {}): LengthPrefixedStream<Stream> {\n  const bytes = byteStream(duplex, opts)\n\n  if (opts.maxDataLength != null && opts.maxLengthLength == null) {\n    // if max data length is set but max length length is not, calculate the\n    // max length length needed to encode max data length\n    opts.maxLengthLength = varint.encodingLength(opts.maxDataLength)\n  }\n\n  const decodeLength = opts?.lengthDecoder ?? varint.decode\n  const encodeLength = opts?.lengthEncoder ?? varint.encode\n\n  const W: LengthPrefixedStream<Stream> = {\n    read: async (options?: AbortOptions) => {\n      let dataLength: number = -1\n      const lengthBuffer = new Uint8ArrayList()\n\n      while (true) {\n        // read one byte at a time until we can decode a varint\n        lengthBuffer.append(await bytes.read(1, options))\n\n        try {\n          dataLength = decodeLength(lengthBuffer)\n        } catch (err) {\n          if (err instanceof RangeError) {\n            continue\n          }\n\n          throw err\n        }\n\n        if (opts?.maxLengthLength != null && lengthBuffer.byteLength > opts.maxLengthLength) {\n          throw new CodeError('message length length too long', 'ERR_MSG_LENGTH_TOO_LONG')\n        }\n\n        if (dataLength > -1) {\n          break\n        }\n      }\n\n      if (opts?.maxDataLength != null && dataLength > opts.maxDataLength) {\n        throw new CodeError('message length too long', 'ERR_MSG_DATA_TOO_LONG')\n      }\n\n      return bytes.read(dataLength, options)\n    },\n    write: async (data, options?: AbortOptions) => {\n      // encode, write\n      await bytes.write(new Uint8ArrayList(encodeLength(data.byteLength), data), options)\n    },\n    writeV: async (data, options?: AbortOptions) => {\n      const list = new Uint8ArrayList(\n        ...data.flatMap(buf => ([encodeLength(buf.byteLength), buf]))\n      )\n\n      // encode, write\n      await bytes.write(list, options)\n    },\n    unwrap: () => {\n      return bytes.unwrap()\n    }\n  }\n\n  return W\n}\n"],
  "mappings": "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",
  "names": ["source", "CodeError"]
}
