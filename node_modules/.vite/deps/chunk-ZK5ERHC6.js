import {
  multiaddr
} from "./chunk-YDXGPUQ5.js";

// node_modules/@multiformats/mafmt/dist/src/index.js
var DNS4 = base("dns4");
var DNS6 = base("dns6");
var DNSADDR = base("dnsaddr");
var DNS = or(base("dns"), DNSADDR, DNS4, DNS6);
var IP = or(base("ip4"), base("ip6"));
var TCP = or(and(IP, base("tcp")), and(DNS, base("tcp")));
var UDP = and(IP, base("udp"));
var UTP = and(UDP, base("utp"));
var QUIC = and(UDP, base("quic"));
var QUICV1 = and(UDP, base("quic-v1"));
var _WebSockets = or(and(TCP, base("ws")), and(DNS, base("ws")));
var WebSockets = or(and(_WebSockets, base("p2p")), _WebSockets);
var _WebSocketsSecure = or(and(TCP, base("wss")), and(DNS, base("wss")), and(TCP, base("tls"), base("ws")), and(DNS, base("tls"), base("ws")));
var WebSocketsSecure = or(and(_WebSocketsSecure, base("p2p")), _WebSocketsSecure);
var HTTP = or(and(TCP, base("http")), and(IP, base("http")), and(DNS, base("http")));
var HTTPS = or(and(TCP, base("https")), and(IP, base("https")), and(DNS, base("https")));
var _WebRTCDirect = and(UDP, base("webrtc-direct"), base("certhash"));
var WebRTCDirect = or(and(_WebRTCDirect, base("p2p")), _WebRTCDirect);
var _WebTransport = and(QUICV1, base("webtransport"), base("certhash"), base("certhash"));
var WebTransport = or(and(_WebTransport, base("p2p")), _WebTransport);
var P2PWebRTCStar = or(and(WebSockets, base("p2p-webrtc-star"), base("p2p")), and(WebSocketsSecure, base("p2p-webrtc-star"), base("p2p")), and(WebSockets, base("p2p-webrtc-star")), and(WebSocketsSecure, base("p2p-webrtc-star")));
var WebSocketStar = or(and(WebSockets, base("p2p-websocket-star"), base("p2p")), and(WebSocketsSecure, base("p2p-websocket-star"), base("p2p")), and(WebSockets, base("p2p-websocket-star")), and(WebSocketsSecure, base("p2p-websocket-star")));
var P2PWebRTCDirect = or(and(HTTP, base("p2p-webrtc-direct"), base("p2p")), and(HTTPS, base("p2p-webrtc-direct"), base("p2p")), and(HTTP, base("p2p-webrtc-direct")), and(HTTPS, base("p2p-webrtc-direct")));
var Reliable = or(_WebSockets, _WebSocketsSecure, HTTP, HTTPS, P2PWebRTCStar, P2PWebRTCDirect, TCP, UTP, QUIC, DNS, WebRTCDirect, WebTransport);
var Stardust = or(and(Reliable, base("p2p-stardust"), base("p2p")), and(Reliable, base("p2p-stardust")));
var _P2P = or(and(Reliable, base("p2p")), P2PWebRTCStar, P2PWebRTCDirect, WebRTCDirect, WebTransport, base("p2p"));
var _Circuit = or(and(_P2P, base("p2p-circuit"), _P2P), and(_P2P, base("p2p-circuit")), and(base("p2p-circuit"), _P2P), and(Reliable, base("p2p-circuit")), and(base("p2p-circuit"), Reliable), base("p2p-circuit"));
var CircuitRecursive = () => or(and(_Circuit, CircuitRecursive), _Circuit);
var Circuit = CircuitRecursive();
var P2P = or(and(Circuit, _P2P, Circuit), and(_P2P, Circuit), and(Circuit, _P2P), Circuit, _P2P);
var WebRTC = or(and(Circuit, base("webrtc"), base("p2p")), and(Circuit, base("webrtc")), and(Reliable, base("webrtc"), base("p2p")), and(Reliable, base("webrtc")), base("webrtc"));
function makeMatchesFunction(partialMatch) {
  function matches(a) {
    let ma;
    try {
      ma = multiaddr(a);
    } catch (err) {
      return false;
    }
    const out = partialMatch(ma.protoNames());
    if (out === null) {
      return false;
    }
    if (out === true || out === false) {
      return out;
    }
    return out.length === 0;
  }
  return matches;
}
function and(...args) {
  function partialMatch(a) {
    if (a.length < args.length) {
      return null;
    }
    let out = a;
    args.some((arg) => {
      out = typeof arg === "function" ? arg().partialMatch(a) : arg.partialMatch(a);
      if (Array.isArray(out)) {
        a = out;
      }
      if (out === null) {
        return true;
      }
      return false;
    });
    return out;
  }
  return {
    toString: function() {
      return "{ " + args.join(" ") + " }";
    },
    input: args,
    matches: makeMatchesFunction(partialMatch),
    partialMatch
  };
}
function or(...args) {
  function partialMatch(a) {
    let out = null;
    args.some((arg) => {
      const res = typeof arg === "function" ? arg().partialMatch(a) : arg.partialMatch(a);
      if (res != null) {
        out = res;
        return true;
      }
      return false;
    });
    return out;
  }
  const result = {
    toString: function() {
      return "{ " + args.join(" ") + " }";
    },
    input: args,
    matches: makeMatchesFunction(partialMatch),
    partialMatch
  };
  return result;
}
function base(n) {
  const name = n;
  function matches(a) {
    let ma;
    try {
      ma = multiaddr(a);
    } catch (err) {
      return false;
    }
    const pnames = ma.protoNames();
    if (pnames.length === 1 && pnames[0] === name) {
      return true;
    }
    return false;
  }
  function partialMatch(protos) {
    if (protos.length === 0) {
      return null;
    }
    if (protos[0] === name) {
      return protos.slice(1);
    }
    return null;
  }
  return {
    toString: function() {
      return name;
    },
    matches,
    partialMatch
  };
}

export {
  DNS,
  WebSockets,
  WebSocketsSecure,
  Circuit
};
//# sourceMappingURL=chunk-ZK5ERHC6.js.map
