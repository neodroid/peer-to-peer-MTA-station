import {
  PeerMap,
  PeerQueue,
  anySignal
} from "./chunk-BIAJMC7X.js";
import "./chunk-A26ZRYK3.js";
import {
  RecordEnvelope
} from "./chunk-ML4RWVAO.js";
import "./chunk-E4JTUZPO.js";
import {
  pbStream
} from "./chunk-Z2JWY6QB.js";
import "./chunk-WI4NAQ2P.js";
import "./chunk-3W5ODUXV.js";
import "./chunk-HCKUFEZV.js";
import {
  peerIdFromBytes,
  peerIdFromString
} from "./chunk-MUJBFYE2.js";
import {
  decodeMessage,
  encodeMessage,
  enumeration,
  message
} from "./chunk-TAPWQVFO.js";
import "./chunk-SHVKZIHG.js";
import {
  Circuit
} from "./chunk-ZK5ERHC6.js";
import {
  pDefer
} from "./chunk-GYD5GS2D.js";
import {
  multiaddr
} from "./chunk-YDXGPUQ5.js";
import "./chunk-5LRH4A7Q.js";
import "./chunk-JLOXJLWY.js";
import {
  CID,
  sha256
} from "./chunk-P6Z4FGVE.js";
import {
  CodeError,
  TypedEventEmitter,
  setMaxListeners,
  transportSymbol
} from "./chunk-Q7O7U65G.js";
import {
  __commonJS,
  __toESM,
  equals
} from "./chunk-NNBXUUFX.js";

// node_modules/retry/lib/retry_operation.js
var require_retry_operation = __commonJS({
  "node_modules/retry/lib/retry_operation.js"(exports, module) {
    function RetryOperation(timeouts, options) {
      if (typeof options === "boolean") {
        options = { forever: options };
      }
      this._originalTimeouts = JSON.parse(JSON.stringify(timeouts));
      this._timeouts = timeouts;
      this._options = options || {};
      this._maxRetryTime = options && options.maxRetryTime || Infinity;
      this._fn = null;
      this._errors = [];
      this._attempts = 1;
      this._operationTimeout = null;
      this._operationTimeoutCb = null;
      this._timeout = null;
      this._operationStart = null;
      this._timer = null;
      if (this._options.forever) {
        this._cachedTimeouts = this._timeouts.slice(0);
      }
    }
    module.exports = RetryOperation;
    RetryOperation.prototype.reset = function() {
      this._attempts = 1;
      this._timeouts = this._originalTimeouts.slice(0);
    };
    RetryOperation.prototype.stop = function() {
      if (this._timeout) {
        clearTimeout(this._timeout);
      }
      if (this._timer) {
        clearTimeout(this._timer);
      }
      this._timeouts = [];
      this._cachedTimeouts = null;
    };
    RetryOperation.prototype.retry = function(err) {
      if (this._timeout) {
        clearTimeout(this._timeout);
      }
      if (!err) {
        return false;
      }
      var currentTime = (/* @__PURE__ */ new Date()).getTime();
      if (err && currentTime - this._operationStart >= this._maxRetryTime) {
        this._errors.push(err);
        this._errors.unshift(new Error("RetryOperation timeout occurred"));
        return false;
      }
      this._errors.push(err);
      var timeout = this._timeouts.shift();
      if (timeout === void 0) {
        if (this._cachedTimeouts) {
          this._errors.splice(0, this._errors.length - 1);
          timeout = this._cachedTimeouts.slice(-1);
        } else {
          return false;
        }
      }
      var self = this;
      this._timer = setTimeout(function() {
        self._attempts++;
        if (self._operationTimeoutCb) {
          self._timeout = setTimeout(function() {
            self._operationTimeoutCb(self._attempts);
          }, self._operationTimeout);
          if (self._options.unref) {
            self._timeout.unref();
          }
        }
        self._fn(self._attempts);
      }, timeout);
      if (this._options.unref) {
        this._timer.unref();
      }
      return true;
    };
    RetryOperation.prototype.attempt = function(fn, timeoutOps) {
      this._fn = fn;
      if (timeoutOps) {
        if (timeoutOps.timeout) {
          this._operationTimeout = timeoutOps.timeout;
        }
        if (timeoutOps.cb) {
          this._operationTimeoutCb = timeoutOps.cb;
        }
      }
      var self = this;
      if (this._operationTimeoutCb) {
        this._timeout = setTimeout(function() {
          self._operationTimeoutCb();
        }, self._operationTimeout);
      }
      this._operationStart = (/* @__PURE__ */ new Date()).getTime();
      this._fn(this._attempts);
    };
    RetryOperation.prototype.try = function(fn) {
      console.log("Using RetryOperation.try() is deprecated");
      this.attempt(fn);
    };
    RetryOperation.prototype.start = function(fn) {
      console.log("Using RetryOperation.start() is deprecated");
      this.attempt(fn);
    };
    RetryOperation.prototype.start = RetryOperation.prototype.try;
    RetryOperation.prototype.errors = function() {
      return this._errors;
    };
    RetryOperation.prototype.attempts = function() {
      return this._attempts;
    };
    RetryOperation.prototype.mainError = function() {
      if (this._errors.length === 0) {
        return null;
      }
      var counts = {};
      var mainError = null;
      var mainErrorCount = 0;
      for (var i = 0; i < this._errors.length; i++) {
        var error = this._errors[i];
        var message2 = error.message;
        var count = (counts[message2] || 0) + 1;
        counts[message2] = count;
        if (count >= mainErrorCount) {
          mainError = error;
          mainErrorCount = count;
        }
      }
      return mainError;
    };
  }
});

// node_modules/retry/lib/retry.js
var require_retry = __commonJS({
  "node_modules/retry/lib/retry.js"(exports) {
    var RetryOperation = require_retry_operation();
    exports.operation = function(options) {
      var timeouts = exports.timeouts(options);
      return new RetryOperation(timeouts, {
        forever: options && (options.forever || options.retries === Infinity),
        unref: options && options.unref,
        maxRetryTime: options && options.maxRetryTime
      });
    };
    exports.timeouts = function(options) {
      if (options instanceof Array) {
        return [].concat(options);
      }
      var opts = {
        retries: 10,
        factor: 2,
        minTimeout: 1 * 1e3,
        maxTimeout: Infinity,
        randomize: false
      };
      for (var key in options) {
        opts[key] = options[key];
      }
      if (opts.minTimeout > opts.maxTimeout) {
        throw new Error("minTimeout is greater than maxTimeout");
      }
      var timeouts = [];
      for (var i = 0; i < opts.retries; i++) {
        timeouts.push(this.createTimeout(i, opts));
      }
      if (options && options.forever && !timeouts.length) {
        timeouts.push(this.createTimeout(i, opts));
      }
      timeouts.sort(function(a, b) {
        return a - b;
      });
      return timeouts;
    };
    exports.createTimeout = function(attempt, opts) {
      var random = opts.randomize ? Math.random() + 1 : 1;
      var timeout = Math.round(random * Math.max(opts.minTimeout, 1) * Math.pow(opts.factor, attempt));
      timeout = Math.min(timeout, opts.maxTimeout);
      return timeout;
    };
    exports.wrap = function(obj, options, methods) {
      if (options instanceof Array) {
        methods = options;
        options = null;
      }
      if (!methods) {
        methods = [];
        for (var key in obj) {
          if (typeof obj[key] === "function") {
            methods.push(key);
          }
        }
      }
      for (var i = 0; i < methods.length; i++) {
        var method = methods[i];
        var original = obj[method];
        obj[method] = function retryWrapper(original2) {
          var op = exports.operation(options);
          var args = Array.prototype.slice.call(arguments, 1);
          var callback = args.pop();
          args.push(function(err) {
            if (op.retry(err)) {
              return;
            }
            if (err) {
              arguments[0] = op.mainError();
            }
            callback.apply(this, arguments);
          });
          op.attempt(function() {
            original2.apply(obj, args);
          });
        }.bind(obj, original);
        obj[method].options = options;
      }
    };
  }
});

// node_modules/retry/index.js
var require_retry2 = __commonJS({
  "node_modules/retry/index.js"(exports, module) {
    module.exports = require_retry();
  }
});

// node_modules/@libp2p/circuit-relay-v2/dist/src/constants.js
var second = 1e3;
var minute = 60 * second;
var ADVERTISE_BOOT_DELAY = 15 * minute;
var ADVERTISE_TTL = 30 * minute;
var CIRCUIT_PROTO_CODE = 290;
var RELAY_RENDEZVOUS_NS = "/libp2p/relay";
var DEFAULT_MAX_RESERVATION_STORE_SIZE = 15;
var DEFAULT_MAX_RESERVATION_CLEAR_INTERVAL = 300 * second;
var DEFAULT_MAX_RESERVATION_TTL = 2 * 60 * minute;
var DEFAULT_RESERVATION_CONCURRENCY = 1;
var RELAY_SOURCE_TAG = "circuit-relay-source";
var RELAY_TAG = "circuit-relay-relay";
var DEFAULT_DURATION_LIMIT = 2 * minute;
var DEFAULT_DATA_LIMIT = BigInt(1 << 17);
var RELAY_V2_HOP_CODEC = "/libp2p/circuit/relay/0.2.0/hop";
var RELAY_V2_STOP_CODEC = "/libp2p/circuit/relay/0.2.0/stop";
var DEFAULT_HOP_TIMEOUT = 30 * second;
var DEFAULT_ADVERT_BOOT_DELAY = 30 * second;
var MAX_CONNECTIONS = 300;
var ERR_NO_ROUTERS_AVAILABLE = "ERR_NO_ROUTERS_AVAILABLE";
var ERR_RELAYED_DIAL = "ERR_RELAYED_DIAL";
var ERR_HOP_REQUEST_FAILED = "ERR_HOP_REQUEST_FAILED";
var ERR_TRANSFER_LIMIT_EXCEEDED = "ERR_TRANSFER_LIMIT_EXCEEDED";

// node_modules/@libp2p/circuit-relay-v2/dist/src/pb/index.js
var HopMessage;
(function(HopMessage2) {
  let Type;
  (function(Type2) {
    Type2["RESERVE"] = "RESERVE";
    Type2["CONNECT"] = "CONNECT";
    Type2["STATUS"] = "STATUS";
  })(Type = HopMessage2.Type || (HopMessage2.Type = {}));
  let __TypeValues;
  (function(__TypeValues2) {
    __TypeValues2[__TypeValues2["RESERVE"] = 0] = "RESERVE";
    __TypeValues2[__TypeValues2["CONNECT"] = 1] = "CONNECT";
    __TypeValues2[__TypeValues2["STATUS"] = 2] = "STATUS";
  })(__TypeValues || (__TypeValues = {}));
  (function(Type2) {
    Type2.codec = () => {
      return enumeration(__TypeValues);
    };
  })(Type = HopMessage2.Type || (HopMessage2.Type = {}));
  let _codec;
  HopMessage2.codec = () => {
    if (_codec == null) {
      _codec = message((obj, w, opts = {}) => {
        if (opts.lengthDelimited !== false) {
          w.fork();
        }
        if (obj.type != null) {
          w.uint32(8);
          HopMessage2.Type.codec().encode(obj.type, w);
        }
        if (obj.peer != null) {
          w.uint32(18);
          Peer.codec().encode(obj.peer, w);
        }
        if (obj.reservation != null) {
          w.uint32(26);
          Reservation.codec().encode(obj.reservation, w);
        }
        if (obj.limit != null) {
          w.uint32(34);
          Limit.codec().encode(obj.limit, w);
        }
        if (obj.status != null) {
          w.uint32(40);
          Status.codec().encode(obj.status, w);
        }
        if (opts.lengthDelimited !== false) {
          w.ldelim();
        }
      }, (reader, length) => {
        const obj = {};
        const end = length == null ? reader.len : reader.pos + length;
        while (reader.pos < end) {
          const tag = reader.uint32();
          switch (tag >>> 3) {
            case 1:
              obj.type = HopMessage2.Type.codec().decode(reader);
              break;
            case 2:
              obj.peer = Peer.codec().decode(reader, reader.uint32());
              break;
            case 3:
              obj.reservation = Reservation.codec().decode(reader, reader.uint32());
              break;
            case 4:
              obj.limit = Limit.codec().decode(reader, reader.uint32());
              break;
            case 5:
              obj.status = Status.codec().decode(reader);
              break;
            default:
              reader.skipType(tag & 7);
              break;
          }
        }
        return obj;
      });
    }
    return _codec;
  };
  HopMessage2.encode = (obj) => {
    return encodeMessage(obj, HopMessage2.codec());
  };
  HopMessage2.decode = (buf) => {
    return decodeMessage(buf, HopMessage2.codec());
  };
})(HopMessage || (HopMessage = {}));
var StopMessage;
(function(StopMessage2) {
  let Type;
  (function(Type2) {
    Type2["CONNECT"] = "CONNECT";
    Type2["STATUS"] = "STATUS";
  })(Type = StopMessage2.Type || (StopMessage2.Type = {}));
  let __TypeValues;
  (function(__TypeValues2) {
    __TypeValues2[__TypeValues2["CONNECT"] = 0] = "CONNECT";
    __TypeValues2[__TypeValues2["STATUS"] = 1] = "STATUS";
  })(__TypeValues || (__TypeValues = {}));
  (function(Type2) {
    Type2.codec = () => {
      return enumeration(__TypeValues);
    };
  })(Type = StopMessage2.Type || (StopMessage2.Type = {}));
  let _codec;
  StopMessage2.codec = () => {
    if (_codec == null) {
      _codec = message((obj, w, opts = {}) => {
        if (opts.lengthDelimited !== false) {
          w.fork();
        }
        if (obj.type != null) {
          w.uint32(8);
          StopMessage2.Type.codec().encode(obj.type, w);
        }
        if (obj.peer != null) {
          w.uint32(18);
          Peer.codec().encode(obj.peer, w);
        }
        if (obj.limit != null) {
          w.uint32(26);
          Limit.codec().encode(obj.limit, w);
        }
        if (obj.status != null) {
          w.uint32(32);
          Status.codec().encode(obj.status, w);
        }
        if (opts.lengthDelimited !== false) {
          w.ldelim();
        }
      }, (reader, length) => {
        const obj = {};
        const end = length == null ? reader.len : reader.pos + length;
        while (reader.pos < end) {
          const tag = reader.uint32();
          switch (tag >>> 3) {
            case 1:
              obj.type = StopMessage2.Type.codec().decode(reader);
              break;
            case 2:
              obj.peer = Peer.codec().decode(reader, reader.uint32());
              break;
            case 3:
              obj.limit = Limit.codec().decode(reader, reader.uint32());
              break;
            case 4:
              obj.status = Status.codec().decode(reader);
              break;
            default:
              reader.skipType(tag & 7);
              break;
          }
        }
        return obj;
      });
    }
    return _codec;
  };
  StopMessage2.encode = (obj) => {
    return encodeMessage(obj, StopMessage2.codec());
  };
  StopMessage2.decode = (buf) => {
    return decodeMessage(buf, StopMessage2.codec());
  };
})(StopMessage || (StopMessage = {}));
var Peer;
(function(Peer2) {
  let _codec;
  Peer2.codec = () => {
    if (_codec == null) {
      _codec = message((obj, w, opts = {}) => {
        if (opts.lengthDelimited !== false) {
          w.fork();
        }
        if (obj.id != null && obj.id.byteLength > 0) {
          w.uint32(10);
          w.bytes(obj.id);
        }
        if (obj.addrs != null) {
          for (const value of obj.addrs) {
            w.uint32(18);
            w.bytes(value);
          }
        }
        if (opts.lengthDelimited !== false) {
          w.ldelim();
        }
      }, (reader, length) => {
        const obj = {
          id: new Uint8Array(0),
          addrs: []
        };
        const end = length == null ? reader.len : reader.pos + length;
        while (reader.pos < end) {
          const tag = reader.uint32();
          switch (tag >>> 3) {
            case 1:
              obj.id = reader.bytes();
              break;
            case 2:
              obj.addrs.push(reader.bytes());
              break;
            default:
              reader.skipType(tag & 7);
              break;
          }
        }
        return obj;
      });
    }
    return _codec;
  };
  Peer2.encode = (obj) => {
    return encodeMessage(obj, Peer2.codec());
  };
  Peer2.decode = (buf) => {
    return decodeMessage(buf, Peer2.codec());
  };
})(Peer || (Peer = {}));
var Reservation;
(function(Reservation2) {
  let _codec;
  Reservation2.codec = () => {
    if (_codec == null) {
      _codec = message((obj, w, opts = {}) => {
        if (opts.lengthDelimited !== false) {
          w.fork();
        }
        if (obj.expire != null && obj.expire !== 0n) {
          w.uint32(8);
          w.uint64(obj.expire);
        }
        if (obj.addrs != null) {
          for (const value of obj.addrs) {
            w.uint32(18);
            w.bytes(value);
          }
        }
        if (obj.voucher != null) {
          w.uint32(26);
          w.bytes(obj.voucher);
        }
        if (opts.lengthDelimited !== false) {
          w.ldelim();
        }
      }, (reader, length) => {
        const obj = {
          expire: 0n,
          addrs: []
        };
        const end = length == null ? reader.len : reader.pos + length;
        while (reader.pos < end) {
          const tag = reader.uint32();
          switch (tag >>> 3) {
            case 1:
              obj.expire = reader.uint64();
              break;
            case 2:
              obj.addrs.push(reader.bytes());
              break;
            case 3:
              obj.voucher = reader.bytes();
              break;
            default:
              reader.skipType(tag & 7);
              break;
          }
        }
        return obj;
      });
    }
    return _codec;
  };
  Reservation2.encode = (obj) => {
    return encodeMessage(obj, Reservation2.codec());
  };
  Reservation2.decode = (buf) => {
    return decodeMessage(buf, Reservation2.codec());
  };
})(Reservation || (Reservation = {}));
var Limit;
(function(Limit2) {
  let _codec;
  Limit2.codec = () => {
    if (_codec == null) {
      _codec = message((obj, w, opts = {}) => {
        if (opts.lengthDelimited !== false) {
          w.fork();
        }
        if (obj.duration != null) {
          w.uint32(8);
          w.uint32(obj.duration);
        }
        if (obj.data != null) {
          w.uint32(16);
          w.uint64(obj.data);
        }
        if (opts.lengthDelimited !== false) {
          w.ldelim();
        }
      }, (reader, length) => {
        const obj = {};
        const end = length == null ? reader.len : reader.pos + length;
        while (reader.pos < end) {
          const tag = reader.uint32();
          switch (tag >>> 3) {
            case 1:
              obj.duration = reader.uint32();
              break;
            case 2:
              obj.data = reader.uint64();
              break;
            default:
              reader.skipType(tag & 7);
              break;
          }
        }
        return obj;
      });
    }
    return _codec;
  };
  Limit2.encode = (obj) => {
    return encodeMessage(obj, Limit2.codec());
  };
  Limit2.decode = (buf) => {
    return decodeMessage(buf, Limit2.codec());
  };
})(Limit || (Limit = {}));
var Status;
(function(Status2) {
  Status2["UNUSED"] = "UNUSED";
  Status2["OK"] = "OK";
  Status2["RESERVATION_REFUSED"] = "RESERVATION_REFUSED";
  Status2["RESOURCE_LIMIT_EXCEEDED"] = "RESOURCE_LIMIT_EXCEEDED";
  Status2["PERMISSION_DENIED"] = "PERMISSION_DENIED";
  Status2["CONNECTION_FAILED"] = "CONNECTION_FAILED";
  Status2["NO_RESERVATION"] = "NO_RESERVATION";
  Status2["MALFORMED_MESSAGE"] = "MALFORMED_MESSAGE";
  Status2["UNEXPECTED_MESSAGE"] = "UNEXPECTED_MESSAGE";
})(Status || (Status = {}));
var __StatusValues;
(function(__StatusValues2) {
  __StatusValues2[__StatusValues2["UNUSED"] = 0] = "UNUSED";
  __StatusValues2[__StatusValues2["OK"] = 100] = "OK";
  __StatusValues2[__StatusValues2["RESERVATION_REFUSED"] = 200] = "RESERVATION_REFUSED";
  __StatusValues2[__StatusValues2["RESOURCE_LIMIT_EXCEEDED"] = 201] = "RESOURCE_LIMIT_EXCEEDED";
  __StatusValues2[__StatusValues2["PERMISSION_DENIED"] = 202] = "PERMISSION_DENIED";
  __StatusValues2[__StatusValues2["CONNECTION_FAILED"] = 203] = "CONNECTION_FAILED";
  __StatusValues2[__StatusValues2["NO_RESERVATION"] = 204] = "NO_RESERVATION";
  __StatusValues2[__StatusValues2["MALFORMED_MESSAGE"] = 400] = "MALFORMED_MESSAGE";
  __StatusValues2[__StatusValues2["UNEXPECTED_MESSAGE"] = 401] = "UNEXPECTED_MESSAGE";
})(__StatusValues || (__StatusValues = {}));
(function(Status2) {
  Status2.codec = () => {
    return enumeration(__StatusValues);
  };
})(Status || (Status = {}));
var ReservationVoucher;
(function(ReservationVoucher2) {
  let _codec;
  ReservationVoucher2.codec = () => {
    if (_codec == null) {
      _codec = message((obj, w, opts = {}) => {
        if (opts.lengthDelimited !== false) {
          w.fork();
        }
        if (obj.relay != null && obj.relay.byteLength > 0) {
          w.uint32(10);
          w.bytes(obj.relay);
        }
        if (obj.peer != null && obj.peer.byteLength > 0) {
          w.uint32(18);
          w.bytes(obj.peer);
        }
        if (obj.expiration != null && obj.expiration !== 0n) {
          w.uint32(24);
          w.uint64(obj.expiration);
        }
        if (opts.lengthDelimited !== false) {
          w.ldelim();
        }
      }, (reader, length) => {
        const obj = {
          relay: new Uint8Array(0),
          peer: new Uint8Array(0),
          expiration: 0n
        };
        const end = length == null ? reader.len : reader.pos + length;
        while (reader.pos < end) {
          const tag = reader.uint32();
          switch (tag >>> 3) {
            case 1:
              obj.relay = reader.bytes();
              break;
            case 2:
              obj.peer = reader.bytes();
              break;
            case 3:
              obj.expiration = reader.uint64();
              break;
            default:
              reader.skipType(tag & 7);
              break;
          }
        }
        return obj;
      });
    }
    return _codec;
  };
  ReservationVoucher2.encode = (obj) => {
    return encodeMessage(obj, ReservationVoucher2.codec());
  };
  ReservationVoucher2.decode = (buf) => {
    return decodeMessage(buf, ReservationVoucher2.codec());
  };
})(ReservationVoucher || (ReservationVoucher = {}));

// node_modules/@libp2p/circuit-relay-v2/dist/src/utils.js
async function* countStreamBytes(source, limit, options) {
  const limitBytes = limit.remaining;
  for await (const buf of source) {
    const len = BigInt(buf.byteLength);
    if (limit.remaining - len < 0) {
      const remaining = Number(limit.remaining);
      limit.remaining = 0n;
      try {
        if (remaining !== 0) {
          yield buf.subarray(0, remaining);
        }
      } catch (err) {
        options.log.error(err);
      }
      throw new CodeError(`data limit of ${limitBytes} bytes exceeded`, ERR_TRANSFER_LIMIT_EXCEEDED);
    }
    limit.remaining -= len;
    yield buf;
  }
}
function createLimitedRelay(src, dst, abortSignal, limit, options) {
  function abortStreams(err) {
    src.abort(err);
    dst.abort(err);
  }
  const signals = [abortSignal];
  if (limit?.duration != null) {
    signals.push(AbortSignal.timeout(limit.duration));
  }
  const signal = anySignal(signals);
  let srcDstFinished = false;
  let dstSrcFinished = false;
  let dataLimit;
  if (limit?.data != null) {
    dataLimit = {
      remaining: limit.data
    };
  }
  queueMicrotask(() => {
    const onAbort = () => {
      dst.abort(new CodeError(`duration limit of ${limit?.duration} ms exceeded`, ERR_TRANSFER_LIMIT_EXCEEDED));
    };
    signal.addEventListener("abort", onAbort, { once: true });
    void dst.sink(dataLimit == null ? src.source : countStreamBytes(src.source, dataLimit, options)).catch((err) => {
      options.log.error("error while relaying streams src -> dst", err);
      abortStreams(err);
    }).finally(() => {
      srcDstFinished = true;
      if (dstSrcFinished) {
        signal.removeEventListener("abort", onAbort);
        signal.clear();
      }
    });
  });
  queueMicrotask(() => {
    const onAbort = () => {
      src.abort(new CodeError(`duration limit of ${limit?.duration} ms exceeded`, ERR_TRANSFER_LIMIT_EXCEEDED));
    };
    signal.addEventListener("abort", onAbort, { once: true });
    void src.sink(dataLimit == null ? dst.source : countStreamBytes(dst.source, dataLimit, options)).catch((err) => {
      options.log.error("error while relaying streams dst -> src", err);
      abortStreams(err);
    }).finally(() => {
      dstSrcFinished = true;
      if (srcDstFinished) {
        signal.removeEventListener("abort", onAbort);
        signal.clear();
      }
    });
  });
}
async function namespaceToCid(namespace) {
  const bytes = new TextEncoder().encode(namespace);
  const hash = await sha256.digest(bytes);
  return CID.createV0(hash);
}
function getExpirationMilliseconds(expireTimeSeconds) {
  const expireTimeMillis = expireTimeSeconds * BigInt(1e3);
  const currentTime = (/* @__PURE__ */ new Date()).getTime();
  return Number(expireTimeMillis - BigInt(currentTime));
}

// node_modules/p-retry/index.js
var import_retry = __toESM(require_retry2());

// node_modules/is-network-error/index.js
var objectToString = Object.prototype.toString;
var isError = (value) => objectToString.call(value) === "[object Error]";
var errorMessages = /* @__PURE__ */ new Set([
  "network error",
  // Chrome
  "Failed to fetch",
  // Chrome
  "NetworkError when attempting to fetch resource.",
  // Firefox
  "The Internet connection appears to be offline.",
  // Safari 16
  "Load failed",
  // Safari 17+
  "Network request failed",
  // `cross-fetch`
  "fetch failed",
  // Undici (Node.js)
  "terminated"
  // Undici (Node.js)
]);
function isNetworkError(error) {
  const isValid = error && isError(error) && error.name === "TypeError" && typeof error.message === "string";
  if (!isValid) {
    return false;
  }
  if (error.message === "Load failed") {
    return error.stack === void 0;
  }
  return errorMessages.has(error.message);
}

// node_modules/p-retry/index.js
var AbortError = class extends Error {
  constructor(message2) {
    super();
    if (message2 instanceof Error) {
      this.originalError = message2;
      ({ message: message2 } = message2);
    } else {
      this.originalError = new Error(message2);
      this.originalError.stack = this.stack;
    }
    this.name = "AbortError";
    this.message = message2;
  }
};
var decorateErrorWithCounts = (error, attemptNumber, options) => {
  const retriesLeft = options.retries - (attemptNumber - 1);
  error.attemptNumber = attemptNumber;
  error.retriesLeft = retriesLeft;
  return error;
};
async function pRetry(input, options) {
  return new Promise((resolve, reject) => {
    options = {
      onFailedAttempt() {
      },
      retries: 10,
      shouldRetry: () => true,
      ...options
    };
    const operation = import_retry.default.operation(options);
    const abortHandler = () => {
      operation.stop();
      reject(options.signal?.reason);
    };
    if (options.signal && !options.signal.aborted) {
      options.signal.addEventListener("abort", abortHandler, { once: true });
    }
    const cleanUp = () => {
      options.signal?.removeEventListener("abort", abortHandler);
      operation.stop();
    };
    operation.attempt(async (attemptNumber) => {
      try {
        const result = await input(attemptNumber);
        cleanUp();
        resolve(result);
      } catch (error) {
        try {
          if (!(error instanceof Error)) {
            throw new TypeError(`Non-error was thrown: "${error}". You should only throw errors.`);
          }
          if (error instanceof AbortError) {
            throw error.originalError;
          }
          if (error instanceof TypeError && !isNetworkError(error)) {
            throw error;
          }
          decorateErrorWithCounts(error, attemptNumber, options);
          if (!await options.shouldRetry(error)) {
            operation.stop();
            reject(error);
          }
          await options.onFailedAttempt(error);
          if (!operation.retry(error)) {
            throw operation.mainError();
          }
        } catch (finalError) {
          decorateErrorWithCounts(finalError, attemptNumber, options);
          cleanUp();
          reject(finalError);
        }
      }
    });
  });
}

// node_modules/@libp2p/circuit-relay-v2/dist/src/server/advert-service.js
var AdvertService = class extends TypedEventEmitter {
  contentRouting;
  timeout;
  started;
  bootDelay;
  log;
  /**
   * Creates an instance of Relay
   */
  constructor(components, init) {
    super();
    this.log = components.logger.forComponent("libp2p:circuit-relay:advert-service");
    this.contentRouting = components.contentRouting;
    this.bootDelay = init?.bootDelay ?? DEFAULT_ADVERT_BOOT_DELAY;
    this.started = false;
  }
  isStarted() {
    return this.started;
  }
  /**
   * Start Relay service
   */
  start() {
    if (this.started) {
      return;
    }
    this.timeout = setTimeout(() => {
      this._advertiseService().catch((err) => {
        this.log.error("could not advertise service", err);
      });
    }, this.bootDelay);
    this.started = true;
  }
  /**
   * Stop Relay service
   */
  stop() {
    try {
      clearTimeout(this.timeout);
    } catch (err) {
    }
    this.started = false;
  }
  /**
   * Advertise hop relay service in the network.
   */
  async _advertiseService() {
    await pRetry(async () => {
      try {
        const cid = await namespaceToCid(RELAY_RENDEZVOUS_NS);
        await this.contentRouting.provide(cid);
        this.safeDispatchEvent("advert:success", { detail: void 0 });
      } catch (err) {
        this.safeDispatchEvent("advert:error", { detail: err });
        if (err.code === ERR_NO_ROUTERS_AVAILABLE) {
          this.log.error("a content router, such as a DHT, must be provided in order to advertise the relay service", err);
          this.stop();
          return;
        }
        this.log.error("could not advertise service", err);
        throw err;
      }
    });
  }
};

// node_modules/@libp2p/circuit-relay-v2/dist/src/server/reservation-store.js
var ReservationStore = class {
  reservations = new PeerMap();
  _started = false;
  interval;
  maxReservations;
  reservationClearInterval;
  applyDefaultLimit;
  reservationTtl;
  defaultDurationLimit;
  defaultDataLimit;
  constructor(options = {}) {
    this.maxReservations = options.maxReservations ?? DEFAULT_MAX_RESERVATION_STORE_SIZE;
    this.reservationClearInterval = options.reservationClearInterval ?? DEFAULT_MAX_RESERVATION_CLEAR_INTERVAL;
    this.applyDefaultLimit = options.applyDefaultLimit !== false;
    this.reservationTtl = options.reservationTtl ?? DEFAULT_MAX_RESERVATION_TTL;
    this.defaultDurationLimit = options.defaultDurationLimit ?? DEFAULT_DURATION_LIMIT;
    this.defaultDataLimit = options.defaultDataLimit ?? DEFAULT_DATA_LIMIT;
  }
  isStarted() {
    return this._started;
  }
  start() {
    if (this._started) {
      return;
    }
    this._started = true;
    this.interval = setInterval(() => {
      const now = (/* @__PURE__ */ new Date()).getTime();
      this.reservations.forEach((r, k) => {
        if (r.expire.getTime() < now) {
          this.reservations.delete(k);
        }
      });
    }, this.reservationClearInterval);
  }
  stop() {
    clearInterval(this.interval);
  }
  reserve(peer, addr, limit) {
    if (this.reservations.size >= this.maxReservations && !this.reservations.has(peer)) {
      return { status: Status.RESERVATION_REFUSED };
    }
    const expire = new Date(Date.now() + this.reservationTtl);
    let checkedLimit;
    if (this.applyDefaultLimit) {
      checkedLimit = limit ?? { data: this.defaultDataLimit, duration: this.defaultDurationLimit };
    }
    this.reservations.set(peer, { addr, expire, limit: checkedLimit });
    return { status: Status.OK, expire: Math.round(expire.getTime() / 1e3) };
  }
  removeReservation(peer) {
    this.reservations.delete(peer);
  }
  hasReservation(dst) {
    return this.reservations.has(dst);
  }
  get(peer) {
    return this.reservations.get(peer);
  }
};

// node_modules/@libp2p/circuit-relay-v2/dist/src/server/reservation-voucher.js
var ReservationVoucherRecord = class _ReservationVoucherRecord {
  domain = "libp2p-relay-rsvp";
  codec = new Uint8Array([3, 2]);
  relay;
  peer;
  expiration;
  constructor({ relay, peer, expiration }) {
    this.relay = relay;
    this.peer = peer;
    this.expiration = expiration;
  }
  marshal() {
    return ReservationVoucher.encode({
      relay: this.relay.toBytes(),
      peer: this.peer.toBytes(),
      expiration: BigInt(this.expiration)
    });
  }
  equals(other) {
    if (!(other instanceof _ReservationVoucherRecord)) {
      return false;
    }
    if (!this.peer.equals(other.peer)) {
      return false;
    }
    if (!this.relay.equals(other.relay)) {
      return false;
    }
    if (this.expiration !== other.expiration) {
      return false;
    }
    return true;
  }
};

// node_modules/@libp2p/circuit-relay-v2/dist/src/server/index.js
var isRelayAddr = (ma) => ma.protoCodes().includes(CIRCUIT_PROTO_CODE);
var defaults = {
  maxOutboundStopStreams: MAX_CONNECTIONS
};
var CircuitRelayServer = class extends TypedEventEmitter {
  registrar;
  peerStore;
  addressManager;
  peerId;
  connectionManager;
  connectionGater;
  reservationStore;
  advertService;
  started;
  hopTimeout;
  shutdownController;
  maxInboundHopStreams;
  maxOutboundHopStreams;
  maxOutboundStopStreams;
  log;
  /**
   * Creates an instance of Relay
   */
  constructor(components, init = {}) {
    super();
    this.log = components.logger.forComponent("libp2p:circuit-relay:server");
    this.registrar = components.registrar;
    this.peerStore = components.peerStore;
    this.addressManager = components.addressManager;
    this.peerId = components.peerId;
    this.connectionManager = components.connectionManager;
    this.connectionGater = components.connectionGater;
    this.started = false;
    this.hopTimeout = init?.hopTimeout ?? DEFAULT_HOP_TIMEOUT;
    this.shutdownController = new AbortController();
    this.maxInboundHopStreams = init.maxInboundHopStreams;
    this.maxOutboundHopStreams = init.maxOutboundHopStreams;
    this.maxOutboundStopStreams = init.maxOutboundStopStreams ?? defaults.maxOutboundStopStreams;
    setMaxListeners(Infinity, this.shutdownController.signal);
    if (init.advertise != null && init.advertise !== false) {
      this.advertService = new AdvertService(components, init.advertise === true ? void 0 : init.advertise);
      this.advertService.addEventListener("advert:success", () => {
        this.safeDispatchEvent("relay:advert:success", {});
      });
      this.advertService.addEventListener("advert:error", (evt) => {
        this.safeDispatchEvent("relay:advert:error", { detail: evt.detail });
      });
    }
    this.reservationStore = new ReservationStore(init.reservations);
  }
  isStarted() {
    return this.started;
  }
  /**
   * Start Relay service
   */
  async start() {
    if (this.started) {
      return;
    }
    this.advertService?.start();
    await this.registrar.handle(RELAY_V2_HOP_CODEC, (data) => {
      void this.onHop(data).catch((err) => {
        this.log.error(err);
      });
    }, {
      maxInboundStreams: this.maxInboundHopStreams,
      maxOutboundStreams: this.maxOutboundHopStreams,
      runOnTransientConnection: true
    });
    this.reservationStore.start();
    this.started = true;
  }
  /**
   * Stop Relay service
   */
  async stop() {
    this.advertService?.stop();
    this.reservationStore.stop();
    this.shutdownController.abort();
    await this.registrar.unhandle(RELAY_V2_HOP_CODEC);
    this.started = false;
  }
  async onHop({ connection, stream }) {
    this.log("received circuit v2 hop protocol stream from %p", connection.remotePeer);
    const hopTimeoutPromise = pDefer();
    const timeout = setTimeout(() => {
      hopTimeoutPromise.reject("timed out");
    }, this.hopTimeout);
    const pbstr = pbStream(stream);
    try {
      const request = await Promise.race([
        pbstr.pb(HopMessage).read(),
        hopTimeoutPromise.promise
      ]);
      if (request?.type == null) {
        throw new Error("request was invalid, could not read from stream");
      }
      this.log("received", request.type);
      await Promise.race([
        this.handleHopProtocol({
          connection,
          stream: pbstr,
          request
        }),
        hopTimeoutPromise.promise
      ]);
    } catch (err) {
      this.log.error("error while handling hop", err);
      await pbstr.pb(HopMessage).write({
        type: HopMessage.Type.STATUS,
        status: Status.MALFORMED_MESSAGE
      });
      stream.abort(err);
    } finally {
      clearTimeout(timeout);
    }
  }
  async handleHopProtocol({ stream, request, connection }) {
    this.log("received hop message");
    switch (request.type) {
      case HopMessage.Type.RESERVE:
        await this.handleReserve({ stream, request, connection });
        break;
      case HopMessage.Type.CONNECT:
        await this.handleConnect({ stream, request, connection });
        break;
      default: {
        this.log.error("invalid hop request type %s via peer %p", request.type, connection.remotePeer);
        await stream.pb(HopMessage).write({ type: HopMessage.Type.STATUS, status: Status.UNEXPECTED_MESSAGE });
      }
    }
  }
  async handleReserve({ stream, request, connection }) {
    const hopstr = stream.pb(HopMessage);
    this.log("hop reserve request from %p", connection.remotePeer);
    if (isRelayAddr(connection.remoteAddr)) {
      this.log.error("relay reservation over circuit connection denied for peer: %p", connection.remotePeer);
      await hopstr.write({ type: HopMessage.Type.STATUS, status: Status.PERMISSION_DENIED });
      return;
    }
    if (await this.connectionGater.denyInboundRelayReservation?.(connection.remotePeer) === true) {
      this.log.error("reservation for %p denied by connection gater", connection.remotePeer);
      await hopstr.write({ type: HopMessage.Type.STATUS, status: Status.PERMISSION_DENIED });
      return;
    }
    const result = this.reservationStore.reserve(connection.remotePeer, connection.remoteAddr);
    if (result.status !== Status.OK) {
      await hopstr.write({ type: HopMessage.Type.STATUS, status: result.status });
      return;
    }
    try {
      if (result.expire != null) {
        const ttl = result.expire * 1e3 - Date.now();
        await this.peerStore.merge(connection.remotePeer, {
          tags: {
            [RELAY_SOURCE_TAG]: { value: 1, ttl }
          }
        });
      }
      await hopstr.write({
        type: HopMessage.Type.STATUS,
        status: Status.OK,
        reservation: await this.makeReservation(connection.remotePeer, BigInt(result.expire ?? 0)),
        limit: this.reservationStore.get(connection.remotePeer)?.limit
      });
      this.log("sent confirmation response to %s", connection.remotePeer);
    } catch (err) {
      this.log.error("failed to send confirmation response to %p", connection.remotePeer, err);
      this.reservationStore.removeReservation(connection.remotePeer);
    }
  }
  async makeReservation(remotePeer, expire) {
    const addrs = [];
    for (const relayAddr of this.addressManager.getAddresses()) {
      if (relayAddr.toString().includes("/p2p-circuit")) {
        continue;
      }
      addrs.push(relayAddr.bytes);
    }
    const voucher = await RecordEnvelope.seal(new ReservationVoucherRecord({
      peer: remotePeer,
      relay: this.peerId,
      expiration: Number(expire)
    }), this.peerId);
    return {
      addrs,
      expire,
      voucher: voucher.marshal()
    };
  }
  async handleConnect({ stream, request, connection }) {
    const hopstr = stream.pb(HopMessage);
    if (isRelayAddr(connection.remoteAddr)) {
      this.log.error("relay reservation over circuit connection denied for peer: %p", connection.remotePeer);
      await hopstr.write({ type: HopMessage.Type.STATUS, status: Status.PERMISSION_DENIED });
      return;
    }
    this.log("hop connect request from %p", connection.remotePeer);
    let dstPeer;
    try {
      if (request.peer == null) {
        this.log.error("no peer info in hop connect request");
        throw new Error("no peer info in request");
      }
      request.peer.addrs.forEach(multiaddr);
      dstPeer = peerIdFromBytes(request.peer.id);
    } catch (err) {
      this.log.error("invalid hop connect request via peer %p %s", connection.remotePeer, err);
      await hopstr.write({ type: HopMessage.Type.STATUS, status: Status.MALFORMED_MESSAGE });
      return;
    }
    if (!this.reservationStore.hasReservation(dstPeer)) {
      this.log.error("hop connect denied for destination peer %p not having a reservation for %p with status %s", dstPeer, connection.remotePeer, Status.NO_RESERVATION);
      await hopstr.write({ type: HopMessage.Type.STATUS, status: Status.NO_RESERVATION });
      return;
    }
    if (await this.connectionGater.denyOutboundRelayedConnection?.(connection.remotePeer, dstPeer) === true) {
      this.log.error("hop connect for %p to %p denied by connection gater", connection.remotePeer, dstPeer);
      await hopstr.write({ type: HopMessage.Type.STATUS, status: Status.PERMISSION_DENIED });
      return;
    }
    const connections = this.connectionManager.getConnections(dstPeer);
    if (connections.length === 0) {
      this.log("hop connect denied for destination peer %p not having a connection for %p as there is no destination connection", dstPeer, connection.remotePeer);
      await hopstr.write({ type: HopMessage.Type.STATUS, status: Status.NO_RESERVATION });
      return;
    }
    const destinationConnection = connections[0];
    const destinationStream = await this.stopHop({
      connection: destinationConnection,
      request: {
        type: StopMessage.Type.CONNECT,
        peer: {
          id: connection.remotePeer.toBytes(),
          addrs: []
        }
      }
    });
    if (destinationStream == null) {
      this.log.error("failed to open stream to destination peer %p", destinationConnection?.remotePeer);
      await hopstr.write({ type: HopMessage.Type.STATUS, status: Status.CONNECTION_FAILED });
      return;
    }
    await hopstr.write({ type: HopMessage.Type.STATUS, status: Status.OK });
    const sourceStream = stream.unwrap();
    this.log("connection from %p to %p established - merging streams", connection.remotePeer, dstPeer);
    const limit = this.reservationStore.get(dstPeer)?.limit;
    createLimitedRelay(sourceStream, destinationStream, this.shutdownController.signal, limit, {
      log: this.log
    });
  }
  /**
   * Send a STOP request to the target peer that the dialing peer wants to contact
   */
  async stopHop({ connection, request }) {
    this.log("starting circuit relay v2 stop request to %s", connection.remotePeer);
    const stream = await connection.newStream([RELAY_V2_STOP_CODEC], {
      maxOutboundStreams: this.maxOutboundStopStreams,
      runOnTransientConnection: true
    });
    const pbstr = pbStream(stream);
    const stopstr = pbstr.pb(StopMessage);
    await stopstr.write(request);
    let response;
    try {
      response = await stopstr.read();
    } catch (err) {
      this.log.error("error parsing stop message response from %p", connection.remotePeer);
    }
    if (response == null) {
      this.log.error("could not read response from %p", connection.remotePeer);
      await stream.close();
      return;
    }
    if (response.status === Status.OK) {
      this.log("stop request to %p was successful", connection.remotePeer);
      return pbstr.unwrap();
    }
    this.log("stop request failed with code %d", response.status);
    await stream.close();
  }
  get reservations() {
    return this.reservationStore.reservations;
  }
};
function circuitRelayServer(init = {}) {
  return (components) => {
    return new CircuitRelayServer(components, init);
  };
}

// node_modules/@libp2p/circuit-relay-v2/dist/src/transport/discovery.js
var RelayDiscovery = class extends TypedEventEmitter {
  peerId;
  peerStore;
  contentRouting;
  registrar;
  started;
  topologyId;
  log;
  constructor(components) {
    super();
    this.log = components.logger.forComponent("libp2p:circuit-relay:discover-relays");
    this.started = false;
    this.peerId = components.peerId;
    this.peerStore = components.peerStore;
    this.contentRouting = components.contentRouting;
    this.registrar = components.registrar;
  }
  isStarted() {
    return this.started;
  }
  async start() {
    this.topologyId = await this.registrar.register(RELAY_V2_HOP_CODEC, {
      notifyOnTransient: true,
      onConnect: (peerId) => {
        this.safeDispatchEvent("relay:discover", { detail: peerId });
      }
    });
    this.started = true;
  }
  afterStart() {
    void this.discover().catch((err) => {
      this.log.error("error discovering relays", err);
    });
  }
  stop() {
    if (this.topologyId != null) {
      this.registrar.unregister(this.topologyId);
    }
    this.started = false;
  }
  /**
   * Try to listen on available hop relay connections.
   * The following order will happen while we do not have enough relays:
   *
   * 1. Check the metadata store for known relays, try to listen on the ones we are already connected
   * 2. Dial and try to listen on the peers we know that support hop but are not connected
   * 3. Search the network
   */
  async discover() {
    this.log("searching peer store for relays");
    const peers = await this.peerStore.all({
      filters: [
        // filter by a list of peers supporting RELAY_V2_HOP and ones we are not listening on
        (peer) => {
          return peer.protocols.includes(RELAY_V2_HOP_CODEC);
        }
      ],
      orders: [
        () => Math.random() < 0.5 ? 1 : -1
      ]
    });
    for (const peer of peers) {
      this.log("found relay peer %p in content peer store", peer.id);
      this.safeDispatchEvent("relay:discover", { detail: peer.id });
    }
    this.log("found %d relay peers in peer store", peers.length);
    try {
      this.log("searching content routing for relays");
      const cid = await namespaceToCid(RELAY_RENDEZVOUS_NS);
      let found = 0;
      for await (const provider of this.contentRouting.findProviders(cid)) {
        if (provider.multiaddrs.length > 0 && !provider.id.equals(this.peerId)) {
          const peerId = provider.id;
          found++;
          await this.peerStore.merge(peerId, {
            multiaddrs: provider.multiaddrs
          });
          this.log("found relay peer %p in content routing", peerId);
          this.safeDispatchEvent("relay:discover", { detail: peerId });
        }
      }
      this.log("found %d relay peers in content routing", found);
    } catch (err) {
      this.log.error("failed when finding relays on the network", err);
    }
  }
};

// node_modules/@libp2p/circuit-relay-v2/dist/src/transport/reservation-store.js
var REFRESH_WINDOW = 60 * 1e3 * 10;
var REFRESH_TIMEOUT = 60 * 1e3 * 5;
var REFRESH_TIMEOUT_MIN = 30 * 1e3;
var ReservationStore2 = class extends TypedEventEmitter {
  peerId;
  connectionManager;
  transportManager;
  peerStore;
  events;
  reserveQueue;
  reservations;
  maxDiscoveredRelays;
  maxReservationQueueLength;
  reservationCompletionTimeout;
  started;
  log;
  constructor(components, init) {
    super();
    this.log = components.logger.forComponent("libp2p:circuit-relay:transport:reservation-store");
    this.peerId = components.peerId;
    this.connectionManager = components.connectionManager;
    this.transportManager = components.transportManager;
    this.peerStore = components.peerStore;
    this.events = components.events;
    this.reservations = new PeerMap();
    this.maxDiscoveredRelays = init?.discoverRelays ?? 0;
    this.maxReservationQueueLength = init?.maxReservationQueueLength ?? 100;
    this.reservationCompletionTimeout = init?.reservationCompletionTimeout ?? 1e4;
    this.started = false;
    this.reserveQueue = new PeerQueue({
      concurrency: init?.reservationConcurrency ?? DEFAULT_RESERVATION_CONCURRENCY,
      metricName: "libp2p_relay_reservation_queue",
      metrics: components.metrics
    });
    this.events.addEventListener("peer:disconnect", (evt) => {
      this.#removeRelay(evt.detail);
    });
  }
  isStarted() {
    return this.started;
  }
  start() {
    this.started = true;
  }
  stop() {
    this.reserveQueue.clear();
    this.reservations.forEach(({ timeout }) => {
      clearTimeout(timeout);
    });
    this.reservations.clear();
    this.started = false;
  }
  /**
   * If the number of current relays is beneath the configured `maxReservations`
   * value, and the passed peer id is not our own, and we have a non-relayed connection
   * to the remote, and the remote peer speaks the hop protocol, try to reserve a slot
   * on the remote peer
   */
  async addRelay(peerId, type) {
    if (this.peerId.equals(peerId)) {
      this.log("not trying to use self as relay");
      return;
    }
    if (this.reserveQueue.size > this.maxReservationQueueLength) {
      this.log("not adding relay as the queue is full");
      return;
    }
    if (this.reserveQueue.has(peerId)) {
      this.log("relay peer is already in the reservation queue");
      return;
    }
    this.log("add relay %p", peerId);
    await this.reserveQueue.add(async () => {
      try {
        const existingReservation = this.reservations.get(peerId);
        if (existingReservation != null) {
          if (getExpirationMilliseconds(existingReservation.reservation.expire) > REFRESH_WINDOW) {
            this.log("already have reservation on relay peer %p and it expires in more than 10 minutes", peerId);
            return;
          }
          clearTimeout(existingReservation.timeout);
          this.reservations.delete(peerId);
        }
        if (type === "discovered" && [...this.reservations.values()].reduce((acc, curr) => {
          if (curr.type === "discovered") {
            acc++;
          }
          return acc;
        }, 0) >= this.maxDiscoveredRelays) {
          this.log("already have enough discovered relays");
          return;
        }
        const signal = AbortSignal.timeout(this.reservationCompletionTimeout);
        const connection = await this.connectionManager.openConnection(peerId, {
          signal
        });
        if (connection.remoteAddr.protoNames().includes("p2p-circuit")) {
          this.log("not creating reservation over relayed connection");
          return;
        }
        const reservation = await this.#createReservation(connection, {
          signal
        });
        this.log("created reservation on relay peer %p", peerId);
        const expiration = getExpirationMilliseconds(reservation.expire);
        const timeoutDuration = Math.min(Math.max(expiration - REFRESH_TIMEOUT, REFRESH_TIMEOUT_MIN), Math.pow(2, 31) - 1);
        const timeout = setTimeout(() => {
          this.addRelay(peerId, type).catch((err) => {
            this.log.error("could not refresh reservation to relay %p", peerId, err);
          });
        }, timeoutDuration);
        this.reservations.set(peerId, {
          timeout,
          reservation,
          type
        });
        await this.peerStore.merge(peerId, {
          tags: {
            [RELAY_TAG]: {
              value: 1,
              ttl: expiration
            }
          }
        });
        await this.transportManager.listen([multiaddr(`/p2p/${peerId.toString()}/p2p-circuit`)]);
      } catch (err) {
        this.log.error("could not reserve slot on %p", peerId, err);
        const reservation = this.reservations.get(peerId);
        if (reservation != null) {
          clearTimeout(reservation.timeout);
        }
        this.reservations.delete(peerId);
      }
    }, {
      peerId
    });
  }
  hasReservation(peerId) {
    return this.reservations.has(peerId);
  }
  getReservation(peerId) {
    return this.reservations.get(peerId)?.reservation;
  }
  async #createReservation(connection, options) {
    options.signal?.throwIfAborted();
    this.log("requesting reservation from %p", connection.remotePeer);
    const stream = await connection.newStream(RELAY_V2_HOP_CODEC, options);
    const pbstr = pbStream(stream);
    const hopstr = pbstr.pb(HopMessage);
    await hopstr.write({ type: HopMessage.Type.RESERVE }, options);
    let response;
    try {
      response = await hopstr.read(options);
    } catch (err) {
      this.log.error("error parsing reserve message response from %p because", connection.remotePeer, err);
      stream.abort(err);
      throw err;
    } finally {
      await stream.close();
    }
    if (response.status === Status.OK && response.reservation != null) {
      let hasRelayAddress = false;
      const relayAddressBytes = connection.remoteAddr.bytes;
      for (const buf of response.reservation.addrs) {
        if (equals(relayAddressBytes, buf)) {
          hasRelayAddress = true;
          break;
        }
      }
      if (!hasRelayAddress) {
        response.reservation.addrs.push(relayAddressBytes);
      }
      return response.reservation;
    }
    const errMsg = `reservation failed with status ${response.status ?? "undefined"}`;
    this.log.error(errMsg);
    throw new Error(errMsg);
  }
  /**
   * Remove listen relay
   */
  #removeRelay(peerId) {
    const existingReservation = this.reservations.get(peerId);
    if (existingReservation == null) {
      return;
    }
    this.log("connection to relay %p closed, removing reservation from local store", peerId);
    clearTimeout(existingReservation.timeout);
    this.reservations.delete(peerId);
    this.safeDispatchEvent("relay:removed", { detail: peerId });
    if (this.reservations.size < this.maxDiscoveredRelays) {
      this.log("not enough relays %d/%d", this.reservations.size, this.maxDiscoveredRelays);
      this.safeDispatchEvent("relay:not-enough-relays", {});
    }
  }
};

// node_modules/@libp2p/utils/dist/src/stream-to-ma-conn.js
function streamToMaConnection(props) {
  const { stream, remoteAddr, logger } = props;
  const log = logger.forComponent("libp2p:stream:converter");
  let closedRead = false;
  let closedWrite = false;
  const streamClose = stream.close.bind(stream);
  stream.close = async (options) => {
    await streamClose(options);
    close(true);
  };
  const streamAbort = stream.abort.bind(stream);
  stream.abort = (err) => {
    streamAbort(err);
    close(true);
  };
  const streamSink = stream.sink.bind(stream);
  stream.sink = async (source) => {
    try {
      await streamSink(source);
    } catch (err) {
      if (err.type !== "aborted") {
        log.error("%s error in sink", remoteAddr, err);
      }
    } finally {
      closedWrite = true;
      close();
    }
  };
  const maConn = {
    log,
    sink: stream.sink,
    source: async function* () {
      try {
        for await (const list of stream.source) {
          if (list instanceof Uint8Array) {
            yield list;
          } else {
            yield* list;
          }
        }
      } finally {
        closedRead = true;
        close();
      }
    }(),
    remoteAddr,
    timeline: { open: Date.now(), close: void 0 },
    close: stream.close,
    abort: stream.abort
  };
  function close(force) {
    if (force === true) {
      closedRead = true;
      closedWrite = true;
    }
    if (closedRead && closedWrite && maConn.timeline.close == null) {
      maConn.timeline.close = Date.now();
    }
  }
  return maConn;
}

// node_modules/@libp2p/circuit-relay-v2/dist/src/transport/listener.js
var CircuitRelayTransportListener = class extends TypedEventEmitter {
  connectionManager;
  relayStore;
  listeningAddrs;
  log;
  constructor(components) {
    super();
    this.log = components.logger.forComponent("libp2p:circuit-relay:transport:listener");
    this.connectionManager = components.connectionManager;
    this.relayStore = components.relayStore;
    this.listeningAddrs = new PeerMap();
    this.relayStore.addEventListener("relay:removed", this._onRemoveRelayPeer);
  }
  _onRemoveRelayPeer = (evt) => {
    this.#removeRelayPeer(evt.detail);
  };
  async listen(addr) {
    this.log("listen on %a", addr);
    const relayAddr = addr.decapsulate("/p2p-circuit");
    const relayConn = await this.connectionManager.openConnection(relayAddr);
    if (!this.relayStore.hasReservation(relayConn.remotePeer)) {
      this.log("making reservation on peer %p", relayConn.remotePeer);
      await this.relayStore.addRelay(relayConn.remotePeer, "configured");
      return;
    }
    const reservation = this.relayStore.getReservation(relayConn.remotePeer);
    if (reservation == null) {
      throw new CodeError("Did not have reservation after making reservation", "ERR_NO_RESERVATION");
    }
    if (this.listeningAddrs.has(relayConn.remotePeer)) {
      this.log("already listening on relay %p", relayConn.remotePeer);
      return;
    }
    this.listeningAddrs.set(relayConn.remotePeer, reservation.addrs.map((buf) => {
      return multiaddr(buf).encapsulate("/p2p-circuit");
    }));
    this.safeDispatchEvent("listening", {});
  }
  getAddrs() {
    return [...this.listeningAddrs.values()].flat();
  }
  async close() {
  }
  #removeRelayPeer(peerId) {
    const had = this.listeningAddrs.has(peerId);
    this.log("relay peer removed %p - had reservation", peerId, had);
    this.listeningAddrs.delete(peerId);
    if (had) {
      this.log.trace("removing relay event listener for peer %p", peerId);
      this.relayStore.removeEventListener("relay:removed", this._onRemoveRelayPeer);
      this.safeDispatchEvent("close", {});
    }
  }
};
function createListener(options) {
  return new CircuitRelayTransportListener(options);
}

// node_modules/@libp2p/circuit-relay-v2/dist/src/transport/transport.js
var isValidStop = (request) => {
  if (request.peer == null) {
    return false;
  }
  try {
    request.peer.addrs.forEach(multiaddr);
  } catch {
    return false;
  }
  return true;
};
var defaults2 = {
  maxInboundStopStreams: MAX_CONNECTIONS,
  maxOutboundStopStreams: MAX_CONNECTIONS,
  stopTimeout: 3e4
};
var CircuitRelayTransport = class {
  discovery;
  registrar;
  peerStore;
  connectionManager;
  transportManager;
  peerId;
  upgrader;
  addressManager;
  connectionGater;
  reservationStore;
  logger;
  maxInboundStopStreams;
  maxOutboundStopStreams;
  stopTimeout;
  started;
  log;
  constructor(components, init) {
    this.log = components.logger.forComponent("libp2p:circuit-relay:transport");
    this.registrar = components.registrar;
    this.peerStore = components.peerStore;
    this.connectionManager = components.connectionManager;
    this.transportManager = components.transportManager;
    this.logger = components.logger;
    this.peerId = components.peerId;
    this.upgrader = components.upgrader;
    this.addressManager = components.addressManager;
    this.connectionGater = components.connectionGater;
    this.maxInboundStopStreams = init.maxInboundStopStreams ?? defaults2.maxInboundStopStreams;
    this.maxOutboundStopStreams = init.maxOutboundStopStreams ?? defaults2.maxOutboundStopStreams;
    this.stopTimeout = init.stopTimeout ?? defaults2.stopTimeout;
    if (init.discoverRelays != null && init.discoverRelays > 0) {
      this.discovery = new RelayDiscovery(components);
      this.discovery.addEventListener("relay:discover", (evt) => {
        this.reservationStore.addRelay(evt.detail, "discovered").catch((err) => {
          this.log.error("could not add discovered relay %p", evt.detail, err);
        });
      });
    }
    this.reservationStore = new ReservationStore2(components, init);
    this.reservationStore.addEventListener("relay:not-enough-relays", () => {
      this.discovery?.discover().catch((err) => {
        this.log.error("could not discover relays", err);
      });
    });
    this.started = false;
  }
  isStarted() {
    return this.started;
  }
  async start() {
    this.reservationStore.start();
    await this.registrar.handle(RELAY_V2_STOP_CODEC, (data) => {
      void this.onStop(data).catch((err) => {
        this.log.error("error while handling STOP protocol", err);
        data.stream.abort(err);
      });
    }, {
      maxInboundStreams: this.maxInboundStopStreams,
      maxOutboundStreams: this.maxOutboundStopStreams,
      runOnTransientConnection: true
    });
    await this.discovery?.start();
    this.started = true;
  }
  afterStart() {
    this.discovery?.afterStart();
  }
  async stop() {
    this.discovery?.stop();
    this.reservationStore.stop();
    await this.registrar.unhandle(RELAY_V2_STOP_CODEC);
    this.started = false;
  }
  [transportSymbol] = true;
  [Symbol.toStringTag] = "libp2p/circuit-relay-v2";
  /**
   * Dial a peer over a relay
   */
  async dial(ma, options = {}) {
    if (ma.protoCodes().filter((code) => code === CIRCUIT_PROTO_CODE).length !== 1) {
      const errMsg = "Invalid circuit relay address";
      this.log.error(errMsg, ma);
      throw new CodeError(errMsg, ERR_RELAYED_DIAL);
    }
    const addrs = ma.toString().split("/p2p-circuit");
    const relayAddr = multiaddr(addrs[0]);
    const destinationAddr = multiaddr(addrs[addrs.length - 1]);
    const relayId = relayAddr.getPeerId();
    const destinationId = destinationAddr.getPeerId();
    if (relayId == null || destinationId == null) {
      const errMsg = `Circuit relay dial to ${ma.toString()} failed as address did not have peer ids`;
      this.log.error(errMsg);
      throw new CodeError(errMsg, ERR_RELAYED_DIAL);
    }
    const relayPeer = peerIdFromString(relayId);
    const destinationPeer = peerIdFromString(destinationId);
    let disconnectOnFailure = false;
    const relayConnections = this.connectionManager.getConnections(relayPeer);
    let relayConnection = relayConnections[0];
    if (relayConnection == null) {
      await this.peerStore.merge(relayPeer, {
        multiaddrs: [relayAddr]
      });
      relayConnection = await this.connectionManager.openConnection(relayPeer, options);
      disconnectOnFailure = true;
    }
    let stream;
    try {
      stream = await relayConnection.newStream(RELAY_V2_HOP_CODEC);
      return await this.connectV2({
        stream,
        connection: relayConnection,
        destinationPeer,
        destinationAddr,
        relayAddr,
        ma,
        disconnectOnFailure
      });
    } catch (err) {
      this.log.error("circuit relay dial to destination %p via relay %p failed", destinationPeer, relayPeer, err);
      if (stream != null) {
        stream.abort(err);
      }
      disconnectOnFailure && await relayConnection.close();
      throw err;
    }
  }
  async connectV2({ stream, connection, destinationPeer, destinationAddr, relayAddr, ma, disconnectOnFailure }) {
    try {
      const pbstr = pbStream(stream);
      const hopstr = pbstr.pb(HopMessage);
      await hopstr.write({
        type: HopMessage.Type.CONNECT,
        peer: {
          id: destinationPeer.toBytes(),
          addrs: [multiaddr(destinationAddr).bytes]
        }
      });
      const status = await hopstr.read();
      if (status.status !== Status.OK) {
        throw new CodeError(`failed to connect via relay with status ${status?.status?.toString() ?? "undefined"}`, ERR_HOP_REQUEST_FAILED);
      }
      const maConn = streamToMaConnection({
        stream: pbstr.unwrap(),
        remoteAddr: ma,
        localAddr: relayAddr.encapsulate(`/p2p-circuit/p2p/${this.peerId.toString()}`),
        logger: this.logger
      });
      this.log("new outbound transient connection %a", maConn.remoteAddr);
      return await this.upgrader.upgradeOutbound(maConn, {
        transient: true
      });
    } catch (err) {
      this.log.error(`Circuit relay dial to destination ${destinationPeer.toString()} via relay ${connection.remotePeer.toString()} failed`, err);
      disconnectOnFailure && await connection.close();
      throw err;
    }
  }
  /**
   * Create a listener
   */
  createListener(options) {
    return createListener({
      connectionManager: this.connectionManager,
      relayStore: this.reservationStore,
      logger: this.logger
    });
  }
  /**
   * Filter check for all Multiaddrs that this transport can listen on
   */
  listenFilter(multiaddrs) {
    multiaddrs = Array.isArray(multiaddrs) ? multiaddrs : [multiaddrs];
    return multiaddrs.filter((ma) => {
      return Circuit.matches(ma);
    });
  }
  /**
   * Filter check for all Multiaddrs that this transport can dial
   */
  dialFilter(multiaddrs) {
    return this.listenFilter(multiaddrs);
  }
  /**
   * An incoming STOP request means a remote peer wants to dial us via a relay
   */
  async onStop({ connection, stream }) {
    if (!this.reservationStore.hasReservation(connection.remotePeer)) {
      try {
        this.log("dialed via relay we did not have a reservation on, start listening on that relay address");
        await this.transportManager.listen([connection.remoteAddr.encapsulate("/p2p-circuit")]);
      } catch (err) {
        this.log.error("failed to listen on a relay peer we were dialed via but did not have a reservation on", err);
      }
    }
    const signal = AbortSignal.timeout(this.stopTimeout);
    const pbstr = pbStream(stream).pb(StopMessage);
    const request = await pbstr.read({
      signal
    });
    this.log("new circuit relay v2 stop stream from %p with type %s", connection.remotePeer, request.type);
    if (request?.type === void 0) {
      this.log.error("type was missing from circuit v2 stop protocol request from %s", connection.remotePeer);
      await pbstr.write({ type: StopMessage.Type.STATUS, status: Status.MALFORMED_MESSAGE }, {
        signal
      });
      await stream.close();
      return;
    }
    if (request.type !== StopMessage.Type.CONNECT) {
      this.log.error("invalid stop connect request via peer %p", connection.remotePeer);
      await pbstr.write({ type: StopMessage.Type.STATUS, status: Status.UNEXPECTED_MESSAGE }, {
        signal
      });
      await stream.close();
      return;
    }
    if (!isValidStop(request)) {
      this.log.error("invalid stop connect request via peer %p", connection.remotePeer);
      await pbstr.write({ type: StopMessage.Type.STATUS, status: Status.MALFORMED_MESSAGE }, {
        signal
      });
      await stream.close();
      return;
    }
    const remotePeerId = peerIdFromBytes(request.peer.id);
    if (await this.connectionGater.denyInboundRelayedConnection?.(connection.remotePeer, remotePeerId) === true) {
      this.log.error("connection gater denied inbound relayed connection from %p", connection.remotePeer);
      await pbstr.write({ type: StopMessage.Type.STATUS, status: Status.PERMISSION_DENIED }, {
        signal
      });
      await stream.close();
      return;
    }
    this.log.trace("sending success response to %p", connection.remotePeer);
    await pbstr.write({ type: StopMessage.Type.STATUS, status: Status.OK }, {
      signal
    });
    const remoteAddr = connection.remoteAddr.encapsulate(`/p2p-circuit/p2p/${remotePeerId.toString()}`);
    const localAddr = this.addressManager.getAddresses()[0];
    const maConn = streamToMaConnection({
      stream: pbstr.unwrap().unwrap(),
      remoteAddr,
      localAddr,
      logger: this.logger
    });
    this.log("new inbound transient connection %a", maConn.remoteAddr);
    await this.upgrader.upgradeInbound(maConn, {
      transient: true
    });
    this.log("%s connection %a upgraded", "inbound", maConn.remoteAddr);
  }
};

// node_modules/@libp2p/circuit-relay-v2/dist/src/transport/index.js
function circuitRelayTransport(init = {}) {
  return (components) => {
    return new CircuitRelayTransport(components, init);
  };
}
export {
  RELAY_V2_HOP_CODEC,
  RELAY_V2_STOP_CODEC,
  circuitRelayServer,
  circuitRelayTransport
};
//# sourceMappingURL=@libp2p_circuit-relay-v2.js.map
