{
  "version": 3,
  "sources": ["../../@libp2p/interface/src/pubsub/index.ts", "../../@libp2p/interface/src/transport/index.ts", "../../@libp2p/interface/src/errors.ts", "../../@libp2p/interface/src/events.browser.ts", "../../@libp2p/interface/src/events.ts", "../../@libp2p/interface/src/event-target.ts", "../../@libp2p/interface/src/connection/index.ts", "../../@libp2p/interface/src/content-routing/index.ts", "../../@libp2p/interface/src/peer-discovery/index.ts", "../../@libp2p/interface/src/peer-id/index.ts", "../../@libp2p/interface/src/peer-routing/index.ts", "../../@libp2p/interface/src/peer-store/tags.ts", "../../@libp2p/interface/src/startable.ts"],
  "sourcesContent": ["import type { Stream } from '../connection/index.js'\nimport type { TypedEventTarget } from '../event-target.js'\nimport type { PeerId } from '../peer-id/index.js'\nimport type { Pushable } from 'it-pushable'\nimport type { Uint8ArrayList } from 'uint8arraylist'\n\n/**\n * On the producing side:\n * * Build messages with the signature, key (from may be enough for certain inlineable public key types), from and seqno fields.\n *\n * On the consuming side:\n * * Enforce the fields to be present, reject otherwise.\n * * Propagate only if the fields are valid and signature can be verified, reject otherwise.\n */\nexport const StrictSign = 'StrictSign'\n\n/**\n * On the producing side:\n * * Build messages without the signature, key, from and seqno fields.\n * * The corresponding protobuf key-value pairs are absent from the marshalled message, not just empty.\n *\n * On the consuming side:\n * * Enforce the fields to be absent, reject otherwise.\n * * Propagate only if the fields are absent, reject otherwise.\n * * A message_id function will not be able to use the above fields, and should instead rely on the data field. A commonplace strategy is to calculate a hash.\n */\nexport const StrictNoSign = 'StrictNoSign'\n\nexport type SignaturePolicy = typeof StrictSign | typeof StrictNoSign\n\nexport interface SignedMessage {\n  type: 'signed'\n  from: PeerId\n  topic: string\n  data: Uint8Array\n  sequenceNumber: bigint\n  signature: Uint8Array\n  key: Uint8Array\n}\n\nexport interface UnsignedMessage {\n  type: 'unsigned'\n  topic: string\n  data: Uint8Array\n}\n\nexport type Message = SignedMessage | UnsignedMessage\n\nexport interface PubSubRPCMessage {\n  from?: Uint8Array\n  topic?: string\n  data?: Uint8Array\n  sequenceNumber?: Uint8Array\n  signature?: Uint8Array\n  key?: Uint8Array\n}\n\nexport interface PubSubRPCSubscription {\n  subscribe?: boolean\n  topic?: string\n}\n\nexport interface PubSubRPC {\n  subscriptions: PubSubRPCSubscription[]\n  messages: PubSubRPCMessage[]\n}\n\nexport interface PeerStreams extends TypedEventTarget<PeerStreamEvents> {\n  id: PeerId\n  protocol: string\n  outboundStream?: Pushable<Uint8ArrayList>\n  inboundStream?: AsyncIterable<Uint8ArrayList>\n  isWritable: boolean\n\n  close(): void\n  write(buf: Uint8Array | Uint8ArrayList): void\n  attachInboundStream(stream: Stream): AsyncIterable<Uint8ArrayList>\n  attachOutboundStream(stream: Stream): Promise<Pushable<Uint8ArrayList>>\n}\n\nexport interface PubSubInit {\n  enabled?: boolean\n\n  multicodecs?: string[]\n\n  /**\n   * defines how signatures should be handled\n   */\n  globalSignaturePolicy?: SignaturePolicy\n\n  /**\n   * if can relay messages not subscribed\n   */\n  canRelayMessage?: boolean\n\n  /**\n   * if publish should emit to self, if subscribed\n   */\n  emitSelf?: boolean\n\n  /**\n   * handle this many incoming pubsub messages concurrently\n   */\n  messageProcessingConcurrency?: number\n\n  /**\n   * How many parallel incoming streams to allow on the pubsub protocol per-connection\n   */\n  maxInboundStreams?: number\n\n  /**\n   * How many parallel outgoing streams to allow on the pubsub protocol per-connection\n   */\n  maxOutboundStreams?: number\n}\n\ninterface Subscription {\n  topic: string\n  subscribe: boolean\n}\n\nexport interface SubscriptionChangeData {\n  peerId: PeerId\n  subscriptions: Subscription[]\n}\n\nexport interface PubSubEvents {\n  'subscription-change': CustomEvent<SubscriptionChangeData>\n  'message': CustomEvent<Message>\n}\n\nexport interface PublishResult {\n  recipients: PeerId[]\n}\n\nexport enum TopicValidatorResult {\n  /**\n   * The message is considered valid, and it should be delivered and forwarded to the network\n   */\n  Accept = 'accept',\n  /**\n   * The message is neither delivered nor forwarded to the network\n   */\n  Ignore = 'ignore',\n  /**\n   * The message is considered invalid, and it should be rejected\n   */\n  Reject = 'reject'\n}\n\nexport interface TopicValidatorFn {\n  (peer: PeerId, message: Message): TopicValidatorResult | Promise<TopicValidatorResult>\n}\n\nexport interface PubSub<Events extends Record<string, any> = PubSubEvents> extends TypedEventTarget<Events> {\n  /**\n   * The global signature policy controls whether or not we sill send and receive\n   * signed or unsigned messages.\n   *\n   * Signed messages prevent spoofing message senders and should be preferred to\n   * using unsigned messages.\n   */\n  globalSignaturePolicy: typeof StrictSign | typeof StrictNoSign\n\n  /**\n   * A list of multicodecs that contain the pubsub protocol name.\n   */\n  multicodecs: string[]\n\n  /**\n   * Pubsub routers support message validators per topic, which will validate the message\n   * before its propagations. They are stored in a map where keys are the topic name and\n   * values are the validators.\n   *\n   * @example\n   *\n   * ```TypeScript\n   * const topic = 'topic'\n   * const validateMessage = (msgTopic, msg) => {\n   *   const input = uint8ArrayToString(msg.data)\n   *   const validInputs = ['a', 'b', 'c']\n   *\n   *   if (!validInputs.includes(input)) {\n   *     throw new Error('no valid input received')\n   *   }\n   * }\n   * libp2p.pubsub.topicValidators.set(topic, validateMessage)\n   * ```\n   */\n  topicValidators: Map<string, TopicValidatorFn>\n\n  getPeers(): PeerId[]\n\n  /**\n   * Gets a list of topics the node is subscribed to.\n   *\n   * ```TypeScript\n   * const topics = libp2p.pubsub.getTopics()\n   * ```\n   */\n  getTopics(): string[]\n\n  /**\n   * Subscribes to a pubsub topic.\n   *\n   * @example\n   *\n   * ```TypeScript\n   * const topic = 'topic'\n   * const handler = (msg) => {\n   *   if (msg.topic === topic) {\n   *     // msg.data - pubsub data received\n   *   }\n   * }\n   *\n   * libp2p.pubsub.addEventListener('message', handler)\n   * libp2p.pubsub.subscribe(topic)\n   * ```\n   */\n  subscribe(topic: string): void\n\n  /**\n   * Unsubscribes from a pubsub topic.\n   *\n   * @example\n   *\n   * ```TypeScript\n   * const topic = 'topic'\n   * const handler = (msg) => {\n   *   // msg.data - pubsub data received\n   * }\n   *\n   * libp2p.pubsub.removeEventListener(topic handler)\n   * libp2p.pubsub.unsubscribe(topic)\n   * ```\n   */\n  unsubscribe(topic: string): void\n\n  /**\n   * Gets a list of the PeerIds that are subscribed to one topic.\n   *\n   * @example\n   *\n   * ```TypeScript\n   * const peerIds = libp2p.pubsub.getSubscribers(topic)\n   * ```\n   */\n  getSubscribers(topic: string): PeerId[]\n\n  /**\n   * Publishes messages to the given topic.\n   *\n   * @example\n   *\n   * ```TypeScript\n   * const topic = 'topic'\n   * const data = uint8ArrayFromString('data')\n   *\n   * await libp2p.pubsub.publish(topic, data)\n   * ```\n   */\n  publish(topic: string, data: Uint8Array): Promise<PublishResult>\n}\n\nexport interface PeerStreamEvents {\n  'stream:inbound': CustomEvent<never>\n  'stream:outbound': CustomEvent<never>\n  'close': CustomEvent<never>\n}\n", "import type { Connection, MultiaddrConnection } from '../connection/index.js'\nimport type { TypedEventTarget } from '../event-target.js'\nimport type { AbortOptions } from '../index.js'\nimport type { StreamMuxerFactory } from '../stream-muxer/index.js'\nimport type { Multiaddr } from '@multiformats/multiaddr'\n\nexport interface ListenerEvents {\n  'connection': CustomEvent<Connection>\n  'listening': CustomEvent\n  'error': CustomEvent<Error>\n  'close': CustomEvent\n}\n\nexport interface Listener extends TypedEventTarget<ListenerEvents> {\n  /**\n   * Start a listener\n   */\n  listen(multiaddr: Multiaddr): Promise<void>\n  /**\n   * Get listen addresses\n   */\n  getAddrs(): Multiaddr[]\n  /**\n   * Close listener\n   *\n   * @returns {Promise<void>}\n   */\n  close(): Promise<void>\n}\n\nexport const transportSymbol = Symbol.for('@libp2p/transport')\n\nexport interface ConnectionHandler { (connection: Connection): void }\n\nexport interface MultiaddrFilter { (multiaddrs: Multiaddr[]): Multiaddr[] }\n\nexport interface CreateListenerOptions {\n  handler?: ConnectionHandler\n  upgrader: Upgrader\n}\n\nexport interface DialOptions extends AbortOptions {\n  upgrader: Upgrader\n}\n\n/**\n * A libp2p transport is understood as something that offers a dial and listen interface to establish connections.\n */\nexport interface Transport {\n  /**\n   * Used to identify the transport\n   */\n  [Symbol.toStringTag]: string\n\n  /**\n   * Used by the isTransport function\n   */\n  [transportSymbol]: true\n\n  /**\n   * Dial a given multiaddr.\n   */\n  dial(ma: Multiaddr, options: DialOptions): Promise<Connection>\n\n  /**\n   * Create transport listeners.\n   */\n  createListener(options: CreateListenerOptions): Listener\n\n  /**\n   * Takes a list of `Multiaddr`s and returns only addresses that are valid for\n   * the transport to listen on\n   */\n  listenFilter: MultiaddrFilter\n\n  /**\n   * Takes a list of `Multiaddr`s and returns only addresses that are vali for\n   * the transport to dial\n   */\n  dialFilter: MultiaddrFilter\n}\n\nexport function isTransport (other: any): other is Transport {\n  return other != null && Boolean(other[transportSymbol])\n}\n\n/**\n * Enum Transport Manager Fault Tolerance values\n */\nexport enum FaultTolerance {\n  /**\n   * should be used for failing in any listen circumstance\n   */\n  FATAL_ALL = 0,\n\n  /**\n   * should be used for not failing when not listening\n   */\n  NO_FATAL\n}\n\nexport interface UpgraderOptions {\n  skipEncryption?: boolean\n  skipProtection?: boolean\n  muxerFactory?: StreamMuxerFactory\n\n  /**\n   * The passed MultiaddrConnection has limits place on duration and/or data\n   * transfer amounts so is not expected to be open for very long.\n   */\n  transient?: boolean\n}\n\nexport interface Upgrader {\n  /**\n   * Upgrades an outbound connection on `transport.dial`.\n   */\n  upgradeOutbound(maConn: MultiaddrConnection, opts?: UpgraderOptions): Promise<Connection>\n\n  /**\n   * Upgrades an inbound connection on transport listener.\n   */\n  upgradeInbound(maConn: MultiaddrConnection, opts?: UpgraderOptions): Promise<Connection>\n}\n", "/**\n * When this error is thrown it means an operation was aborted,\n * usually in response to the `abort` event being emitted by an\n * AbortSignal.\n */\nexport class AbortError extends Error {\n  public readonly code: string\n  public readonly type: string\n\n  constructor (message: string = 'The operation was aborted') {\n    super(message)\n    this.name = 'AbortError'\n    this.code = AbortError.code\n    this.type = AbortError.type\n  }\n\n  static readonly code = 'ABORT_ERR'\n\n  static readonly type = 'aborted'\n}\n\nexport class CodeError<T extends Record<string, any> = Record<string, never>> extends Error {\n  public readonly props: T\n\n  constructor (\n    message: string,\n    public readonly code: string,\n    props?: T\n  ) {\n    super(message)\n\n    this.name = props?.name ?? 'CodeError'\n    this.props = props ?? {} as T // eslint-disable-line @typescript-eslint/consistent-type-assertions\n  }\n}\n\nexport class AggregateCodeError<T extends Record<string, any> = Record<string, never>> extends AggregateError {\n  public readonly props: T\n\n  constructor (\n    errors: Error[],\n    message: string,\n    public readonly code: string,\n    props?: T\n  ) {\n    super(errors, message)\n\n    this.name = props?.name ?? 'AggregateCodeError'\n    this.props = props ?? {} as T // eslint-disable-line @typescript-eslint/consistent-type-assertions\n  }\n}\n\nexport class UnexpectedPeerError extends Error {\n  public code: string\n\n  constructor (message = 'Unexpected Peer') {\n    super(message)\n    this.name = 'UnexpectedPeerError'\n    this.code = UnexpectedPeerError.code\n  }\n\n  static readonly code = 'ERR_UNEXPECTED_PEER'\n}\n\nexport class InvalidCryptoExchangeError extends Error {\n  public code: string\n\n  constructor (message = 'Invalid crypto exchange') {\n    super(message)\n    this.name = 'InvalidCryptoExchangeError'\n    this.code = InvalidCryptoExchangeError.code\n  }\n\n  static readonly code = 'ERR_INVALID_CRYPTO_EXCHANGE'\n}\n\nexport class InvalidCryptoTransmissionError extends Error {\n  public code: string\n\n  constructor (message = 'Invalid crypto transmission') {\n    super(message)\n    this.name = 'InvalidCryptoTransmissionError'\n    this.code = InvalidCryptoTransmissionError.code\n  }\n\n  static readonly code = 'ERR_INVALID_CRYPTO_TRANSMISSION'\n}\n\n// Error codes\n\nexport const ERR_TIMEOUT = 'ERR_TIMEOUT'\nexport const ERR_INVALID_PARAMETERS = 'ERR_INVALID_PARAMETERS'\nexport const ERR_NOT_FOUND = 'ERR_NOT_FOUND'\nexport const ERR_INVALID_MESSAGE = 'ERR_INVALID_MESSAGE'\n", "/** Noop for browser compatibility */\nexport function setMaxListeners (): void {}\n", "import { setMaxListeners as nodeSetMaxListeners } from 'events'\n\n// create a setMaxListeners that doesn't break browser usage\nexport const setMaxListeners: typeof nodeSetMaxListeners = (n, ...eventTargets) => {\n  try {\n    nodeSetMaxListeners(n, ...eventTargets)\n  } catch {\n    // swallow error, gulp\n  }\n}\n", "import { setMaxListeners } from './events.js'\n\nexport interface EventCallback<EventType> { (evt: EventType): void }\nexport interface EventObject<EventType> { handleEvent: EventCallback<EventType> }\nexport type EventHandler<EventType> = EventCallback<EventType> | EventObject<EventType>\n\ninterface Listener {\n  once: boolean\n  callback: any\n}\n\n/**\n * Adds types to the EventTarget class. Hopefully this won't be necessary forever.\n *\n * https://github.com/microsoft/TypeScript/issues/28357\n * https://github.com/microsoft/TypeScript/issues/43477\n * https://github.com/microsoft/TypeScript/issues/299\n * etc\n */\nexport interface TypedEventTarget <EventMap extends Record<string, any>> extends EventTarget {\n  addEventListener<K extends keyof EventMap>(type: K, listener: EventHandler<EventMap[K]> | null, options?: boolean | AddEventListenerOptions): void\n\n  listenerCount (type: string): number\n\n  removeEventListener<K extends keyof EventMap>(type: K, listener?: EventHandler<EventMap[K]> | null, options?: boolean | EventListenerOptions): void\n\n  removeEventListener (type: string, listener?: EventHandler<Event>, options?: boolean | EventListenerOptions): void\n\n  safeDispatchEvent<Detail>(type: keyof EventMap, detail: CustomEventInit<Detail>): boolean\n}\n\n/**\n * An implementation of a typed event target\n * etc\n */\nexport class TypedEventEmitter<EventMap extends Record<string, any>> extends EventTarget implements TypedEventTarget<EventMap> {\n  #listeners = new Map<any, Listener[]>()\n\n  constructor () {\n    super()\n\n    // silence MaxListenersExceededWarning warning on Node.js, this is a red\n    // herring almost all of the time\n    setMaxListeners(Infinity, this)\n  }\n\n  listenerCount (type: string): number {\n    const listeners = this.#listeners.get(type)\n\n    if (listeners == null) {\n      return 0\n    }\n\n    return listeners.length\n  }\n\n  addEventListener<K extends keyof EventMap>(type: K, listener: EventHandler<EventMap[K]> | null, options?: boolean | AddEventListenerOptions): void\n  addEventListener (type: string, listener: EventHandler<Event>, options?: boolean | AddEventListenerOptions): void {\n    super.addEventListener(type, listener, options)\n\n    let list = this.#listeners.get(type)\n\n    if (list == null) {\n      list = []\n      this.#listeners.set(type, list)\n    }\n\n    list.push({\n      callback: listener,\n      once: (options !== true && options !== false && options?.once) ?? false\n    })\n  }\n\n  removeEventListener<K extends keyof EventMap>(type: K, listener?: EventHandler<EventMap[K]> | null, options?: boolean | EventListenerOptions): void\n  removeEventListener (type: string, listener?: EventHandler<Event>, options?: boolean | EventListenerOptions): void {\n    super.removeEventListener(type.toString(), listener ?? null, options)\n\n    let list = this.#listeners.get(type)\n\n    if (list == null) {\n      return\n    }\n\n    list = list.filter(({ callback }) => callback !== listener)\n    this.#listeners.set(type, list)\n  }\n\n  dispatchEvent (event: Event): boolean {\n    const result = super.dispatchEvent(event)\n\n    let list = this.#listeners.get(event.type)\n\n    if (list == null) {\n      return result\n    }\n\n    list = list.filter(({ once }) => !once)\n    this.#listeners.set(event.type, list)\n\n    return result\n  }\n\n  safeDispatchEvent<Detail>(type: keyof EventMap, detail: CustomEventInit<Detail> = {}): boolean {\n    return this.dispatchEvent(new CustomEvent<Detail>(type as string, detail))\n  }\n}\n\n/**\n * CustomEvent is a standard event but it's not supported by node.\n *\n * Remove this when https://github.com/nodejs/node/issues/40678 is closed.\n *\n * Ref: https://developer.mozilla.org/en-US/docs/Web/API/CustomEvent\n */\nclass CustomEventPolyfill<T = any> extends Event {\n  /** Returns any custom data event was created with. Typically used for synthetic events. */\n  public detail: T\n\n  constructor (message: string, data?: EventInit & { detail: T }) {\n    super(message, data)\n    // @ts-expect-error could be undefined\n    this.detail = data?.detail\n  }\n}\n\nexport const CustomEvent = globalThis.CustomEvent ?? CustomEventPolyfill\n", "import type { AbortOptions, Logger } from '../index.js'\nimport type { PeerId } from '../peer-id/index.js'\nimport type { Multiaddr } from '@multiformats/multiaddr'\nimport type { Duplex, Source } from 'it-stream-types'\nimport type { Uint8ArrayList } from 'uint8arraylist'\n\nexport interface ConnectionTimeline {\n  /**\n   * When the connection was opened\n   */\n  open: number\n\n  /**\n   * When the MultiaddrConnection was upgraded to a Connection - e.g. the type\n   * of connection encryption and multiplexing was negotiated.\n   */\n  upgraded?: number\n\n  /**\n   * When the connection was closed.\n   */\n  close?: number\n}\n\n/**\n * Outbound connections are opened by the local node, inbound streams are opened by the remote\n */\nexport type Direction = 'inbound' | 'outbound'\n\nexport interface StreamTimeline {\n  /**\n   * A timestamp of when the stream was opened\n   */\n  open: number\n\n  /**\n   * A timestamp of when the stream was closed for both reading and writing\n   */\n  close?: number\n\n  /**\n   * A timestamp of when the stream was closed for reading\n   */\n  closeRead?: number\n\n  /**\n   * A timestamp of when the stream was closed for writing\n   */\n  closeWrite?: number\n\n  /**\n   * A timestamp of when the stream was reset\n   */\n  reset?: number\n\n  /**\n   * A timestamp of when the stream was aborted\n   */\n  abort?: number\n}\n\n/**\n * The states a stream can be in\n */\nexport type StreamStatus = 'open' | 'closing' | 'closed' | 'aborted' | 'reset'\n\n/**\n * The states the readable end of a stream can be in\n *\n * ready - the readable end is ready for reading\n * closing - the readable end is closing\n * closed - the readable end has closed\n */\nexport type ReadStatus = 'ready' | 'closing' | 'closed'\n\n/**\n * The states the writable end of a stream can be in\n *\n * ready - the writable end is ready for writing\n * writing - the writable end is in the process of being written to\n * done - the source passed to the `.sink` function yielded all values without error\n * closing - the writable end is closing\n * closed - the writable end has closed\n */\nexport type WriteStatus = 'ready' | 'writing' | 'done' | 'closing' | 'closed'\n\n/**\n * A Stream is a data channel between two peers that\n * can be written to and read from at both ends.\n *\n * It may be encrypted and multiplexed depending on the\n * configuration of the nodes.\n */\nexport interface Stream extends Duplex<AsyncGenerator<Uint8ArrayList>, Source<Uint8ArrayList | Uint8Array>, Promise<void>> {\n  /**\n   * Closes the stream for **reading** *and* **writing**.\n   *\n   * Any buffered data in the source can still be consumed and the stream will end normally.\n   *\n   * This will cause a `CLOSE` message to be sent to the remote, *unless* the sink has already ended.\n   *\n   * The sink and the source will return normally.\n   */\n  close(options?: AbortOptions): Promise<void>\n\n  /**\n   * Closes the stream for **reading**. If iterating over the source of this stream in a `for await of` loop, it will return (exit the loop) after any buffered data has been consumed.\n   *\n   * This function is called automatically by the muxer when it receives a `CLOSE` message from the remote.\n   *\n   * The source will return normally, the sink will continue to consume.\n   */\n  closeRead(options?: AbortOptions): Promise<void>\n\n  /**\n   * Closes the stream for **writing**. If iterating over the source of this stream in a `for await of` loop, it will return (exit the loop) after any buffered data has been consumed.\n   *\n   * The source will return normally, the sink will continue to consume.\n   */\n  closeWrite(options?: AbortOptions): Promise<void>\n\n  /**\n   * Closes the stream for **reading** *and* **writing**. This should be called when a *local error* has occurred.\n   *\n   * Note, if called without an error any buffered data in the source can still be consumed and the stream will end normally.\n   *\n   * This will cause a `RESET` message to be sent to the remote, *unless* the sink has already ended.\n   *\n   * The sink will return and the source will throw if an error is passed or return normally if not.\n   */\n  abort(err: Error): void\n\n  /**\n   * Unique identifier for a stream. Identifiers are not unique across muxers.\n   */\n  id: string\n\n  /**\n   * Outbound streams are opened by the local node, inbound streams are opened by the remote\n   */\n  direction: Direction\n\n  /**\n   * Lifecycle times for the stream\n   */\n  timeline: StreamTimeline\n\n  /**\n   * The protocol negotiated for this stream\n   */\n  protocol?: string\n\n  /**\n   * User defined stream metadata\n   */\n  metadata: Record<string, any>\n\n  /**\n   * The current status of the stream\n   */\n  status: StreamStatus\n\n  /**\n   * The current status of the readable end of the stream\n   */\n  readStatus: ReadStatus\n\n  /**\n   * The current status of the writable end of the stream\n   */\n  writeStatus: WriteStatus\n\n  /**\n   * The stream logger\n   */\n  log: Logger\n}\n\nexport interface NewStreamOptions extends AbortOptions {\n  /**\n   * If specified, and no handler has been registered with the registrar for the\n   * successfully negotiated protocol, use this as the max outbound stream limit\n   * for the protocol\n   */\n  maxOutboundStreams?: number\n\n  /**\n   * Opt-in to running over a transient connection - one that has time/data limits\n   * placed on it.\n   *\n   * @default false\n   */\n  runOnTransientConnection?: boolean\n\n  /**\n   * By default when negotiating a protocol the dialer writes then protocol name\n   * then reads the response.\n   *\n   * When a only a single protocol is being negotiated on an outbound stream,\n   * and the stream is written to before being read from, we can optimistically\n   * write the protocol name and the first chunk of data together in the first\n   * message.\n   *\n   * Reading and handling the protocol response is done asynchronously, which\n   * means we can skip a round trip on writing to newly opened streams which\n   * significantly reduces the time-to-first-byte on a stream.\n   *\n   * The side-effect of this is that the underlying stream won't negotiate the\n   * protocol until either data is written to or read from the stream so it will\n   * not be opened on the remote until this is done.\n   *\n   * Pass `false` here to optimistically write the protocol name and first chunk\n   * of data in the first message.\n   *\n   * If multiple protocols are being negotiated, negotiation is always completed\n   * in full before the stream is returned so this option has no effect.\n   *\n   * @default true\n   */\n  negotiateFully?: boolean\n}\n\nexport type ConnectionStatus = 'open' | 'closing' | 'closed'\n\n/**\n * A Connection is a high-level representation of a connection\n * to a remote peer that may have been secured by encryption and\n * multiplexed, depending on the configuration of the nodes\n * between which the connection is made.\n */\nexport interface Connection {\n  /**\n   * The unique identifier for this connection\n   */\n  id: string\n\n  /**\n   * The address of the remote end of the connection\n   */\n  remoteAddr: Multiaddr\n\n  /**\n   * The id of the peer at the remote end of the connection\n   */\n  remotePeer: PeerId\n\n  /**\n   * A list of tags applied to this connection\n   */\n  tags: string[]\n\n  /**\n   * A list of open streams on this connection\n   */\n  streams: Stream[]\n\n  /**\n   * Outbound conections are opened by the local node, inbound streams are opened by the remote\n   */\n  direction: Direction\n\n  /**\n   * Lifecycle times for the connection\n   */\n  timeline: ConnectionTimeline\n\n  /**\n   * The multiplexer negotiated for this connection\n   */\n  multiplexer?: string\n\n  /**\n   * The encryption protocol negotiated for this connection\n   */\n  encryption?: string\n\n  /**\n   * The current status of the connection\n   */\n  status: ConnectionStatus\n\n  /**\n   * A transient connection is one that is not expected to be open for very long\n   * or one that cannot transfer very much data, such as one being used as a\n   * circuit relay connection. Protocols need to explicitly opt-in to being run\n   * over transient connections.\n   */\n  transient: boolean\n\n  /**\n   * Create a new stream on this connection and negotiate one of the passed protocols\n   */\n  newStream(protocols: string | string[], options?: NewStreamOptions): Promise<Stream>\n\n  /**\n   * Gracefully close the connection. All queued data will be written to the\n   * underlying transport.\n   */\n  close(options?: AbortOptions): Promise<void>\n\n  /**\n   * Immediately close the connection, any queued data will be discarded\n   */\n  abort(err: Error): void\n\n  /**\n   * The connection logger\n   */\n  log: Logger\n}\n\nexport const connectionSymbol = Symbol.for('@libp2p/connection')\n\nexport function isConnection (other: any): other is Connection {\n  return other != null && Boolean(other[connectionSymbol])\n}\n\nexport interface ConnectionProtector {\n  /**\n   * Takes a given Connection and creates a private encryption stream\n   * between its two peers from the PSK the Protector instance was\n   * created with.\n   */\n  protect(connection: MultiaddrConnection): Promise<MultiaddrConnection>\n}\n\nexport interface MultiaddrConnectionTimeline {\n  /**\n   * When the connection was opened\n   */\n  open: number\n\n  /**\n   * When the MultiaddrConnection was upgraded to a Connection - the type of\n   * connection encryption and multiplexing was negotiated.\n   */\n  upgraded?: number\n\n  /**\n   * When the connection was closed.\n   */\n  close?: number\n}\n\n/**\n * A MultiaddrConnection is returned by transports after dialing\n * a peer. It is a low-level primitive and is the raw connection\n * without encryption or stream multiplexing.\n */\nexport interface MultiaddrConnection extends Duplex<AsyncGenerator<Uint8Array | Uint8ArrayList>> {\n  /**\n   * Gracefully close the connection. All queued data will be written to the\n   * underlying transport.\n   */\n  close(options?: AbortOptions): Promise<void>\n\n  /**\n   * Immediately close the connection, any queued data will be discarded\n   */\n  abort(err: Error): void\n\n  /**\n   * The address of the remote end of the connection\n   */\n  remoteAddr: Multiaddr\n\n  /**\n   * When connection lifecycle events occurred\n   */\n  timeline: MultiaddrConnectionTimeline\n\n  /**\n   * The multiaddr connection logger\n   */\n  log: Logger\n}\n", "import type { RoutingOptions } from '../index.js'\nimport type { PeerInfo } from '../peer-info/index.js'\nimport type { CID } from 'multiformats/cid'\n\n/**\n * Any object that implements this Symbol as a property should return a\n * ContentRouting instance as the property value, similar to how\n * `Symbol.Iterable` can be used to return an `Iterable` from an `Iterator`.\n *\n * @example\n *\n * ```TypeScript\n * import { contentRoutingSymbol, ContentRouting } from '@libp2p/content-routing'\n *\n * class MyContentRouter implements ContentRouting {\n *   get [contentRoutingSymbol] () {\n *     return this\n *   }\n *\n *   // ...other methods\n * }\n * ```\n */\nexport const contentRoutingSymbol = Symbol.for('@libp2p/content-routing')\n\n/**\n * Implementers of this interface can provide a ContentRouting implementation to\n * interested callers.\n */\nexport interface ContentRoutingProvider {\n  [contentRoutingSymbol]: ContentRouting\n}\n\nexport interface ContentRouting {\n  /**\n   * The implementation of this method should ensure that network peers know the\n   * caller can provide content that corresponds to the passed CID.\n   *\n   * @example\n   *\n   * ```TypeScript\n   * // ...\n   * await contentRouting.provide(cid)\n   * ```\n   */\n  provide(cid: CID, options?: RoutingOptions): Promise<void>\n\n  /**\n   * Find the providers of the passed CID.\n   *\n   * @example\n   *\n   * ```TypeScript\n   * // Iterate over the providers found for the given cid\n   * for await (const provider of contentRouting.findProviders(cid)) {\n   *  console.log(provider.id, provider.multiaddrs)\n   * }\n   * ```\n   */\n  findProviders(cid: CID, options?: RoutingOptions): AsyncIterable<PeerInfo>\n\n  /**\n   * Puts a value corresponding to the passed key in a way that can later be\n   * retrieved by another network peer using the get method.\n   *\n   * @example\n   *\n   * ```TypeScript\n   * // ...\n   * const key = '/key'\n   * const value = uint8ArrayFromString('oh hello there')\n   *\n   * await contentRouting.put(key, value)\n   * ```\n   */\n  put(key: Uint8Array, value: Uint8Array, options?: RoutingOptions): Promise<void>\n\n  /**\n   * Retrieves a value from the network corresponding to the passed key.\n   *\n   * @example\n   *\n   * ```TypeScript\n   * // ...\n   *\n   * const key = '/key'\n   * const value = await contentRouting.get(key)\n   * ```\n   */\n  get(key: Uint8Array, options?: RoutingOptions): Promise<Uint8Array>\n}\n", "import type { TypedEventTarget } from '../event-target.js'\nimport type { PeerInfo } from '../peer-info/index.js'\n\n/**\n * Any object that implements this Symbol as a property should return a\n * PeerDiscovery instance as the property value, similar to how\n * `Symbol.Iterable` can be used to return an `Iterable` from an `Iterator`.\n *\n * @example\n *\n * ```TypeScript\n * import { peerDiscovery, PeerDiscovery } from '@libp2p/peer-discovery'\n *\n * class MyPeerDiscoverer implements PeerDiscovery {\n *   get [peerDiscovery] () {\n *     return this\n *   }\n *\n *   // ...other methods\n * }\n * ```\n */\nexport const peerDiscoverySymbol = Symbol.for('@libp2p/peer-discovery')\n\n/**\n * Implementers of this interface can provide a PeerDiscovery implementation to\n * interested callers.\n */\nexport interface PeerDiscoveryProvider {\n  [peerDiscoverySymbol]: PeerDiscovery\n}\n\nexport interface PeerDiscoveryEvents {\n  'peer': CustomEvent<PeerInfo>\n}\n\nexport interface PeerDiscovery extends TypedEventTarget<PeerDiscoveryEvents> {}\n", "import type { KeyType } from '../keys/index.js'\nimport type { CID } from 'multiformats/cid'\nimport type { MultihashDigest } from 'multiformats/hashes/interface'\n\nexport type PeerIdType = KeyType | string\n\nexport interface RSAPeerId extends PeerId {\n  readonly type: 'RSA'\n  readonly publicKey?: Uint8Array\n}\n\nexport interface Ed25519PeerId extends PeerId {\n  readonly type: 'Ed25519'\n  readonly publicKey: Uint8Array\n}\n\nexport interface Secp256k1PeerId extends PeerId {\n  readonly type: 'secp256k1'\n  readonly publicKey: Uint8Array\n}\n\nexport interface PeerId {\n  type: PeerIdType\n  multihash: MultihashDigest\n  privateKey?: Uint8Array\n  publicKey?: Uint8Array\n\n  toString(): string\n  toCID(): CID\n  toBytes(): Uint8Array\n  equals(other?: PeerId | Uint8Array | string): boolean\n}\n\nexport const peerIdSymbol = Symbol.for('@libp2p/peer-id')\n\nexport function isPeerId (other: any): other is PeerId {\n  return other != null && Boolean(other[peerIdSymbol])\n}\n", "import type { RoutingOptions } from '../index.js'\nimport type { PeerId } from '../peer-id/index.js'\nimport type { PeerInfo } from '../peer-info/index.js'\n\n/**\n * Any object that implements this Symbol as a property should return a\n * PeerRouting instance as the property value, similar to how\n * `Symbol.Iterable` can be used to return an `Iterable` from an `Iterator`.\n *\n * @example\n *\n * ```TypeScript\n * import { peerRouting, PeerRouting } from '@libp2p/peer-routing'\n *\n * class MyPeerRouter implements PeerRouting {\n *   get [peerRouting] () {\n *     return this\n *   }\n *\n *   // ...other methods\n * }\n * ```\n */\nexport const peerRoutingSymbol = Symbol.for('@libp2p/peer-routing')\n\n/**\n * Implementers of this interface can provide a PeerRouting implementation to\n * interested callers.\n */\nexport interface PeerRoutingProvider {\n  [peerRoutingSymbol]: PeerRouting\n}\n\nexport interface PeerRouting {\n  /**\n   * Searches the network for peer info corresponding to the passed peer id.\n   *\n   * @example\n   *\n   * ```TypeScript\n   * // ...\n   * const peer = await peerRouting.findPeer(peerId, options)\n   * ```\n   */\n  findPeer(peerId: PeerId, options?: RoutingOptions): Promise<PeerInfo>\n\n  /**\n   * Search the network for peers that are closer to the passed key. Peer\n   * info should be yielded in ever-increasing closeness to the key.\n   *\n   * @example\n   *\n   * ```TypeScript\n   * // Iterate over the closest peers found for the given key\n   * for await (const peer of peerRouting.getClosestPeers(key)) {\n   *   console.log(peer.id, peer.multiaddrs)\n   * }\n   * ```\n   */\n  getClosestPeers(key: Uint8Array, options?: RoutingOptions): AsyncIterable<PeerInfo>\n}\n", "export const KEEP_ALIVE = 'keep-alive'\n", "/**\n * Implemented by components that have a lifecycle\n */\nexport interface Startable {\n  /**\n   * If implemented, this method will be invoked before the start method.\n   *\n   * It should not assume any other components have been started.\n   */\n  beforeStart?(): void | Promise<void>\n\n  /**\n   * This method will be invoked to start the component.\n   *\n   * It should not assume that any other components have been started.\n   */\n  start(): void | Promise<void>\n\n  /**\n   * If implemented, this method will be invoked after the start method.\n   *\n   * All other components will have had their start method invoked before this method is called.\n   */\n  afterStart?(): void | Promise<void>\n\n  /**\n   * If implemented, this method will be invoked before the stop method.\n   *\n   * Any other components will still be running when this method is called.\n   */\n  beforeStop?(): void | Promise<void>\n\n  /**\n   * This method will be invoked to stop the component.\n   *\n   * It should not assume any other components are running when it is called.\n   */\n  stop(): void | Promise<void>\n\n  /**\n   * If implemented, this method will be invoked after the stop method.\n   *\n   * All other components will have had their stop method invoked before this method is called.\n   */\n  afterStop?(): void | Promise<void>\n}\n\nexport function isStartable (obj: any): obj is Startable {\n  return obj != null && typeof obj.start === 'function' && typeof obj.stop === 'function'\n}\n\nexport async function start (...objs: any[]): Promise<void> {\n  const startables: Startable[] = []\n\n  for (const obj of objs) {\n    if (isStartable(obj)) {\n      startables.push(obj)\n    }\n  }\n\n  await Promise.all(\n    startables.map(async s => {\n      if (s.beforeStart != null) {\n        await s.beforeStart()\n      }\n    })\n  )\n\n  await Promise.all(\n    startables.map(async s => {\n      await s.start()\n    })\n  )\n\n  await Promise.all(\n    startables.map(async s => {\n      if (s.afterStart != null) {\n        await s.afterStart()\n      }\n    })\n  )\n}\n\nexport async function stop (...objs: any[]): Promise<void> {\n  const startables: Startable[] = []\n\n  for (const obj of objs) {\n    if (isStartable(obj)) {\n      startables.push(obj)\n    }\n  }\n\n  await Promise.all(\n    startables.map(async s => {\n      if (s.beforeStop != null) {\n        await s.beforeStop()\n      }\n    })\n  )\n\n  await Promise.all(\n    startables.map(async s => {\n      await s.stop()\n    })\n  )\n\n  await Promise.all(\n    startables.map(async s => {\n      if (s.afterStop != null) {\n        await s.afterStop()\n      }\n    })\n  )\n}\n"],
  "mappings": "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",
  "names": ["TopicValidatorResult", "FaultTolerance", "setMaxListeners", "setMaxListeners"]
}
