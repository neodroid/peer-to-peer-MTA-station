{
  "version": 3,
  "sources": ["../../retry/lib/retry_operation.js", "../../retry/lib/retry.js", "../../retry/index.js", "../../@libp2p/circuit-relay-v2/src/constants.ts", "../../@libp2p/circuit-relay-v2/src/pb/index.ts", "../../@libp2p/circuit-relay-v2/src/utils.ts", "../../p-retry/index.js", "../../is-network-error/index.js", "../../@libp2p/circuit-relay-v2/src/server/advert-service.ts", "../../@libp2p/circuit-relay-v2/src/server/reservation-store.ts", "../../@libp2p/circuit-relay-v2/src/server/reservation-voucher.ts", "../../@libp2p/circuit-relay-v2/src/server/index.ts", "../../@libp2p/circuit-relay-v2/src/transport/discovery.ts", "../../@libp2p/circuit-relay-v2/src/transport/reservation-store.ts", "../../@libp2p/utils/src/stream-to-ma-conn.ts", "../../@libp2p/circuit-relay-v2/src/transport/listener.ts", "../../@libp2p/circuit-relay-v2/src/transport/transport.ts", "../../@libp2p/circuit-relay-v2/src/transport/index.ts"],
  "sourcesContent": ["function RetryOperation(timeouts, options) {\n  // Compatibility for the old (timeouts, retryForever) signature\n  if (typeof options === 'boolean') {\n    options = { forever: options };\n  }\n\n  this._originalTimeouts = JSON.parse(JSON.stringify(timeouts));\n  this._timeouts = timeouts;\n  this._options = options || {};\n  this._maxRetryTime = options && options.maxRetryTime || Infinity;\n  this._fn = null;\n  this._errors = [];\n  this._attempts = 1;\n  this._operationTimeout = null;\n  this._operationTimeoutCb = null;\n  this._timeout = null;\n  this._operationStart = null;\n  this._timer = null;\n\n  if (this._options.forever) {\n    this._cachedTimeouts = this._timeouts.slice(0);\n  }\n}\nmodule.exports = RetryOperation;\n\nRetryOperation.prototype.reset = function() {\n  this._attempts = 1;\n  this._timeouts = this._originalTimeouts.slice(0);\n}\n\nRetryOperation.prototype.stop = function() {\n  if (this._timeout) {\n    clearTimeout(this._timeout);\n  }\n  if (this._timer) {\n    clearTimeout(this._timer);\n  }\n\n  this._timeouts       = [];\n  this._cachedTimeouts = null;\n};\n\nRetryOperation.prototype.retry = function(err) {\n  if (this._timeout) {\n    clearTimeout(this._timeout);\n  }\n\n  if (!err) {\n    return false;\n  }\n  var currentTime = new Date().getTime();\n  if (err && currentTime - this._operationStart >= this._maxRetryTime) {\n    this._errors.push(err);\n    this._errors.unshift(new Error('RetryOperation timeout occurred'));\n    return false;\n  }\n\n  this._errors.push(err);\n\n  var timeout = this._timeouts.shift();\n  if (timeout === undefined) {\n    if (this._cachedTimeouts) {\n      // retry forever, only keep last error\n      this._errors.splice(0, this._errors.length - 1);\n      timeout = this._cachedTimeouts.slice(-1);\n    } else {\n      return false;\n    }\n  }\n\n  var self = this;\n  this._timer = setTimeout(function() {\n    self._attempts++;\n\n    if (self._operationTimeoutCb) {\n      self._timeout = setTimeout(function() {\n        self._operationTimeoutCb(self._attempts);\n      }, self._operationTimeout);\n\n      if (self._options.unref) {\n          self._timeout.unref();\n      }\n    }\n\n    self._fn(self._attempts);\n  }, timeout);\n\n  if (this._options.unref) {\n      this._timer.unref();\n  }\n\n  return true;\n};\n\nRetryOperation.prototype.attempt = function(fn, timeoutOps) {\n  this._fn = fn;\n\n  if (timeoutOps) {\n    if (timeoutOps.timeout) {\n      this._operationTimeout = timeoutOps.timeout;\n    }\n    if (timeoutOps.cb) {\n      this._operationTimeoutCb = timeoutOps.cb;\n    }\n  }\n\n  var self = this;\n  if (this._operationTimeoutCb) {\n    this._timeout = setTimeout(function() {\n      self._operationTimeoutCb();\n    }, self._operationTimeout);\n  }\n\n  this._operationStart = new Date().getTime();\n\n  this._fn(this._attempts);\n};\n\nRetryOperation.prototype.try = function(fn) {\n  console.log('Using RetryOperation.try() is deprecated');\n  this.attempt(fn);\n};\n\nRetryOperation.prototype.start = function(fn) {\n  console.log('Using RetryOperation.start() is deprecated');\n  this.attempt(fn);\n};\n\nRetryOperation.prototype.start = RetryOperation.prototype.try;\n\nRetryOperation.prototype.errors = function() {\n  return this._errors;\n};\n\nRetryOperation.prototype.attempts = function() {\n  return this._attempts;\n};\n\nRetryOperation.prototype.mainError = function() {\n  if (this._errors.length === 0) {\n    return null;\n  }\n\n  var counts = {};\n  var mainError = null;\n  var mainErrorCount = 0;\n\n  for (var i = 0; i < this._errors.length; i++) {\n    var error = this._errors[i];\n    var message = error.message;\n    var count = (counts[message] || 0) + 1;\n\n    counts[message] = count;\n\n    if (count >= mainErrorCount) {\n      mainError = error;\n      mainErrorCount = count;\n    }\n  }\n\n  return mainError;\n};\n", "var RetryOperation = require('./retry_operation');\n\nexports.operation = function(options) {\n  var timeouts = exports.timeouts(options);\n  return new RetryOperation(timeouts, {\n      forever: options && (options.forever || options.retries === Infinity),\n      unref: options && options.unref,\n      maxRetryTime: options && options.maxRetryTime\n  });\n};\n\nexports.timeouts = function(options) {\n  if (options instanceof Array) {\n    return [].concat(options);\n  }\n\n  var opts = {\n    retries: 10,\n    factor: 2,\n    minTimeout: 1 * 1000,\n    maxTimeout: Infinity,\n    randomize: false\n  };\n  for (var key in options) {\n    opts[key] = options[key];\n  }\n\n  if (opts.minTimeout > opts.maxTimeout) {\n    throw new Error('minTimeout is greater than maxTimeout');\n  }\n\n  var timeouts = [];\n  for (var i = 0; i < opts.retries; i++) {\n    timeouts.push(this.createTimeout(i, opts));\n  }\n\n  if (options && options.forever && !timeouts.length) {\n    timeouts.push(this.createTimeout(i, opts));\n  }\n\n  // sort the array numerically ascending\n  timeouts.sort(function(a,b) {\n    return a - b;\n  });\n\n  return timeouts;\n};\n\nexports.createTimeout = function(attempt, opts) {\n  var random = (opts.randomize)\n    ? (Math.random() + 1)\n    : 1;\n\n  var timeout = Math.round(random * Math.max(opts.minTimeout, 1) * Math.pow(opts.factor, attempt));\n  timeout = Math.min(timeout, opts.maxTimeout);\n\n  return timeout;\n};\n\nexports.wrap = function(obj, options, methods) {\n  if (options instanceof Array) {\n    methods = options;\n    options = null;\n  }\n\n  if (!methods) {\n    methods = [];\n    for (var key in obj) {\n      if (typeof obj[key] === 'function') {\n        methods.push(key);\n      }\n    }\n  }\n\n  for (var i = 0; i < methods.length; i++) {\n    var method   = methods[i];\n    var original = obj[method];\n\n    obj[method] = function retryWrapper(original) {\n      var op       = exports.operation(options);\n      var args     = Array.prototype.slice.call(arguments, 1);\n      var callback = args.pop();\n\n      args.push(function(err) {\n        if (op.retry(err)) {\n          return;\n        }\n        if (err) {\n          arguments[0] = op.mainError();\n        }\n        callback.apply(this, arguments);\n      });\n\n      op.attempt(function() {\n        original.apply(obj, args);\n      });\n    }.bind(obj, original);\n    obj[method].options = options;\n  }\n};\n", "module.exports = require('./lib/retry');", "const second = 1000\nconst minute = 60 * second\n\n/**\n * Delay before HOP relay service is advertised on the network\n */\nexport const ADVERTISE_BOOT_DELAY = 15 * minute\n\n/**\n * Delay Between HOP relay service advertisements on the network\n */\nexport const ADVERTISE_TTL = 30 * minute\n\n/**\n * Multicodec code\n */\nexport const CIRCUIT_PROTO_CODE = 290\n\n/**\n * Relay HOP relay service namespace for discovery\n */\nexport const RELAY_RENDEZVOUS_NS = '/libp2p/relay'\n\n/**\n * The maximum number of relay reservations the relay server will accept\n */\nexport const DEFAULT_MAX_RESERVATION_STORE_SIZE = 15\n\n/**\n * How often to check for reservation expiry\n */\nexport const DEFAULT_MAX_RESERVATION_CLEAR_INTERVAL = 300 * second\n\n/**\n * How often to check for reservation expiry\n */\nexport const DEFAULT_MAX_RESERVATION_TTL = 2 * 60 * minute\n\nexport const DEFAULT_RESERVATION_CONCURRENCY = 1\n\nexport const RELAY_SOURCE_TAG = 'circuit-relay-source'\n\nexport const RELAY_TAG = 'circuit-relay-relay'\n\n// circuit v2 connection limits\n// https://github.com/libp2p/go-libp2p/blob/master/p2p/protocol/circuitv2/relay/resources.go#L61-L66\n\n// 2 min is the default connection duration\nexport const DEFAULT_DURATION_LIMIT = 2 * minute\n\n// 128k is the default data limit\nexport const DEFAULT_DATA_LIMIT = BigInt(1 << 17)\n\n/**\n * The hop protocol\n */\nexport const RELAY_V2_HOP_CODEC = '/libp2p/circuit/relay/0.2.0/hop'\n\n/**\n * the stop protocol\n */\nexport const RELAY_V2_STOP_CODEC = '/libp2p/circuit/relay/0.2.0/stop'\n\n/**\n * Hop messages must be exchanged inside this timeout\n */\nexport const DEFAULT_HOP_TIMEOUT = 30 * second\n\n/**\n * How long to wait before starting to advertise the relay service\n */\nexport const DEFAULT_ADVERT_BOOT_DELAY = 30 * second\n\nexport const MAX_CONNECTIONS = 300\n\nexport const ERR_NO_ROUTERS_AVAILABLE = 'ERR_NO_ROUTERS_AVAILABLE'\nexport const ERR_RELAYED_DIAL = 'ERR_RELAYED_DIAL'\nexport const ERR_HOP_REQUEST_FAILED = 'ERR_HOP_REQUEST_FAILED'\nexport const ERR_TRANSFER_LIMIT_EXCEEDED = 'ERR_TRANSFER_LIMIT_EXCEEDED'\n", "/* eslint-disable import/export */\n/* eslint-disable complexity */\n/* eslint-disable @typescript-eslint/no-namespace */\n/* eslint-disable @typescript-eslint/no-unnecessary-boolean-literal-compare */\n/* eslint-disable @typescript-eslint/no-empty-interface */\n\nimport { enumeration, encodeMessage, decodeMessage, message } from 'protons-runtime'\nimport type { Codec } from 'protons-runtime'\nimport type { Uint8ArrayList } from 'uint8arraylist'\n\nexport interface HopMessage {\n  type?: HopMessage.Type\n  peer?: Peer\n  reservation?: Reservation\n  limit?: Limit\n  status?: Status\n}\n\nexport namespace HopMessage {\n  export enum Type {\n    RESERVE = 'RESERVE',\n    CONNECT = 'CONNECT',\n    STATUS = 'STATUS'\n  }\n\n  enum __TypeValues {\n    RESERVE = 0,\n    CONNECT = 1,\n    STATUS = 2\n  }\n\n  export namespace Type {\n    export const codec = (): Codec<Type> => {\n      return enumeration<Type>(__TypeValues)\n    }\n  }\n\n  let _codec: Codec<HopMessage>\n\n  export const codec = (): Codec<HopMessage> => {\n    if (_codec == null) {\n      _codec = message<HopMessage>((obj, w, opts = {}) => {\n        if (opts.lengthDelimited !== false) {\n          w.fork()\n        }\n\n        if (obj.type != null) {\n          w.uint32(8)\n          HopMessage.Type.codec().encode(obj.type, w)\n        }\n\n        if (obj.peer != null) {\n          w.uint32(18)\n          Peer.codec().encode(obj.peer, w)\n        }\n\n        if (obj.reservation != null) {\n          w.uint32(26)\n          Reservation.codec().encode(obj.reservation, w)\n        }\n\n        if (obj.limit != null) {\n          w.uint32(34)\n          Limit.codec().encode(obj.limit, w)\n        }\n\n        if (obj.status != null) {\n          w.uint32(40)\n          Status.codec().encode(obj.status, w)\n        }\n\n        if (opts.lengthDelimited !== false) {\n          w.ldelim()\n        }\n      }, (reader, length) => {\n        const obj: any = {}\n\n        const end = length == null ? reader.len : reader.pos + length\n\n        while (reader.pos < end) {\n          const tag = reader.uint32()\n\n          switch (tag >>> 3) {\n            case 1:\n              obj.type = HopMessage.Type.codec().decode(reader)\n              break\n            case 2:\n              obj.peer = Peer.codec().decode(reader, reader.uint32())\n              break\n            case 3:\n              obj.reservation = Reservation.codec().decode(reader, reader.uint32())\n              break\n            case 4:\n              obj.limit = Limit.codec().decode(reader, reader.uint32())\n              break\n            case 5:\n              obj.status = Status.codec().decode(reader)\n              break\n            default:\n              reader.skipType(tag & 7)\n              break\n          }\n        }\n\n        return obj\n      })\n    }\n\n    return _codec\n  }\n\n  export const encode = (obj: Partial<HopMessage>): Uint8Array => {\n    return encodeMessage(obj, HopMessage.codec())\n  }\n\n  export const decode = (buf: Uint8Array | Uint8ArrayList): HopMessage => {\n    return decodeMessage(buf, HopMessage.codec())\n  }\n}\n\nexport interface StopMessage {\n  type?: StopMessage.Type\n  peer?: Peer\n  limit?: Limit\n  status?: Status\n}\n\nexport namespace StopMessage {\n  export enum Type {\n    CONNECT = 'CONNECT',\n    STATUS = 'STATUS'\n  }\n\n  enum __TypeValues {\n    CONNECT = 0,\n    STATUS = 1\n  }\n\n  export namespace Type {\n    export const codec = (): Codec<Type> => {\n      return enumeration<Type>(__TypeValues)\n    }\n  }\n\n  let _codec: Codec<StopMessage>\n\n  export const codec = (): Codec<StopMessage> => {\n    if (_codec == null) {\n      _codec = message<StopMessage>((obj, w, opts = {}) => {\n        if (opts.lengthDelimited !== false) {\n          w.fork()\n        }\n\n        if (obj.type != null) {\n          w.uint32(8)\n          StopMessage.Type.codec().encode(obj.type, w)\n        }\n\n        if (obj.peer != null) {\n          w.uint32(18)\n          Peer.codec().encode(obj.peer, w)\n        }\n\n        if (obj.limit != null) {\n          w.uint32(26)\n          Limit.codec().encode(obj.limit, w)\n        }\n\n        if (obj.status != null) {\n          w.uint32(32)\n          Status.codec().encode(obj.status, w)\n        }\n\n        if (opts.lengthDelimited !== false) {\n          w.ldelim()\n        }\n      }, (reader, length) => {\n        const obj: any = {}\n\n        const end = length == null ? reader.len : reader.pos + length\n\n        while (reader.pos < end) {\n          const tag = reader.uint32()\n\n          switch (tag >>> 3) {\n            case 1:\n              obj.type = StopMessage.Type.codec().decode(reader)\n              break\n            case 2:\n              obj.peer = Peer.codec().decode(reader, reader.uint32())\n              break\n            case 3:\n              obj.limit = Limit.codec().decode(reader, reader.uint32())\n              break\n            case 4:\n              obj.status = Status.codec().decode(reader)\n              break\n            default:\n              reader.skipType(tag & 7)\n              break\n          }\n        }\n\n        return obj\n      })\n    }\n\n    return _codec\n  }\n\n  export const encode = (obj: Partial<StopMessage>): Uint8Array => {\n    return encodeMessage(obj, StopMessage.codec())\n  }\n\n  export const decode = (buf: Uint8Array | Uint8ArrayList): StopMessage => {\n    return decodeMessage(buf, StopMessage.codec())\n  }\n}\n\nexport interface Peer {\n  id: Uint8Array\n  addrs: Uint8Array[]\n}\n\nexport namespace Peer {\n  let _codec: Codec<Peer>\n\n  export const codec = (): Codec<Peer> => {\n    if (_codec == null) {\n      _codec = message<Peer>((obj, w, opts = {}) => {\n        if (opts.lengthDelimited !== false) {\n          w.fork()\n        }\n\n        if ((obj.id != null && obj.id.byteLength > 0)) {\n          w.uint32(10)\n          w.bytes(obj.id)\n        }\n\n        if (obj.addrs != null) {\n          for (const value of obj.addrs) {\n            w.uint32(18)\n            w.bytes(value)\n          }\n        }\n\n        if (opts.lengthDelimited !== false) {\n          w.ldelim()\n        }\n      }, (reader, length) => {\n        const obj: any = {\n          id: new Uint8Array(0),\n          addrs: []\n        }\n\n        const end = length == null ? reader.len : reader.pos + length\n\n        while (reader.pos < end) {\n          const tag = reader.uint32()\n\n          switch (tag >>> 3) {\n            case 1:\n              obj.id = reader.bytes()\n              break\n            case 2:\n              obj.addrs.push(reader.bytes())\n              break\n            default:\n              reader.skipType(tag & 7)\n              break\n          }\n        }\n\n        return obj\n      })\n    }\n\n    return _codec\n  }\n\n  export const encode = (obj: Partial<Peer>): Uint8Array => {\n    return encodeMessage(obj, Peer.codec())\n  }\n\n  export const decode = (buf: Uint8Array | Uint8ArrayList): Peer => {\n    return decodeMessage(buf, Peer.codec())\n  }\n}\n\nexport interface Reservation {\n  expire: bigint\n  addrs: Uint8Array[]\n  voucher?: Uint8Array\n}\n\nexport namespace Reservation {\n  let _codec: Codec<Reservation>\n\n  export const codec = (): Codec<Reservation> => {\n    if (_codec == null) {\n      _codec = message<Reservation>((obj, w, opts = {}) => {\n        if (opts.lengthDelimited !== false) {\n          w.fork()\n        }\n\n        if ((obj.expire != null && obj.expire !== 0n)) {\n          w.uint32(8)\n          w.uint64(obj.expire)\n        }\n\n        if (obj.addrs != null) {\n          for (const value of obj.addrs) {\n            w.uint32(18)\n            w.bytes(value)\n          }\n        }\n\n        if (obj.voucher != null) {\n          w.uint32(26)\n          w.bytes(obj.voucher)\n        }\n\n        if (opts.lengthDelimited !== false) {\n          w.ldelim()\n        }\n      }, (reader, length) => {\n        const obj: any = {\n          expire: 0n,\n          addrs: []\n        }\n\n        const end = length == null ? reader.len : reader.pos + length\n\n        while (reader.pos < end) {\n          const tag = reader.uint32()\n\n          switch (tag >>> 3) {\n            case 1:\n              obj.expire = reader.uint64()\n              break\n            case 2:\n              obj.addrs.push(reader.bytes())\n              break\n            case 3:\n              obj.voucher = reader.bytes()\n              break\n            default:\n              reader.skipType(tag & 7)\n              break\n          }\n        }\n\n        return obj\n      })\n    }\n\n    return _codec\n  }\n\n  export const encode = (obj: Partial<Reservation>): Uint8Array => {\n    return encodeMessage(obj, Reservation.codec())\n  }\n\n  export const decode = (buf: Uint8Array | Uint8ArrayList): Reservation => {\n    return decodeMessage(buf, Reservation.codec())\n  }\n}\n\nexport interface Limit {\n  duration?: number\n  data?: bigint\n}\n\nexport namespace Limit {\n  let _codec: Codec<Limit>\n\n  export const codec = (): Codec<Limit> => {\n    if (_codec == null) {\n      _codec = message<Limit>((obj, w, opts = {}) => {\n        if (opts.lengthDelimited !== false) {\n          w.fork()\n        }\n\n        if (obj.duration != null) {\n          w.uint32(8)\n          w.uint32(obj.duration)\n        }\n\n        if (obj.data != null) {\n          w.uint32(16)\n          w.uint64(obj.data)\n        }\n\n        if (opts.lengthDelimited !== false) {\n          w.ldelim()\n        }\n      }, (reader, length) => {\n        const obj: any = {}\n\n        const end = length == null ? reader.len : reader.pos + length\n\n        while (reader.pos < end) {\n          const tag = reader.uint32()\n\n          switch (tag >>> 3) {\n            case 1:\n              obj.duration = reader.uint32()\n              break\n            case 2:\n              obj.data = reader.uint64()\n              break\n            default:\n              reader.skipType(tag & 7)\n              break\n          }\n        }\n\n        return obj\n      })\n    }\n\n    return _codec\n  }\n\n  export const encode = (obj: Partial<Limit>): Uint8Array => {\n    return encodeMessage(obj, Limit.codec())\n  }\n\n  export const decode = (buf: Uint8Array | Uint8ArrayList): Limit => {\n    return decodeMessage(buf, Limit.codec())\n  }\n}\n\nexport enum Status {\n  UNUSED = 'UNUSED',\n  OK = 'OK',\n  RESERVATION_REFUSED = 'RESERVATION_REFUSED',\n  RESOURCE_LIMIT_EXCEEDED = 'RESOURCE_LIMIT_EXCEEDED',\n  PERMISSION_DENIED = 'PERMISSION_DENIED',\n  CONNECTION_FAILED = 'CONNECTION_FAILED',\n  NO_RESERVATION = 'NO_RESERVATION',\n  MALFORMED_MESSAGE = 'MALFORMED_MESSAGE',\n  UNEXPECTED_MESSAGE = 'UNEXPECTED_MESSAGE'\n}\n\nenum __StatusValues {\n  UNUSED = 0,\n  OK = 100,\n  RESERVATION_REFUSED = 200,\n  RESOURCE_LIMIT_EXCEEDED = 201,\n  PERMISSION_DENIED = 202,\n  CONNECTION_FAILED = 203,\n  NO_RESERVATION = 204,\n  MALFORMED_MESSAGE = 400,\n  UNEXPECTED_MESSAGE = 401\n}\n\nexport namespace Status {\n  export const codec = (): Codec<Status> => {\n    return enumeration<Status>(__StatusValues)\n  }\n}\nexport interface ReservationVoucher {\n  relay: Uint8Array\n  peer: Uint8Array\n  expiration: bigint\n}\n\nexport namespace ReservationVoucher {\n  let _codec: Codec<ReservationVoucher>\n\n  export const codec = (): Codec<ReservationVoucher> => {\n    if (_codec == null) {\n      _codec = message<ReservationVoucher>((obj, w, opts = {}) => {\n        if (opts.lengthDelimited !== false) {\n          w.fork()\n        }\n\n        if ((obj.relay != null && obj.relay.byteLength > 0)) {\n          w.uint32(10)\n          w.bytes(obj.relay)\n        }\n\n        if ((obj.peer != null && obj.peer.byteLength > 0)) {\n          w.uint32(18)\n          w.bytes(obj.peer)\n        }\n\n        if ((obj.expiration != null && obj.expiration !== 0n)) {\n          w.uint32(24)\n          w.uint64(obj.expiration)\n        }\n\n        if (opts.lengthDelimited !== false) {\n          w.ldelim()\n        }\n      }, (reader, length) => {\n        const obj: any = {\n          relay: new Uint8Array(0),\n          peer: new Uint8Array(0),\n          expiration: 0n\n        }\n\n        const end = length == null ? reader.len : reader.pos + length\n\n        while (reader.pos < end) {\n          const tag = reader.uint32()\n\n          switch (tag >>> 3) {\n            case 1:\n              obj.relay = reader.bytes()\n              break\n            case 2:\n              obj.peer = reader.bytes()\n              break\n            case 3:\n              obj.expiration = reader.uint64()\n              break\n            default:\n              reader.skipType(tag & 7)\n              break\n          }\n        }\n\n        return obj\n      })\n    }\n\n    return _codec\n  }\n\n  export const encode = (obj: Partial<ReservationVoucher>): Uint8Array => {\n    return encodeMessage(obj, ReservationVoucher.codec())\n  }\n\n  export const decode = (buf: Uint8Array | Uint8ArrayList): ReservationVoucher => {\n    return decodeMessage(buf, ReservationVoucher.codec())\n  }\n}\n", "import { CodeError } from '@libp2p/interface'\nimport { anySignal } from 'any-signal'\nimport { CID } from 'multiformats/cid'\nimport { sha256 } from 'multiformats/hashes/sha2'\nimport { ERR_TRANSFER_LIMIT_EXCEEDED } from './constants.js'\nimport type { Limit } from './pb/index.js'\nimport type { LoggerOptions, Stream } from '@libp2p/interface'\nimport type { Source } from 'it-stream-types'\nimport type { Uint8ArrayList } from 'uint8arraylist'\n\nasync function * countStreamBytes (source: Source<Uint8Array | Uint8ArrayList>, limit: { remaining: bigint }, options: LoggerOptions): AsyncGenerator<Uint8Array | Uint8ArrayList, void, unknown> {\n  const limitBytes = limit.remaining\n\n  for await (const buf of source) {\n    const len = BigInt(buf.byteLength)\n\n    if ((limit.remaining - len) < 0) {\n      // this is a safe downcast since len is guarantee to be in the range for a number\n      const remaining = Number(limit.remaining)\n      limit.remaining = 0n\n\n      try {\n        if (remaining !== 0) {\n          yield buf.subarray(0, remaining)\n        }\n      } catch (err: any) {\n        options.log.error(err)\n      }\n\n      throw new CodeError(`data limit of ${limitBytes} bytes exceeded`, ERR_TRANSFER_LIMIT_EXCEEDED)\n    }\n\n    limit.remaining -= len\n    yield buf\n  }\n}\n\nexport function createLimitedRelay (src: Stream, dst: Stream, abortSignal: AbortSignal, limit: Limit | undefined, options: LoggerOptions): void {\n  function abortStreams (err: Error): void {\n    src.abort(err)\n    dst.abort(err)\n  }\n\n  const signals = [abortSignal]\n\n  if (limit?.duration != null) {\n    signals.push(AbortSignal.timeout(limit.duration))\n  }\n\n  const signal = anySignal(signals)\n\n  let srcDstFinished = false\n  let dstSrcFinished = false\n\n  let dataLimit: { remaining: bigint } | undefined\n\n  if (limit?.data != null) {\n    dataLimit = {\n      remaining: limit.data\n    }\n  }\n\n  queueMicrotask(() => {\n    const onAbort = (): void => {\n      dst.abort(new CodeError(`duration limit of ${limit?.duration} ms exceeded`, ERR_TRANSFER_LIMIT_EXCEEDED))\n    }\n\n    signal.addEventListener('abort', onAbort, { once: true })\n\n    void dst.sink(dataLimit == null ? src.source : countStreamBytes(src.source, dataLimit, options))\n      .catch(err => {\n        options.log.error('error while relaying streams src -> dst', err)\n        abortStreams(err)\n      })\n      .finally(() => {\n        srcDstFinished = true\n\n        if (dstSrcFinished) {\n          signal.removeEventListener('abort', onAbort)\n          signal.clear()\n        }\n      })\n  })\n\n  queueMicrotask(() => {\n    const onAbort = (): void => {\n      src.abort(new CodeError(`duration limit of ${limit?.duration} ms exceeded`, ERR_TRANSFER_LIMIT_EXCEEDED))\n    }\n\n    signal.addEventListener('abort', onAbort, { once: true })\n\n    void src.sink(dataLimit == null ? dst.source : countStreamBytes(dst.source, dataLimit, options))\n      .catch(err => {\n        options.log.error('error while relaying streams dst -> src', err)\n        abortStreams(err)\n      })\n      .finally(() => {\n        dstSrcFinished = true\n\n        if (srcDstFinished) {\n          signal.removeEventListener('abort', onAbort)\n          signal.clear()\n        }\n      })\n  })\n}\n\n/**\n * Convert a namespace string into a cid\n */\nexport async function namespaceToCid (namespace: string): Promise<CID> {\n  const bytes = new TextEncoder().encode(namespace)\n  const hash = await sha256.digest(bytes)\n\n  return CID.createV0(hash)\n}\n\n/**\n * returns number of ms between now and expiration time\n */\nexport function getExpirationMilliseconds (expireTimeSeconds: bigint): number {\n  const expireTimeMillis = expireTimeSeconds * BigInt(1000)\n  const currentTime = new Date().getTime()\n\n  // downcast to number to use with setTimeout\n  return Number(expireTimeMillis - BigInt(currentTime))\n}\n", "import retry from 'retry';\nimport isNetworkError from 'is-network-error';\n\nexport class AbortError extends Error {\n\tconstructor(message) {\n\t\tsuper();\n\n\t\tif (message instanceof Error) {\n\t\t\tthis.originalError = message;\n\t\t\t({message} = message);\n\t\t} else {\n\t\t\tthis.originalError = new Error(message);\n\t\t\tthis.originalError.stack = this.stack;\n\t\t}\n\n\t\tthis.name = 'AbortError';\n\t\tthis.message = message;\n\t}\n}\n\nconst decorateErrorWithCounts = (error, attemptNumber, options) => {\n\t// Minus 1 from attemptNumber because the first attempt does not count as a retry\n\tconst retriesLeft = options.retries - (attemptNumber - 1);\n\n\terror.attemptNumber = attemptNumber;\n\terror.retriesLeft = retriesLeft;\n\treturn error;\n};\n\nexport default async function pRetry(input, options) {\n\treturn new Promise((resolve, reject) => {\n\t\toptions = {\n\t\t\tonFailedAttempt() {},\n\t\t\tretries: 10,\n\t\t\tshouldRetry: () => true,\n\t\t\t...options,\n\t\t};\n\n\t\tconst operation = retry.operation(options);\n\n\t\tconst abortHandler = () => {\n\t\t\toperation.stop();\n\t\t\treject(options.signal?.reason);\n\t\t};\n\n\t\tif (options.signal && !options.signal.aborted) {\n\t\t\toptions.signal.addEventListener('abort', abortHandler, {once: true});\n\t\t}\n\n\t\tconst cleanUp = () => {\n\t\t\toptions.signal?.removeEventListener('abort', abortHandler);\n\t\t\toperation.stop();\n\t\t};\n\n\t\toperation.attempt(async attemptNumber => {\n\t\t\ttry {\n\t\t\t\tconst result = await input(attemptNumber);\n\t\t\t\tcleanUp();\n\t\t\t\tresolve(result);\n\t\t\t} catch (error) {\n\t\t\t\ttry {\n\t\t\t\t\tif (!(error instanceof Error)) {\n\t\t\t\t\t\tthrow new TypeError(`Non-error was thrown: \"${error}\". You should only throw errors.`);\n\t\t\t\t\t}\n\n\t\t\t\t\tif (error instanceof AbortError) {\n\t\t\t\t\t\tthrow error.originalError;\n\t\t\t\t\t}\n\n\t\t\t\t\tif (error instanceof TypeError && !isNetworkError(error)) {\n\t\t\t\t\t\tthrow error;\n\t\t\t\t\t}\n\n\t\t\t\t\tdecorateErrorWithCounts(error, attemptNumber, options);\n\n\t\t\t\t\tif (!(await options.shouldRetry(error))) {\n\t\t\t\t\t\toperation.stop();\n\t\t\t\t\t\treject(error);\n\t\t\t\t\t}\n\n\t\t\t\t\tawait options.onFailedAttempt(error);\n\n\t\t\t\t\tif (!operation.retry(error)) {\n\t\t\t\t\t\tthrow operation.mainError();\n\t\t\t\t\t}\n\t\t\t\t} catch (finalError) {\n\t\t\t\t\tdecorateErrorWithCounts(finalError, attemptNumber, options);\n\t\t\t\t\tcleanUp();\n\t\t\t\t\treject(finalError);\n\t\t\t\t}\n\t\t\t}\n\t\t});\n\t});\n}\n", "const objectToString = Object.prototype.toString;\n\nconst isError = value => objectToString.call(value) === '[object Error]';\n\nconst errorMessages = new Set([\n\t'network error', // Chrome\n\t'Failed to fetch', // Chrome\n\t'NetworkError when attempting to fetch resource.', // Firefox\n\t'The Internet connection appears to be offline.', // Safari 16\n\t'Load failed', // Safari 17+\n\t'Network request failed', // `cross-fetch`\n\t'fetch failed', // Undici (Node.js)\n\t'terminated', // Undici (Node.js)\n]);\n\nexport default function isNetworkError(error) {\n\tconst isValid = error\n\t\t&& isError(error)\n\t\t&& error.name === 'TypeError'\n\t\t&& typeof error.message === 'string';\n\n\tif (!isValid) {\n\t\treturn false;\n\t}\n\n\t// We do an extra check for Safari 17+ as it has a very generic error message.\n\t// Network errors in Safari have no stack.\n\tif (error.message === 'Load failed') {\n\t\treturn error.stack === undefined;\n\t}\n\n\treturn errorMessages.has(error.message);\n}\n", "import { TypedEventEmitter } from '@libp2p/interface'\nimport pRetry from 'p-retry'\nimport {\n  DEFAULT_ADVERT_BOOT_DELAY,\n  ERR_NO_ROUTERS_AVAILABLE,\n  RELAY_RENDEZVOUS_NS\n} from '../constants.js'\nimport { namespaceToCid } from '../utils.js'\nimport type { ComponentLogger, Logger, ContentRouting, Startable } from '@libp2p/interface'\n\nexport interface AdvertServiceInit {\n  /**\n   * How long to wait after startup to begin advertising the service\n   * - if some configured content routers take a while to warm up (for\n   * example, the DHT needs some peers to be able to publish) this\n   * value should be high enough that they will have warmed up\n   */\n  bootDelay?: number\n}\n\nexport interface AdvertServiceComponents {\n  contentRouting: ContentRouting\n  logger: ComponentLogger\n}\n\nexport interface AdvertServiceEvents {\n  'advert:success': CustomEvent<unknown>\n  'advert:error': CustomEvent<Error>\n}\n\nexport class AdvertService extends TypedEventEmitter<AdvertServiceEvents> implements Startable {\n  private readonly contentRouting: ContentRouting\n  private timeout?: any\n  private started: boolean\n  private readonly bootDelay: number\n  private readonly log: Logger\n\n  /**\n   * Creates an instance of Relay\n   */\n  constructor (components: AdvertServiceComponents, init?: AdvertServiceInit) {\n    super()\n\n    this.log = components.logger.forComponent('libp2p:circuit-relay:advert-service')\n    this.contentRouting = components.contentRouting\n    this.bootDelay = init?.bootDelay ?? DEFAULT_ADVERT_BOOT_DELAY\n    this.started = false\n  }\n\n  isStarted (): boolean {\n    return this.started\n  }\n\n  /**\n   * Start Relay service\n   */\n  start (): void {\n    if (this.started) {\n      return\n    }\n\n    // Advertise service if HOP enabled and advertising enabled\n    this.timeout = setTimeout(() => {\n      this._advertiseService().catch(err => {\n        this.log.error('could not advertise service', err)\n      })\n    }, this.bootDelay)\n\n    this.started = true\n  }\n\n  /**\n   * Stop Relay service\n   */\n  stop (): void {\n    try {\n      clearTimeout(this.timeout)\n    } catch (err) { }\n\n    this.started = false\n  }\n\n  /**\n   * Advertise hop relay service in the network.\n   */\n  async _advertiseService (): Promise<void> {\n    await pRetry(async () => {\n      try {\n        const cid = await namespaceToCid(RELAY_RENDEZVOUS_NS)\n        await this.contentRouting.provide(cid)\n\n        this.safeDispatchEvent('advert:success', { detail: undefined })\n      } catch (err: any) {\n        this.safeDispatchEvent('advert:error', { detail: err })\n\n        if (err.code === ERR_NO_ROUTERS_AVAILABLE) {\n          this.log.error('a content router, such as a DHT, must be provided in order to advertise the relay service', err)\n          this.stop()\n          return\n        }\n\n        this.log.error('could not advertise service', err)\n        throw err\n      }\n    })\n  }\n}\n", "import { PeerMap } from '@libp2p/peer-collections'\nimport { DEFAULT_DATA_LIMIT, DEFAULT_DURATION_LIMIT, DEFAULT_MAX_RESERVATION_CLEAR_INTERVAL, DEFAULT_MAX_RESERVATION_STORE_SIZE, DEFAULT_MAX_RESERVATION_TTL } from '../constants.js'\nimport { type Limit, Status } from '../pb/index.js'\nimport type { RelayReservation } from '../index.js'\nimport type { RecursivePartial, PeerId, Startable } from '@libp2p/interface'\nimport type { Multiaddr } from '@multiformats/multiaddr'\n\nexport type ReservationStatus = Status.OK | Status.PERMISSION_DENIED | Status.RESERVATION_REFUSED\n\nexport interface ReservationStoreInit {\n  /*\n   * maximum number of reservations allowed, default: 15\n   */\n  maxReservations?: number\n  /*\n   * interval after which stale reservations are cleared, default: 300s\n   */\n  reservationClearInterval?: number\n  /*\n   * apply default relay limits to a new reservation, default: true\n   */\n  applyDefaultLimit?: boolean\n  /**\n   * reservation ttl, default: 2 hours\n   */\n  reservationTtl?: number\n  /**\n   * The maximum time a relayed connection can be open for\n   */\n  defaultDurationLimit?: number\n  /**\n   * The maximum amount of data allowed to be transferred over a relayed connection\n   */\n  defaultDataLimit?: bigint\n}\n\nexport type ReservationStoreOptions = RecursivePartial<ReservationStoreInit>\n\nexport class ReservationStore implements Startable {\n  public readonly reservations = new PeerMap<RelayReservation>()\n  private _started = false\n  private interval: any\n  private readonly maxReservations: number\n  private readonly reservationClearInterval: number\n  private readonly applyDefaultLimit: boolean\n  private readonly reservationTtl: number\n  private readonly defaultDurationLimit: number\n  private readonly defaultDataLimit: bigint\n\n  constructor (options: ReservationStoreOptions = {}) {\n    this.maxReservations = options.maxReservations ?? DEFAULT_MAX_RESERVATION_STORE_SIZE\n    this.reservationClearInterval = options.reservationClearInterval ?? DEFAULT_MAX_RESERVATION_CLEAR_INTERVAL\n    this.applyDefaultLimit = options.applyDefaultLimit !== false\n    this.reservationTtl = options.reservationTtl ?? DEFAULT_MAX_RESERVATION_TTL\n    this.defaultDurationLimit = options.defaultDurationLimit ?? DEFAULT_DURATION_LIMIT\n    this.defaultDataLimit = options.defaultDataLimit ?? DEFAULT_DATA_LIMIT\n  }\n\n  isStarted (): boolean {\n    return this._started\n  }\n\n  start (): void {\n    if (this._started) {\n      return\n    }\n    this._started = true\n    this.interval = setInterval(\n      () => {\n        const now = (new Date()).getTime()\n        this.reservations.forEach((r, k) => {\n          if (r.expire.getTime() < now) {\n            this.reservations.delete(k)\n          }\n        })\n      },\n      this.reservationClearInterval\n    )\n  }\n\n  stop (): void {\n    clearInterval(this.interval)\n  }\n\n  reserve (peer: PeerId, addr: Multiaddr, limit?: Limit): { status: ReservationStatus, expire?: number } {\n    if (this.reservations.size >= this.maxReservations && !this.reservations.has(peer)) {\n      return { status: Status.RESERVATION_REFUSED }\n    }\n\n    const expire = new Date(Date.now() + this.reservationTtl)\n    let checkedLimit: Limit | undefined\n\n    if (this.applyDefaultLimit) {\n      checkedLimit = limit ?? { data: this.defaultDataLimit, duration: this.defaultDurationLimit }\n    }\n\n    this.reservations.set(peer, { addr, expire, limit: checkedLimit })\n\n    // return expiry time in seconds\n    return { status: Status.OK, expire: Math.round(expire.getTime() / 1000) }\n  }\n\n  removeReservation (peer: PeerId): void {\n    this.reservations.delete(peer)\n  }\n\n  hasReservation (dst: PeerId): boolean {\n    return this.reservations.has(dst)\n  }\n\n  get (peer: PeerId): RelayReservation | undefined {\n    return this.reservations.get(peer)\n  }\n}\n", "import { ReservationVoucher } from '../pb/index.js'\nimport type { PeerId, Record } from '@libp2p/interface'\n\nexport interface ReservationVoucherOptions {\n  relay: PeerId\n  peer: PeerId\n  expiration: number\n}\n\nexport class ReservationVoucherRecord implements Record {\n  public readonly domain = 'libp2p-relay-rsvp'\n  public readonly codec = new Uint8Array([0x03, 0x02])\n\n  private readonly relay: PeerId\n  private readonly peer: PeerId\n  private readonly expiration: number\n\n  constructor ({ relay, peer, expiration }: ReservationVoucherOptions) {\n    this.relay = relay\n    this.peer = peer\n    this.expiration = expiration\n  }\n\n  marshal (): Uint8Array {\n    return ReservationVoucher.encode({\n      relay: this.relay.toBytes(),\n      peer: this.peer.toBytes(),\n      expiration: BigInt(this.expiration)\n    })\n  }\n\n  equals (other: Record): boolean {\n    if (!(other instanceof ReservationVoucherRecord)) {\n      return false\n    }\n    if (!this.peer.equals(other.peer)) {\n      return false\n    }\n\n    if (!this.relay.equals(other.relay)) {\n      return false\n    }\n\n    if (this.expiration !== other.expiration) {\n      return false\n    }\n\n    return true\n  }\n}\n", "import { TypedEventEmitter, setMaxListeners } from '@libp2p/interface'\nimport { peerIdFromBytes } from '@libp2p/peer-id'\nimport { RecordEnvelope } from '@libp2p/peer-record'\nimport { type Multiaddr, multiaddr } from '@multiformats/multiaddr'\nimport { pbStream, type ProtobufStream } from 'it-protobuf-stream'\nimport pDefer from 'p-defer'\nimport {\n  CIRCUIT_PROTO_CODE,\n  DEFAULT_HOP_TIMEOUT,\n  MAX_CONNECTIONS,\n  RELAY_SOURCE_TAG,\n  RELAY_V2_HOP_CODEC,\n  RELAY_V2_STOP_CODEC\n} from '../constants.js'\nimport { HopMessage, type Reservation, Status, StopMessage } from '../pb/index.js'\nimport { createLimitedRelay } from '../utils.js'\nimport { AdvertService, type AdvertServiceComponents, type AdvertServiceInit } from './advert-service.js'\nimport { ReservationStore, type ReservationStoreInit } from './reservation-store.js'\nimport { ReservationVoucherRecord } from './reservation-voucher.js'\nimport type { CircuitRelayService, RelayReservation } from '../index.js'\nimport type { ComponentLogger, Logger, Connection, Stream, ConnectionGater, PeerId, PeerStore, Startable } from '@libp2p/interface'\nimport type { AddressManager, ConnectionManager, IncomingStreamData, Registrar } from '@libp2p/interface-internal'\nimport type { PeerMap } from '@libp2p/peer-collections'\n\nconst isRelayAddr = (ma: Multiaddr): boolean => ma.protoCodes().includes(CIRCUIT_PROTO_CODE)\n\nexport interface CircuitRelayServerInit {\n  /**\n   * Incoming hop requests must complete within this time in ms otherwise\n   * the stream will be reset (default: 30s)\n   */\n  hopTimeout?: number\n\n  /**\n   * If true, advertise this service via libp2p content routing to allow\n   * peers to locate us on the network (default: false)\n   */\n  advertise?: boolean | AdvertServiceInit\n\n  /**\n   * Configuration of reservations\n   */\n  reservations?: ReservationStoreInit\n\n  /**\n   * The maximum number of simultaneous HOP inbound streams that can be open at once\n   */\n  maxInboundHopStreams?: number\n\n  /**\n   * The maximum number of simultaneous HOP outbound streams that can be open at once\n   */\n  maxOutboundHopStreams?: number\n\n  /**\n   * The maximum number of simultaneous STOP outbound streams that can be open at\n   * once. (default: 300)\n   */\n  maxOutboundStopStreams?: number\n}\n\nexport interface HopProtocolOptions {\n  connection: Connection\n  request: HopMessage\n  stream: ProtobufStream<Stream>\n}\n\nexport interface StopOptions {\n  connection: Connection\n  request: StopMessage\n}\n\nexport interface CircuitRelayServerComponents extends AdvertServiceComponents {\n  registrar: Registrar\n  peerStore: PeerStore\n  addressManager: AddressManager\n  peerId: PeerId\n  connectionManager: ConnectionManager\n  connectionGater: ConnectionGater\n  logger: ComponentLogger\n}\n\nexport interface RelayServerEvents {\n  'relay:reservation': CustomEvent<RelayReservation>\n  'relay:advert:success': CustomEvent<unknown>\n  'relay:advert:error': CustomEvent<Error>\n}\n\nconst defaults = {\n  maxOutboundStopStreams: MAX_CONNECTIONS\n}\n\nclass CircuitRelayServer extends TypedEventEmitter<RelayServerEvents> implements Startable, CircuitRelayService {\n  private readonly registrar: Registrar\n  private readonly peerStore: PeerStore\n  private readonly addressManager: AddressManager\n  private readonly peerId: PeerId\n  private readonly connectionManager: ConnectionManager\n  private readonly connectionGater: ConnectionGater\n  private readonly reservationStore: ReservationStore\n  private readonly advertService: AdvertService | undefined\n  private started: boolean\n  private readonly hopTimeout: number\n  private readonly shutdownController: AbortController\n  private readonly maxInboundHopStreams?: number\n  private readonly maxOutboundHopStreams?: number\n  private readonly maxOutboundStopStreams: number\n  private readonly log: Logger\n\n  /**\n   * Creates an instance of Relay\n   */\n  constructor (components: CircuitRelayServerComponents, init: CircuitRelayServerInit = {}) {\n    super()\n\n    this.log = components.logger.forComponent('libp2p:circuit-relay:server')\n    this.registrar = components.registrar\n    this.peerStore = components.peerStore\n    this.addressManager = components.addressManager\n    this.peerId = components.peerId\n    this.connectionManager = components.connectionManager\n    this.connectionGater = components.connectionGater\n    this.started = false\n    this.hopTimeout = init?.hopTimeout ?? DEFAULT_HOP_TIMEOUT\n    this.shutdownController = new AbortController()\n    this.maxInboundHopStreams = init.maxInboundHopStreams\n    this.maxOutboundHopStreams = init.maxOutboundHopStreams\n    this.maxOutboundStopStreams = init.maxOutboundStopStreams ?? defaults.maxOutboundStopStreams\n\n    setMaxListeners(Infinity, this.shutdownController.signal)\n\n    if (init.advertise != null && init.advertise !== false) {\n      this.advertService = new AdvertService(components, init.advertise === true ? undefined : init.advertise)\n      this.advertService.addEventListener('advert:success', () => {\n        this.safeDispatchEvent('relay:advert:success', {})\n      })\n      this.advertService.addEventListener('advert:error', (evt) => {\n        this.safeDispatchEvent('relay:advert:error', { detail: evt.detail })\n      })\n    }\n\n    this.reservationStore = new ReservationStore(init.reservations)\n  }\n\n  isStarted (): boolean {\n    return this.started\n  }\n\n  /**\n   * Start Relay service\n   */\n  async start (): Promise<void> {\n    if (this.started) {\n      return\n    }\n\n    // Advertise service if HOP enabled and advertising enabled\n    this.advertService?.start()\n\n    await this.registrar.handle(RELAY_V2_HOP_CODEC, (data) => {\n      void this.onHop(data).catch(err => {\n        this.log.error(err)\n      })\n    }, {\n      maxInboundStreams: this.maxInboundHopStreams,\n      maxOutboundStreams: this.maxOutboundHopStreams,\n      runOnTransientConnection: true\n    })\n\n    this.reservationStore.start()\n\n    this.started = true\n  }\n\n  /**\n   * Stop Relay service\n   */\n  async stop (): Promise<void> {\n    this.advertService?.stop()\n    this.reservationStore.stop()\n    this.shutdownController.abort()\n    await this.registrar.unhandle(RELAY_V2_HOP_CODEC)\n\n    this.started = false\n  }\n\n  async onHop ({ connection, stream }: IncomingStreamData): Promise<void> {\n    this.log('received circuit v2 hop protocol stream from %p', connection.remotePeer)\n\n    const hopTimeoutPromise = pDefer<HopMessage>()\n    const timeout = setTimeout(() => {\n      hopTimeoutPromise.reject('timed out')\n    }, this.hopTimeout)\n    const pbstr = pbStream(stream)\n\n    try {\n      const request: HopMessage = await Promise.race([\n        pbstr.pb(HopMessage).read(),\n        hopTimeoutPromise.promise\n      ])\n\n      if (request?.type == null) {\n        throw new Error('request was invalid, could not read from stream')\n      }\n\n      this.log('received', request.type)\n\n      await Promise.race([\n        this.handleHopProtocol({\n          connection,\n          stream: pbstr,\n          request\n        }),\n        hopTimeoutPromise.promise\n      ])\n    } catch (err: any) {\n      this.log.error('error while handling hop', err)\n      await pbstr.pb(HopMessage).write({\n        type: HopMessage.Type.STATUS,\n        status: Status.MALFORMED_MESSAGE\n      })\n      stream.abort(err)\n    } finally {\n      clearTimeout(timeout)\n    }\n  }\n\n  async handleHopProtocol ({ stream, request, connection }: HopProtocolOptions): Promise<void> {\n    this.log('received hop message')\n    switch (request.type) {\n      case HopMessage.Type.RESERVE: await this.handleReserve({ stream, request, connection }); break\n      case HopMessage.Type.CONNECT: await this.handleConnect({ stream, request, connection }); break\n      default: {\n        this.log.error('invalid hop request type %s via peer %p', request.type, connection.remotePeer)\n        await stream.pb(HopMessage).write({ type: HopMessage.Type.STATUS, status: Status.UNEXPECTED_MESSAGE })\n      }\n    }\n  }\n\n  async handleReserve ({ stream, request, connection }: HopProtocolOptions): Promise<void> {\n    const hopstr = stream.pb(HopMessage)\n    this.log('hop reserve request from %p', connection.remotePeer)\n\n    if (isRelayAddr(connection.remoteAddr)) {\n      this.log.error('relay reservation over circuit connection denied for peer: %p', connection.remotePeer)\n      await hopstr.write({ type: HopMessage.Type.STATUS, status: Status.PERMISSION_DENIED })\n      return\n    }\n\n    if ((await this.connectionGater.denyInboundRelayReservation?.(connection.remotePeer)) === true) {\n      this.log.error('reservation for %p denied by connection gater', connection.remotePeer)\n      await hopstr.write({ type: HopMessage.Type.STATUS, status: Status.PERMISSION_DENIED })\n      return\n    }\n\n    const result = this.reservationStore.reserve(connection.remotePeer, connection.remoteAddr)\n\n    if (result.status !== Status.OK) {\n      await hopstr.write({ type: HopMessage.Type.STATUS, status: result.status })\n      return\n    }\n\n    try {\n      // tag relay target peer\n      // result.expire is non-null if `ReservationStore.reserve` returns with status == OK\n      if (result.expire != null) {\n        const ttl = (result.expire * 1000) - Date.now()\n        await this.peerStore.merge(connection.remotePeer, {\n          tags: {\n            [RELAY_SOURCE_TAG]: { value: 1, ttl }\n          }\n        })\n      }\n\n      await hopstr.write({\n        type: HopMessage.Type.STATUS,\n        status: Status.OK,\n        reservation: await this.makeReservation(connection.remotePeer, BigInt(result.expire ?? 0)),\n        limit: this.reservationStore.get(connection.remotePeer)?.limit\n      })\n      this.log('sent confirmation response to %s', connection.remotePeer)\n    } catch (err) {\n      this.log.error('failed to send confirmation response to %p', connection.remotePeer, err)\n      this.reservationStore.removeReservation(connection.remotePeer)\n    }\n  }\n\n  async makeReservation (\n    remotePeer: PeerId,\n    expire: bigint\n  ): Promise<Reservation> {\n    const addrs = []\n\n    for (const relayAddr of this.addressManager.getAddresses()) {\n      if (relayAddr.toString().includes('/p2p-circuit')) {\n        continue\n      }\n\n      addrs.push(relayAddr.bytes)\n    }\n\n    const voucher = await RecordEnvelope.seal(new ReservationVoucherRecord({\n      peer: remotePeer,\n      relay: this.peerId,\n      expiration: Number(expire)\n    }), this.peerId)\n\n    return {\n      addrs,\n      expire,\n      voucher: voucher.marshal()\n    }\n  }\n\n  async handleConnect ({ stream, request, connection }: HopProtocolOptions): Promise<void> {\n    const hopstr = stream.pb(HopMessage)\n\n    if (isRelayAddr(connection.remoteAddr)) {\n      this.log.error('relay reservation over circuit connection denied for peer: %p', connection.remotePeer)\n      await hopstr.write({ type: HopMessage.Type.STATUS, status: Status.PERMISSION_DENIED })\n      return\n    }\n\n    this.log('hop connect request from %p', connection.remotePeer)\n\n    let dstPeer: PeerId\n\n    try {\n      if (request.peer == null) {\n        this.log.error('no peer info in hop connect request')\n        throw new Error('no peer info in request')\n      }\n\n      request.peer.addrs.forEach(multiaddr)\n      dstPeer = peerIdFromBytes(request.peer.id)\n    } catch (err) {\n      this.log.error('invalid hop connect request via peer %p %s', connection.remotePeer, err)\n      await hopstr.write({ type: HopMessage.Type.STATUS, status: Status.MALFORMED_MESSAGE })\n      return\n    }\n\n    if (!this.reservationStore.hasReservation(dstPeer)) {\n      this.log.error('hop connect denied for destination peer %p not having a reservation for %p with status %s', dstPeer, connection.remotePeer, Status.NO_RESERVATION)\n      await hopstr.write({ type: HopMessage.Type.STATUS, status: Status.NO_RESERVATION })\n      return\n    }\n\n    if ((await this.connectionGater.denyOutboundRelayedConnection?.(connection.remotePeer, dstPeer)) === true) {\n      this.log.error('hop connect for %p to %p denied by connection gater', connection.remotePeer, dstPeer)\n      await hopstr.write({ type: HopMessage.Type.STATUS, status: Status.PERMISSION_DENIED })\n      return\n    }\n\n    const connections = this.connectionManager.getConnections(dstPeer)\n\n    if (connections.length === 0) {\n      this.log('hop connect denied for destination peer %p not having a connection for %p as there is no destination connection', dstPeer, connection.remotePeer)\n      await hopstr.write({ type: HopMessage.Type.STATUS, status: Status.NO_RESERVATION })\n      return\n    }\n\n    const destinationConnection = connections[0]\n\n    const destinationStream = await this.stopHop({\n      connection: destinationConnection,\n      request: {\n        type: StopMessage.Type.CONNECT,\n        peer: {\n          id: connection.remotePeer.toBytes(),\n          addrs: []\n        }\n      }\n    })\n\n    if (destinationStream == null) {\n      this.log.error('failed to open stream to destination peer %p', destinationConnection?.remotePeer)\n      await hopstr.write({ type: HopMessage.Type.STATUS, status: Status.CONNECTION_FAILED })\n      return\n    }\n\n    await hopstr.write({ type: HopMessage.Type.STATUS, status: Status.OK })\n    const sourceStream = stream.unwrap()\n\n    this.log('connection from %p to %p established - merging streams', connection.remotePeer, dstPeer)\n    const limit = this.reservationStore.get(dstPeer)?.limit\n    // Short circuit the two streams to create the relayed connection\n    createLimitedRelay(sourceStream, destinationStream, this.shutdownController.signal, limit, {\n      log: this.log\n    })\n  }\n\n  /**\n   * Send a STOP request to the target peer that the dialing peer wants to contact\n   */\n  async stopHop ({\n    connection,\n    request\n  }: StopOptions): Promise<Stream | undefined> {\n    this.log('starting circuit relay v2 stop request to %s', connection.remotePeer)\n    const stream = await connection.newStream([RELAY_V2_STOP_CODEC], {\n      maxOutboundStreams: this.maxOutboundStopStreams,\n      runOnTransientConnection: true\n    })\n    const pbstr = pbStream(stream)\n    const stopstr = pbstr.pb(StopMessage)\n    await stopstr.write(request)\n    let response\n\n    try {\n      response = await stopstr.read()\n    } catch (err) {\n      this.log.error('error parsing stop message response from %p', connection.remotePeer)\n    }\n\n    if (response == null) {\n      this.log.error('could not read response from %p', connection.remotePeer)\n      await stream.close()\n      return\n    }\n\n    if (response.status === Status.OK) {\n      this.log('stop request to %p was successful', connection.remotePeer)\n      return pbstr.unwrap()\n    }\n\n    this.log('stop request failed with code %d', response.status)\n    await stream.close()\n  }\n\n  get reservations (): PeerMap<RelayReservation> {\n    return this.reservationStore.reservations\n  }\n}\n\nexport function circuitRelayServer (init: CircuitRelayServerInit = {}): (components: CircuitRelayServerComponents) => CircuitRelayService {\n  return (components) => {\n    return new CircuitRelayServer(components, init)\n  }\n}\n", "import { TypedEventEmitter } from '@libp2p/interface'\nimport {\n  RELAY_RENDEZVOUS_NS,\n  RELAY_V2_HOP_CODEC\n} from '../constants.js'\nimport { namespaceToCid } from '../utils.js'\nimport type { ComponentLogger, Logger, ContentRouting, PeerId, PeerStore, Startable } from '@libp2p/interface'\nimport type { ConnectionManager, Registrar, TransportManager } from '@libp2p/interface-internal'\n\nexport interface RelayDiscoveryEvents {\n  'relay:discover': CustomEvent<PeerId>\n}\n\nexport interface RelayDiscoveryComponents {\n  peerId: PeerId\n  peerStore: PeerStore\n  connectionManager: ConnectionManager\n  transportManager: TransportManager\n  contentRouting: ContentRouting\n  registrar: Registrar\n  logger: ComponentLogger\n}\n\n/**\n * ReservationManager automatically makes a circuit v2 reservation on any connected\n * peers that support the circuit v2 HOP protocol.\n */\nexport class RelayDiscovery extends TypedEventEmitter<RelayDiscoveryEvents> implements Startable {\n  private readonly peerId: PeerId\n  private readonly peerStore: PeerStore\n  private readonly contentRouting: ContentRouting\n  private readonly registrar: Registrar\n  private started: boolean\n  private topologyId?: string\n  private readonly log: Logger\n\n  constructor (components: RelayDiscoveryComponents) {\n    super()\n\n    this.log = components.logger.forComponent('libp2p:circuit-relay:discover-relays')\n    this.started = false\n    this.peerId = components.peerId\n    this.peerStore = components.peerStore\n    this.contentRouting = components.contentRouting\n    this.registrar = components.registrar\n  }\n\n  isStarted (): boolean {\n    return this.started\n  }\n\n  async start (): Promise<void> {\n    // register a topology listener for when new peers are encountered\n    // that support the hop protocol\n    this.topologyId = await this.registrar.register(RELAY_V2_HOP_CODEC, {\n      notifyOnTransient: true,\n      onConnect: (peerId) => {\n        this.safeDispatchEvent('relay:discover', { detail: peerId })\n      }\n    })\n\n    this.started = true\n  }\n\n  afterStart (): void {\n    void this.discover()\n      .catch(err => {\n        this.log.error('error discovering relays', err)\n      })\n  }\n\n  stop (): void {\n    if (this.topologyId != null) {\n      this.registrar.unregister(this.topologyId)\n    }\n\n    this.started = false\n  }\n\n  /**\n   * Try to listen on available hop relay connections.\n   * The following order will happen while we do not have enough relays:\n   *\n   * 1. Check the metadata store for known relays, try to listen on the ones we are already connected\n   * 2. Dial and try to listen on the peers we know that support hop but are not connected\n   * 3. Search the network\n   */\n  async discover (): Promise<void> {\n    this.log('searching peer store for relays')\n    const peers = (await this.peerStore.all({\n      filters: [\n        // filter by a list of peers supporting RELAY_V2_HOP and ones we are not listening on\n        (peer) => {\n          return peer.protocols.includes(RELAY_V2_HOP_CODEC)\n        }\n      ],\n      orders: [\n        () => Math.random() < 0.5 ? 1 : -1\n      ]\n    }))\n\n    for (const peer of peers) {\n      this.log('found relay peer %p in content peer store', peer.id)\n      this.safeDispatchEvent('relay:discover', { detail: peer.id })\n    }\n\n    this.log('found %d relay peers in peer store', peers.length)\n\n    try {\n      this.log('searching content routing for relays')\n      const cid = await namespaceToCid(RELAY_RENDEZVOUS_NS)\n\n      let found = 0\n\n      for await (const provider of this.contentRouting.findProviders(cid)) {\n        if (provider.multiaddrs.length > 0 && !provider.id.equals(this.peerId)) {\n          const peerId = provider.id\n\n          found++\n          await this.peerStore.merge(peerId, {\n            multiaddrs: provider.multiaddrs\n          })\n\n          this.log('found relay peer %p in content routing', peerId)\n          this.safeDispatchEvent('relay:discover', { detail: peerId })\n        }\n      }\n\n      this.log('found %d relay peers in content routing', found)\n    } catch (err: any) {\n      this.log.error('failed when finding relays on the network', err)\n    }\n  }\n}\n", "import { TypedEventEmitter } from '@libp2p/interface'\nimport { PeerMap } from '@libp2p/peer-collections'\nimport { PeerQueue } from '@libp2p/utils/peer-queue'\nimport { multiaddr } from '@multiformats/multiaddr'\nimport { pbStream } from 'it-protobuf-stream'\nimport { equals as uint8ArrayEquals } from 'uint8arrays/equals'\nimport { DEFAULT_RESERVATION_CONCURRENCY, RELAY_TAG, RELAY_V2_HOP_CODEC } from '../constants.js'\nimport { HopMessage, Status } from '../pb/index.js'\nimport { getExpirationMilliseconds } from '../utils.js'\nimport type { Reservation } from '../pb/index.js'\nimport type { TypedEventTarget, Libp2pEvents, AbortOptions, ComponentLogger, Logger, Connection, PeerId, PeerStore, Startable, Metrics } from '@libp2p/interface'\nimport type { ConnectionManager, TransportManager } from '@libp2p/interface-internal'\n\n// allow refreshing a relay reservation if it will expire in the next 10 minutes\nconst REFRESH_WINDOW = (60 * 1000) * 10\n\n// try to refresh relay reservations 5 minutes before expiry\nconst REFRESH_TIMEOUT = (60 * 1000) * 5\n\n// minimum duration before which a reservation must not be refreshed\nconst REFRESH_TIMEOUT_MIN = 30 * 1000\n\nexport interface RelayStoreComponents {\n  peerId: PeerId\n  connectionManager: ConnectionManager\n  transportManager: TransportManager\n  peerStore: PeerStore\n  events: TypedEventTarget<Libp2pEvents>\n  logger: ComponentLogger\n  metrics?: Metrics\n}\n\nexport interface RelayStoreInit {\n  /**\n   * Multiple relays may be discovered simultaneously - to prevent listening\n   * on too many relays, this value controls how many to attempt to reserve a\n   * slot on at once. If set to more than one, we may end up listening on\n   * more relays than the `maxReservations` value, but on networks with poor\n   * connectivity the user may wish to attempt to reserve on multiple relays\n   * simultaneously. (default: 1)\n   */\n  reservationConcurrency?: number\n\n  /**\n   * How many discovered relays to allow in the reservation store\n   */\n  discoverRelays?: number\n\n  /**\n   * Limit the number of potential relays we will dial (default: 100)\n   */\n  maxReservationQueueLength?: number\n\n  /**\n   * When creating a reservation it must complete within this number of ms\n   * (default: 5000)\n   */\n  reservationCompletionTimeout?: number\n}\n\nexport type RelayType = 'discovered' | 'configured'\n\ninterface RelayEntry {\n  timeout: ReturnType<typeof setTimeout>\n  type: RelayType\n  reservation: Reservation\n}\n\nexport interface ReservationStoreEvents {\n  'relay:not-enough-relays': CustomEvent\n  'relay:removed': CustomEvent<PeerId>\n}\n\nexport class ReservationStore extends TypedEventEmitter<ReservationStoreEvents> implements Startable {\n  private readonly peerId: PeerId\n  private readonly connectionManager: ConnectionManager\n  private readonly transportManager: TransportManager\n  private readonly peerStore: PeerStore\n  private readonly events: TypedEventTarget<Libp2pEvents>\n  private readonly reserveQueue: PeerQueue\n  private readonly reservations: PeerMap<RelayEntry>\n  private readonly maxDiscoveredRelays: number\n  private readonly maxReservationQueueLength: number\n  private readonly reservationCompletionTimeout: number\n  private started: boolean\n  private readonly log: Logger\n\n  constructor (components: RelayStoreComponents, init?: RelayStoreInit) {\n    super()\n\n    this.log = components.logger.forComponent('libp2p:circuit-relay:transport:reservation-store')\n    this.peerId = components.peerId\n    this.connectionManager = components.connectionManager\n    this.transportManager = components.transportManager\n    this.peerStore = components.peerStore\n    this.events = components.events\n    this.reservations = new PeerMap()\n    this.maxDiscoveredRelays = init?.discoverRelays ?? 0\n    this.maxReservationQueueLength = init?.maxReservationQueueLength ?? 100\n    this.reservationCompletionTimeout = init?.reservationCompletionTimeout ?? 10000\n    this.started = false\n\n    // ensure we don't listen on multiple relays simultaneously\n    this.reserveQueue = new PeerQueue({\n      concurrency: init?.reservationConcurrency ?? DEFAULT_RESERVATION_CONCURRENCY,\n      metricName: 'libp2p_relay_reservation_queue',\n      metrics: components.metrics\n    })\n\n    // When a peer disconnects, if we had a reservation on that peer\n    // remove the reservation and multiaddr and maybe trigger search\n    // for new relays\n    this.events.addEventListener('peer:disconnect', (evt) => {\n      this.#removeRelay(evt.detail)\n    })\n  }\n\n  isStarted (): boolean {\n    return this.started\n  }\n\n  start (): void {\n    this.started = true\n  }\n\n  stop (): void {\n    this.reserveQueue.clear()\n    this.reservations.forEach(({ timeout }) => {\n      clearTimeout(timeout)\n    })\n    this.reservations.clear()\n    this.started = false\n  }\n\n  /**\n   * If the number of current relays is beneath the configured `maxReservations`\n   * value, and the passed peer id is not our own, and we have a non-relayed connection\n   * to the remote, and the remote peer speaks the hop protocol, try to reserve a slot\n   * on the remote peer\n   */\n  async addRelay (peerId: PeerId, type: RelayType): Promise<void> {\n    if (this.peerId.equals(peerId)) {\n      this.log('not trying to use self as relay')\n      return\n    }\n\n    if (this.reserveQueue.size > this.maxReservationQueueLength) {\n      this.log('not adding relay as the queue is full')\n      return\n    }\n\n    if (this.reserveQueue.has(peerId)) {\n      this.log('relay peer is already in the reservation queue')\n      return\n    }\n\n    this.log('add relay %p', peerId)\n\n    await this.reserveQueue.add(async () => {\n      try {\n        // allow refresh of an existing reservation if it is about to expire\n        const existingReservation = this.reservations.get(peerId)\n\n        if (existingReservation != null) {\n          if (getExpirationMilliseconds(existingReservation.reservation.expire) > REFRESH_WINDOW) {\n            this.log('already have reservation on relay peer %p and it expires in more than 10 minutes', peerId)\n            return\n          }\n\n          clearTimeout(existingReservation.timeout)\n          this.reservations.delete(peerId)\n        }\n\n        if (type === 'discovered' && [...this.reservations.values()].reduce((acc, curr) => {\n          if (curr.type === 'discovered') {\n            acc++\n          }\n\n          return acc\n        }, 0) >= this.maxDiscoveredRelays) {\n          this.log('already have enough discovered relays')\n          return\n        }\n\n        const signal = AbortSignal.timeout(this.reservationCompletionTimeout)\n\n        const connection = await this.connectionManager.openConnection(peerId, {\n          signal\n        })\n\n        if (connection.remoteAddr.protoNames().includes('p2p-circuit')) {\n          this.log('not creating reservation over relayed connection')\n          return\n        }\n\n        const reservation = await this.#createReservation(connection, {\n          signal\n        })\n\n        this.log('created reservation on relay peer %p', peerId)\n\n        const expiration = getExpirationMilliseconds(reservation.expire)\n\n        // sets a lower bound on the timeout, and also don't let it go over\n        // 2^31 - 1 (setTimeout will only accept signed 32 bit integers)\n        const timeoutDuration = Math.min(Math.max(expiration - REFRESH_TIMEOUT, REFRESH_TIMEOUT_MIN), Math.pow(2, 31) - 1)\n\n        const timeout = setTimeout(() => {\n          this.addRelay(peerId, type).catch(err => {\n            this.log.error('could not refresh reservation to relay %p', peerId, err)\n          })\n        }, timeoutDuration)\n\n        // we've managed to create a reservation successfully\n        this.reservations.set(peerId, {\n          timeout,\n          reservation,\n          type\n        })\n\n        // ensure we don't close the connection to the relay\n        await this.peerStore.merge(peerId, {\n          tags: {\n            [RELAY_TAG]: {\n              value: 1,\n              ttl: expiration\n            }\n          }\n        })\n\n        // listen on multiaddr that only the circuit transport is listening for\n        await this.transportManager.listen([multiaddr(`/p2p/${peerId.toString()}/p2p-circuit`)])\n      } catch (err) {\n        this.log.error('could not reserve slot on %p', peerId, err)\n\n        // cancel the renewal timeout if it's been set\n        const reservation = this.reservations.get(peerId)\n\n        if (reservation != null) {\n          clearTimeout(reservation.timeout)\n        }\n\n        // if listening failed, remove the reservation\n        this.reservations.delete(peerId)\n      }\n    }, {\n      peerId\n    })\n  }\n\n  hasReservation (peerId: PeerId): boolean {\n    return this.reservations.has(peerId)\n  }\n\n  getReservation (peerId: PeerId): Reservation | undefined {\n    return this.reservations.get(peerId)?.reservation\n  }\n\n  async #createReservation (connection: Connection, options: AbortOptions): Promise<Reservation> {\n    options.signal?.throwIfAborted()\n\n    this.log('requesting reservation from %p', connection.remotePeer)\n    const stream = await connection.newStream(RELAY_V2_HOP_CODEC, options)\n    const pbstr = pbStream(stream)\n    const hopstr = pbstr.pb(HopMessage)\n    await hopstr.write({ type: HopMessage.Type.RESERVE }, options)\n\n    let response: HopMessage\n\n    try {\n      response = await hopstr.read(options)\n    } catch (err: any) {\n      this.log.error('error parsing reserve message response from %p because', connection.remotePeer, err)\n      stream.abort(err)\n      throw err\n    } finally {\n      await stream.close()\n    }\n\n    if (response.status === Status.OK && (response.reservation != null)) {\n      // check that the returned relay has the relay address - this can be\n      // omitted when requesting a reservation from a go-libp2p relay we\n      // already have a reservation on\n      let hasRelayAddress = false\n      const relayAddressBytes = connection.remoteAddr.bytes\n\n      for (const buf of response.reservation.addrs) {\n        if (uint8ArrayEquals(relayAddressBytes, buf)) {\n          hasRelayAddress = true\n          break\n        }\n      }\n\n      if (!hasRelayAddress) {\n        response.reservation.addrs.push(relayAddressBytes)\n      }\n\n      return response.reservation\n    }\n\n    const errMsg = `reservation failed with status ${response.status ?? 'undefined'}`\n    this.log.error(errMsg)\n\n    throw new Error(errMsg)\n  }\n\n  /**\n   * Remove listen relay\n   */\n  #removeRelay (peerId: PeerId): void {\n    const existingReservation = this.reservations.get(peerId)\n\n    if (existingReservation == null) {\n      return\n    }\n\n    this.log('connection to relay %p closed, removing reservation from local store', peerId)\n\n    clearTimeout(existingReservation.timeout)\n    this.reservations.delete(peerId)\n\n    this.safeDispatchEvent('relay:removed', { detail: peerId })\n\n    if (this.reservations.size < this.maxDiscoveredRelays) {\n      this.log('not enough relays %d/%d', this.reservations.size, this.maxDiscoveredRelays)\n      this.safeDispatchEvent('relay:not-enough-relays', {})\n    }\n  }\n}\n", "import type { ComponentLogger, MultiaddrConnection, Stream } from '@libp2p/interface'\nimport type { Multiaddr } from '@multiformats/multiaddr'\n\nexport interface StreamProperties {\n  stream: Stream\n  remoteAddr: Multiaddr\n  localAddr: Multiaddr\n  logger: ComponentLogger\n}\n\n/**\n * Convert a duplex iterable into a MultiaddrConnection.\n * https://github.com/libp2p/interface-transport#multiaddrconnection\n */\nexport function streamToMaConnection (props: StreamProperties): MultiaddrConnection {\n  const { stream, remoteAddr, logger } = props\n  const log = logger.forComponent('libp2p:stream:converter')\n\n  let closedRead = false\n  let closedWrite = false\n\n  // piggyback on `stream.close` invocations to close maconn\n  const streamClose = stream.close.bind(stream)\n  stream.close = async (options) => {\n    await streamClose(options)\n    close(true)\n  }\n\n  // piggyback on `stream.abort` invocations to close maconn\n  const streamAbort = stream.abort.bind(stream)\n  stream.abort = (err) => {\n    streamAbort(err)\n    close(true)\n  }\n\n  // piggyback on `stream.sink` invocations to close maconn\n  const streamSink = stream.sink.bind(stream)\n  stream.sink = async (source) => {\n    try {\n      await streamSink(source)\n    } catch (err: any) {\n      // If aborted we can safely ignore\n      if (err.type !== 'aborted') {\n        // If the source errored the socket will already have been destroyed by\n        // toIterable.duplex(). If the socket errored it will already be\n        // destroyed. There's nothing to do here except log the error & return.\n        log.error('%s error in sink', remoteAddr, err)\n      }\n    } finally {\n      closedWrite = true\n      close()\n    }\n  }\n\n  const maConn: MultiaddrConnection = {\n    log,\n    sink: stream.sink,\n    source: (async function * () {\n      try {\n        for await (const list of stream.source) {\n          if (list instanceof Uint8Array) {\n            yield list\n          } else {\n            yield * list\n          }\n        }\n      } finally {\n        closedRead = true\n        close()\n      }\n    }()),\n    remoteAddr,\n    timeline: { open: Date.now(), close: undefined },\n    close: stream.close,\n    abort: stream.abort\n  }\n\n  function close (force?: boolean): void {\n    if (force === true) {\n      closedRead = true\n      closedWrite = true\n    }\n\n    if (closedRead && closedWrite && maConn.timeline.close == null) {\n      maConn.timeline.close = Date.now()\n    }\n  }\n\n  return maConn\n}\n", "import { CodeError, TypedEventEmitter } from '@libp2p/interface'\nimport { PeerMap } from '@libp2p/peer-collections'\nimport { multiaddr } from '@multiformats/multiaddr'\nimport type { ReservationStore } from './reservation-store.js'\nimport type { ComponentLogger, Logger, PeerId, Listener, ListenerEvents } from '@libp2p/interface'\nimport type { ConnectionManager } from '@libp2p/interface-internal'\nimport type { Multiaddr } from '@multiformats/multiaddr'\n\nexport interface CircuitRelayTransportListenerComponents {\n  connectionManager: ConnectionManager\n  relayStore: ReservationStore\n  logger: ComponentLogger\n}\n\nclass CircuitRelayTransportListener extends TypedEventEmitter<ListenerEvents> implements Listener {\n  private readonly connectionManager: ConnectionManager\n  private readonly relayStore: ReservationStore\n  private readonly listeningAddrs: PeerMap<Multiaddr[]>\n  private readonly log: Logger\n\n  constructor (components: CircuitRelayTransportListenerComponents) {\n    super()\n\n    this.log = components.logger.forComponent('libp2p:circuit-relay:transport:listener')\n    this.connectionManager = components.connectionManager\n    this.relayStore = components.relayStore\n    this.listeningAddrs = new PeerMap()\n\n    // remove listening addrs when a relay is removed\n    this.relayStore.addEventListener('relay:removed', this._onRemoveRelayPeer)\n  }\n\n  _onRemoveRelayPeer = (evt: CustomEvent<PeerId>): void => {\n    this.#removeRelayPeer(evt.detail)\n  }\n\n  async listen (addr: Multiaddr): Promise<void> {\n    this.log('listen on %a', addr)\n\n    // remove the circuit part to get the peer id of the relay\n    const relayAddr = addr.decapsulate('/p2p-circuit')\n    const relayConn = await this.connectionManager.openConnection(relayAddr)\n\n    if (!this.relayStore.hasReservation(relayConn.remotePeer)) {\n      this.log('making reservation on peer %p', relayConn.remotePeer)\n      // addRelay calls transportManager.listen which calls this listen method\n      await this.relayStore.addRelay(relayConn.remotePeer, 'configured')\n      return\n    }\n\n    const reservation = this.relayStore.getReservation(relayConn.remotePeer)\n\n    if (reservation == null) {\n      throw new CodeError('Did not have reservation after making reservation', 'ERR_NO_RESERVATION')\n    }\n\n    if (this.listeningAddrs.has(relayConn.remotePeer)) {\n      this.log('already listening on relay %p', relayConn.remotePeer)\n      return\n    }\n\n    // add all addresses from the relay reservation\n    this.listeningAddrs.set(relayConn.remotePeer, reservation.addrs.map(buf => {\n      return multiaddr(buf).encapsulate('/p2p-circuit')\n    }))\n\n    this.safeDispatchEvent('listening', {})\n  }\n\n  getAddrs (): Multiaddr[] {\n    return [...this.listeningAddrs.values()].flat()\n  }\n\n  async close (): Promise<void> {\n\n  }\n\n  #removeRelayPeer (peerId: PeerId): void {\n    const had = this.listeningAddrs.has(peerId)\n\n    this.log('relay peer removed %p - had reservation', peerId, had)\n\n    this.listeningAddrs.delete(peerId)\n\n    if (had) {\n      this.log.trace('removing relay event listener for peer %p', peerId)\n      this.relayStore.removeEventListener('relay:removed', this._onRemoveRelayPeer)\n      // Announce listen addresses change\n      this.safeDispatchEvent('close', {})\n    }\n  }\n}\n\nexport function createListener (options: CircuitRelayTransportListenerComponents): Listener {\n  return new CircuitRelayTransportListener(options)\n}\n", "import { CodeError } from '@libp2p/interface'\nimport { transportSymbol, type Transport, type CreateListenerOptions, type Listener, type Upgrader, type AbortOptions, type ComponentLogger, type Logger, type Connection, type Stream, type ConnectionGater, type PeerId, type PeerStore } from '@libp2p/interface'\nimport { peerIdFromBytes, peerIdFromString } from '@libp2p/peer-id'\nimport { streamToMaConnection } from '@libp2p/utils/stream-to-ma-conn'\nimport * as mafmt from '@multiformats/mafmt'\nimport { multiaddr } from '@multiformats/multiaddr'\nimport { pbStream } from 'it-protobuf-stream'\nimport { CIRCUIT_PROTO_CODE, ERR_HOP_REQUEST_FAILED, ERR_RELAYED_DIAL, MAX_CONNECTIONS, RELAY_V2_HOP_CODEC, RELAY_V2_STOP_CODEC } from '../constants.js'\nimport { StopMessage, HopMessage, Status } from '../pb/index.js'\nimport { RelayDiscovery } from './discovery.js'\nimport { createListener } from './listener.js'\nimport { ReservationStore } from './reservation-store.js'\nimport type { CircuitRelayTransportComponents, CircuitRelayTransportInit } from './index.js'\nimport type { AddressManager, ConnectionManager, IncomingStreamData, Registrar, TransportManager } from '@libp2p/interface-internal'\nimport type { Multiaddr } from '@multiformats/multiaddr'\n\nconst isValidStop = (request: StopMessage): request is Required<StopMessage> => {\n  if (request.peer == null) {\n    return false\n  }\n\n  try {\n    request.peer.addrs.forEach(multiaddr)\n  } catch {\n    return false\n  }\n\n  return true\n}\n\ninterface ConnectOptions {\n  stream: Stream\n  connection: Connection\n  destinationPeer: PeerId\n  destinationAddr: Multiaddr\n  relayAddr: Multiaddr\n  ma: Multiaddr\n  disconnectOnFailure: boolean\n}\n\nconst defaults = {\n  maxInboundStopStreams: MAX_CONNECTIONS,\n  maxOutboundStopStreams: MAX_CONNECTIONS,\n  stopTimeout: 30000\n}\n\nexport class CircuitRelayTransport implements Transport {\n  private readonly discovery?: RelayDiscovery\n  private readonly registrar: Registrar\n  private readonly peerStore: PeerStore\n  private readonly connectionManager: ConnectionManager\n  private readonly transportManager: TransportManager\n  private readonly peerId: PeerId\n  private readonly upgrader: Upgrader\n  private readonly addressManager: AddressManager\n  private readonly connectionGater: ConnectionGater\n  public readonly reservationStore: ReservationStore\n  private readonly logger: ComponentLogger\n  private readonly maxInboundStopStreams: number\n  private readonly maxOutboundStopStreams?: number\n  private readonly stopTimeout: number\n  private started: boolean\n  private readonly log: Logger\n\n  constructor (components: CircuitRelayTransportComponents, init: CircuitRelayTransportInit) {\n    this.log = components.logger.forComponent('libp2p:circuit-relay:transport')\n    this.registrar = components.registrar\n    this.peerStore = components.peerStore\n    this.connectionManager = components.connectionManager\n    this.transportManager = components.transportManager\n    this.logger = components.logger\n    this.peerId = components.peerId\n    this.upgrader = components.upgrader\n    this.addressManager = components.addressManager\n    this.connectionGater = components.connectionGater\n    this.maxInboundStopStreams = init.maxInboundStopStreams ?? defaults.maxInboundStopStreams\n    this.maxOutboundStopStreams = init.maxOutboundStopStreams ?? defaults.maxOutboundStopStreams\n    this.stopTimeout = init.stopTimeout ?? defaults.stopTimeout\n\n    if (init.discoverRelays != null && init.discoverRelays > 0) {\n      this.discovery = new RelayDiscovery(components)\n      this.discovery.addEventListener('relay:discover', (evt) => {\n        this.reservationStore.addRelay(evt.detail, 'discovered')\n          .catch(err => {\n            this.log.error('could not add discovered relay %p', evt.detail, err)\n          })\n      })\n    }\n\n    this.reservationStore = new ReservationStore(components, init)\n    this.reservationStore.addEventListener('relay:not-enough-relays', () => {\n      this.discovery?.discover()\n        .catch(err => {\n          this.log.error('could not discover relays', err)\n        })\n    })\n\n    this.started = false\n  }\n\n  isStarted (): boolean {\n    return this.started\n  }\n\n  async start (): Promise<void> {\n    this.reservationStore.start()\n\n    await this.registrar.handle(RELAY_V2_STOP_CODEC, (data) => {\n      void this.onStop(data).catch(err => {\n        this.log.error('error while handling STOP protocol', err)\n        data.stream.abort(err)\n      })\n    }, {\n      maxInboundStreams: this.maxInboundStopStreams,\n      maxOutboundStreams: this.maxOutboundStopStreams,\n      runOnTransientConnection: true\n    })\n\n    await this.discovery?.start()\n\n    this.started = true\n  }\n\n  afterStart (): void {\n    this.discovery?.afterStart()\n  }\n\n  async stop (): Promise<void> {\n    this.discovery?.stop()\n    this.reservationStore.stop()\n    await this.registrar.unhandle(RELAY_V2_STOP_CODEC)\n\n    this.started = false\n  }\n\n  readonly [transportSymbol] = true\n\n  readonly [Symbol.toStringTag] = 'libp2p/circuit-relay-v2'\n\n  /**\n   * Dial a peer over a relay\n   */\n  async dial (ma: Multiaddr, options: AbortOptions = {}): Promise<Connection> {\n    if (ma.protoCodes().filter(code => code === CIRCUIT_PROTO_CODE).length !== 1) {\n      const errMsg = 'Invalid circuit relay address'\n      this.log.error(errMsg, ma)\n      throw new CodeError(errMsg, ERR_RELAYED_DIAL)\n    }\n\n    // Check the multiaddr to see if it contains a relay and a destination peer\n    const addrs = ma.toString().split('/p2p-circuit')\n    const relayAddr = multiaddr(addrs[0])\n    const destinationAddr = multiaddr(addrs[addrs.length - 1])\n    const relayId = relayAddr.getPeerId()\n    const destinationId = destinationAddr.getPeerId()\n\n    if (relayId == null || destinationId == null) {\n      const errMsg = `Circuit relay dial to ${ma.toString()} failed as address did not have peer ids`\n      this.log.error(errMsg)\n      throw new CodeError(errMsg, ERR_RELAYED_DIAL)\n    }\n\n    const relayPeer = peerIdFromString(relayId)\n    const destinationPeer = peerIdFromString(destinationId)\n\n    let disconnectOnFailure = false\n    const relayConnections = this.connectionManager.getConnections(relayPeer)\n    let relayConnection = relayConnections[0]\n\n    if (relayConnection == null) {\n      await this.peerStore.merge(relayPeer, {\n        multiaddrs: [relayAddr]\n      })\n      relayConnection = await this.connectionManager.openConnection(relayPeer, options)\n      disconnectOnFailure = true\n    }\n\n    let stream: Stream | undefined\n\n    try {\n      stream = await relayConnection.newStream(RELAY_V2_HOP_CODEC)\n\n      return await this.connectV2({\n        stream,\n        connection: relayConnection,\n        destinationPeer,\n        destinationAddr,\n        relayAddr,\n        ma,\n        disconnectOnFailure\n      })\n    } catch (err: any) {\n      this.log.error('circuit relay dial to destination %p via relay %p failed', destinationPeer, relayPeer, err)\n\n      if (stream != null) {\n        stream.abort(err)\n      }\n      disconnectOnFailure && await relayConnection.close()\n      throw err\n    }\n  }\n\n  async connectV2 (\n    {\n      stream, connection, destinationPeer,\n      destinationAddr, relayAddr, ma,\n      disconnectOnFailure\n    }: ConnectOptions\n  ): Promise<Connection> {\n    try {\n      const pbstr = pbStream(stream)\n      const hopstr = pbstr.pb(HopMessage)\n      await hopstr.write({\n        type: HopMessage.Type.CONNECT,\n        peer: {\n          id: destinationPeer.toBytes(),\n          addrs: [multiaddr(destinationAddr).bytes]\n        }\n      })\n\n      const status = await hopstr.read()\n\n      if (status.status !== Status.OK) {\n        throw new CodeError(`failed to connect via relay with status ${status?.status?.toString() ?? 'undefined'}`, ERR_HOP_REQUEST_FAILED)\n      }\n\n      const maConn = streamToMaConnection({\n        stream: pbstr.unwrap(),\n        remoteAddr: ma,\n        localAddr: relayAddr.encapsulate(`/p2p-circuit/p2p/${this.peerId.toString()}`),\n        logger: this.logger\n      })\n\n      this.log('new outbound transient connection %a', maConn.remoteAddr)\n      return await this.upgrader.upgradeOutbound(maConn, {\n        transient: true\n      })\n    } catch (err: any) {\n      this.log.error(`Circuit relay dial to destination ${destinationPeer.toString()} via relay ${connection.remotePeer.toString()} failed`, err)\n      disconnectOnFailure && await connection.close()\n      throw err\n    }\n  }\n\n  /**\n   * Create a listener\n   */\n  createListener (options: CreateListenerOptions): Listener {\n    return createListener({\n      connectionManager: this.connectionManager,\n      relayStore: this.reservationStore,\n      logger: this.logger\n    })\n  }\n\n  /**\n   * Filter check for all Multiaddrs that this transport can listen on\n   */\n  listenFilter (multiaddrs: Multiaddr[]): Multiaddr[] {\n    multiaddrs = Array.isArray(multiaddrs) ? multiaddrs : [multiaddrs]\n\n    return multiaddrs.filter((ma) => {\n      return mafmt.Circuit.matches(ma)\n    })\n  }\n\n  /**\n   * Filter check for all Multiaddrs that this transport can dial\n   */\n  dialFilter (multiaddrs: Multiaddr[]): Multiaddr[] {\n    return this.listenFilter(multiaddrs)\n  }\n\n  /**\n   * An incoming STOP request means a remote peer wants to dial us via a relay\n   */\n  async onStop ({ connection, stream }: IncomingStreamData): Promise<void> {\n    if (!this.reservationStore.hasReservation(connection.remotePeer)) {\n      try {\n        this.log('dialed via relay we did not have a reservation on, start listening on that relay address')\n        await this.transportManager.listen([connection.remoteAddr.encapsulate('/p2p-circuit')])\n      } catch (err: any) {\n        // failed to refresh our hitherto unknown relay reservation but allow the connection attempt anyway\n        this.log.error('failed to listen on a relay peer we were dialed via but did not have a reservation on', err)\n      }\n    }\n\n    const signal = AbortSignal.timeout(this.stopTimeout)\n    const pbstr = pbStream(stream).pb(StopMessage)\n    const request = await pbstr.read({\n      signal\n    })\n\n    this.log('new circuit relay v2 stop stream from %p with type %s', connection.remotePeer, request.type)\n\n    if (request?.type === undefined) {\n      this.log.error('type was missing from circuit v2 stop protocol request from %s', connection.remotePeer)\n      await pbstr.write({ type: StopMessage.Type.STATUS, status: Status.MALFORMED_MESSAGE }, {\n        signal\n      })\n      await stream.close()\n      return\n    }\n\n    // Validate the STOP request has the required input\n    if (request.type !== StopMessage.Type.CONNECT) {\n      this.log.error('invalid stop connect request via peer %p', connection.remotePeer)\n      await pbstr.write({ type: StopMessage.Type.STATUS, status: Status.UNEXPECTED_MESSAGE }, {\n        signal\n      })\n      await stream.close()\n      return\n    }\n\n    if (!isValidStop(request)) {\n      this.log.error('invalid stop connect request via peer %p', connection.remotePeer)\n      await pbstr.write({ type: StopMessage.Type.STATUS, status: Status.MALFORMED_MESSAGE }, {\n        signal\n      })\n      await stream.close()\n      return\n    }\n\n    const remotePeerId = peerIdFromBytes(request.peer.id)\n\n    if ((await this.connectionGater.denyInboundRelayedConnection?.(connection.remotePeer, remotePeerId)) === true) {\n      this.log.error('connection gater denied inbound relayed connection from %p', connection.remotePeer)\n      await pbstr.write({ type: StopMessage.Type.STATUS, status: Status.PERMISSION_DENIED }, {\n        signal\n      })\n      await stream.close()\n      return\n    }\n\n    this.log.trace('sending success response to %p', connection.remotePeer)\n    await pbstr.write({ type: StopMessage.Type.STATUS, status: Status.OK }, {\n      signal\n    })\n\n    const remoteAddr = connection.remoteAddr.encapsulate(`/p2p-circuit/p2p/${remotePeerId.toString()}`)\n    const localAddr = this.addressManager.getAddresses()[0]\n    const maConn = streamToMaConnection({\n      stream: pbstr.unwrap().unwrap(),\n      remoteAddr,\n      localAddr,\n      logger: this.logger\n    })\n\n    this.log('new inbound transient connection %a', maConn.remoteAddr)\n    await this.upgrader.upgradeInbound(maConn, {\n      transient: true\n    })\n    this.log('%s connection %a upgraded', 'inbound', maConn.remoteAddr)\n  }\n}\n", "import { type Transport, type Upgrader, type Libp2pEvents, type ComponentLogger, type ConnectionGater, type ContentRouting, type TypedEventTarget, type PeerId, type PeerStore } from '@libp2p/interface'\nimport { type RelayDiscoveryComponents } from './discovery.js'\nimport { type RelayStoreInit } from './reservation-store.js'\nimport { CircuitRelayTransport } from './transport.js'\nimport type { AddressManager, ConnectionManager, Registrar } from '@libp2p/interface-internal'\n\nexport interface CircuitRelayTransportComponents extends RelayDiscoveryComponents {\n  peerId: PeerId\n  peerStore: PeerStore\n  registrar: Registrar\n  connectionManager: ConnectionManager\n  upgrader: Upgrader\n  addressManager: AddressManager\n  contentRouting: ContentRouting\n  connectionGater: ConnectionGater\n  events: TypedEventTarget<Libp2pEvents>\n  logger: ComponentLogger\n}\n\n/**\n * RelayConfig configures the circuit v2 relay transport.\n */\nexport interface CircuitRelayTransportInit extends RelayStoreInit {\n  /**\n   * The number of peers running diable relays to search for and\n   * connect to. (default: 0)\n   */\n  discoverRelays?: number\n\n  /**\n   * The maximum number of simultaneous STOP inbound streams that can be open at\n   * once - each inbound relayed connection uses a STOP stream (default: 300)\n   */\n  maxInboundStopStreams?: number\n\n  /**\n   * The maximum number of simultaneous STOP outbound streams that can be open at\n   * once. If this transport is used along with the relay server these settings\n   * should be set to the same value (default: 300)\n   */\n  maxOutboundStopStreams?: number\n\n  /**\n   * Incoming STOP requests (e.g. when a remote peer wants to dial us via a relay)\n   * must finish the initial protocol negotiation within this timeout in ms\n   * (default: 30000)\n   */\n  stopTimeout?: number\n\n  /**\n   * When creating a reservation it must complete within this number of ms\n   * (default: 10000)\n   */\n  reservationCompletionTimeout?: number\n}\n\nexport function circuitRelayTransport (init: CircuitRelayTransportInit = {}): (components: CircuitRelayTransportComponents) => Transport {\n  return (components) => {\n    return new CircuitRelayTransport(components, init)\n  }\n}\n"],
  "mappings": "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",
  "names": ["message", "original", "require_retry", "HopMessage", "Type", "__TypeValues", "StopMessage", "Peer", "Reservation", "Limit", "Status", "__StatusValues", "ReservationVoucher", "message", "retry", "ReservationStore", "defaults", "ReservationStore"]
}
