{
  "version": 3,
  "sources": ["../../event-iterator/lib/event-iterator.js", "../../event-iterator/lib/dom.js", "../../@multiformats/multiaddr-to-uri/src/index.ts", "../../it-ws/src/ready.ts", "../../it-ws/src/sink.ts", "../../it-ws/src/source.ts", "../../it-ws/src/duplex.ts", "../../it-ws/src/web-socket.browser.ts", "../../it-ws/src/ws-url.ts", "../../it-ws/src/client.ts", "../../@libp2p/websockets/src/listener.browser.ts", "../../@libp2p/websockets/src/socket-to-conn.ts", "../../@libp2p/websockets/src/index.ts"],
  "sourcesContent": ["\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nclass EventQueue {\n    constructor() {\n        this.pullQueue = [];\n        this.pushQueue = [];\n        this.eventHandlers = {};\n        this.isPaused = false;\n        this.isStopped = false;\n    }\n    push(value) {\n        if (this.isStopped)\n            return;\n        const resolution = { value, done: false };\n        if (this.pullQueue.length) {\n            const placeholder = this.pullQueue.shift();\n            if (placeholder)\n                placeholder.resolve(resolution);\n        }\n        else {\n            this.pushQueue.push(Promise.resolve(resolution));\n            if (this.highWaterMark !== undefined &&\n                this.pushQueue.length >= this.highWaterMark &&\n                !this.isPaused) {\n                this.isPaused = true;\n                if (this.eventHandlers.highWater) {\n                    this.eventHandlers.highWater();\n                }\n                else if (console) {\n                    console.warn(`EventIterator queue reached ${this.pushQueue.length} items`);\n                }\n            }\n        }\n    }\n    stop() {\n        if (this.isStopped)\n            return;\n        this.isStopped = true;\n        this.remove();\n        for (const placeholder of this.pullQueue) {\n            placeholder.resolve({ value: undefined, done: true });\n        }\n        this.pullQueue.length = 0;\n    }\n    fail(error) {\n        if (this.isStopped)\n            return;\n        this.isStopped = true;\n        this.remove();\n        if (this.pullQueue.length) {\n            for (const placeholder of this.pullQueue) {\n                placeholder.reject(error);\n            }\n            this.pullQueue.length = 0;\n        }\n        else {\n            const rejection = Promise.reject(error);\n            /* Attach error handler to avoid leaking an unhandled promise rejection. */\n            rejection.catch(() => { });\n            this.pushQueue.push(rejection);\n        }\n    }\n    remove() {\n        Promise.resolve().then(() => {\n            if (this.removeCallback)\n                this.removeCallback();\n        });\n    }\n    [Symbol.asyncIterator]() {\n        return {\n            next: (value) => {\n                const result = this.pushQueue.shift();\n                if (result) {\n                    if (this.lowWaterMark !== undefined &&\n                        this.pushQueue.length <= this.lowWaterMark &&\n                        this.isPaused) {\n                        this.isPaused = false;\n                        if (this.eventHandlers.lowWater) {\n                            this.eventHandlers.lowWater();\n                        }\n                    }\n                    return result;\n                }\n                else if (this.isStopped) {\n                    return Promise.resolve({ value: undefined, done: true });\n                }\n                else {\n                    return new Promise((resolve, reject) => {\n                        this.pullQueue.push({ resolve, reject });\n                    });\n                }\n            },\n            return: () => {\n                this.isStopped = true;\n                this.pushQueue.length = 0;\n                this.remove();\n                return Promise.resolve({ value: undefined, done: true });\n            },\n        };\n    }\n}\nclass EventIterator {\n    constructor(listen, { highWaterMark = 100, lowWaterMark = 1 } = {}) {\n        const queue = new EventQueue();\n        queue.highWaterMark = highWaterMark;\n        queue.lowWaterMark = lowWaterMark;\n        queue.removeCallback =\n            listen({\n                push: value => queue.push(value),\n                stop: () => queue.stop(),\n                fail: error => queue.fail(error),\n                on: (event, fn) => {\n                    queue.eventHandlers[event] = fn;\n                },\n            }) || (() => { });\n        this[Symbol.asyncIterator] = () => queue[Symbol.asyncIterator]();\n        Object.freeze(this);\n    }\n}\nexports.EventIterator = EventIterator;\nexports.default = EventIterator;\n", "\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nconst event_iterator_1 = require(\"./event-iterator\");\nexports.EventIterator = event_iterator_1.EventIterator;\nfunction subscribe(event, options, evOptions) {\n    return new event_iterator_1.EventIterator(({ push }) => {\n        this.addEventListener(event, push, options);\n        return () => this.removeEventListener(event, push, options);\n    }, evOptions);\n}\nexports.subscribe = subscribe;\nexports.default = event_iterator_1.EventIterator;\n", "/**\n * @packageDocumentation\n *\n * This module allows easy conversion of Multiaddrs to string URIs.\n *\n * @example Converting multiaddrs to string URIs\n *\n * ```js\n * import { multiaddrToUri } from '@multiformats/multiaddr-to-uri'\n *\n * console.log(multiaddrToUri('/dnsaddr/protocol.ai/https'))\n * // -> https://protocol.ai\n *\n * console.log(multiaddrToUri('/ip4/127.0.0.1/tcp/8080'))\n * // -> http://127.0.0.1:8080\n *\n * console.log(multiaddrToUri('/ip4/127.0.0.1/tcp/8080', { assumeHttp: false }))\n * // -> tcp://127.0.0.1:8080\n * ```\n *\n * Note:\n *\n * - When `/tcp` is the last (terminating) protocol HTTP is assumed by default (implicit `assumeHttp: true`)\n *   - this means produced URIs will start with `http://` instead of `tcp://`\n *   - passing `{ assumeHttp: false }` disables this behavior\n * - Might be lossy - e.g. a DNSv6 multiaddr\n * - Can throw if the passed multiaddr:\n *   - is not a valid multiaddr\n *   - is not supported as a URI e.g. circuit\n */\n\nimport { multiaddr, protocols } from '@multiformats/multiaddr'\nimport type { Multiaddr, StringTuple } from '@multiformats/multiaddr'\n\nexport interface MultiaddrToUriOpts {\n  assumeHttp?: boolean\n}\n\nconst ASSUME_HTTP_CODES = [\n  protocols('tcp').code,\n  protocols('dns').code,\n  protocols('dnsaddr').code,\n  protocols('dns4').code,\n  protocols('dns6').code\n]\n\ninterface Interpreter { (value: string, ma: StringTuple[]): string }\n\nfunction extractSNI (ma: StringTuple[]): string | null {\n  let sniProtoCode: number\n  try {\n    sniProtoCode = protocols('sni').code\n  } catch (e) {\n    // No SNI protocol in multiaddr\n    return null\n  }\n  for (const [proto, value] of ma) {\n    if (proto === sniProtoCode && value !== undefined) {\n      return value\n    }\n  }\n  return null\n}\n\nfunction hasTLS (ma: StringTuple[]): boolean {\n  return ma.some(([proto, _]) => proto === protocols('tls').code)\n}\n\nfunction interpretNext (headProtoCode: number, headProtoVal: string, restMa: StringTuple[]): string {\n  const interpreter = interpreters[protocols(headProtoCode).name]\n  if (interpreter === undefined) {\n    throw new Error(`Can't interpret protocol ${protocols(headProtoCode).name}`)\n  }\n  const restVal = interpreter(headProtoVal, restMa)\n  if (headProtoCode === protocols('ip6').code) {\n    return `[${restVal}]`\n  }\n  return restVal\n}\n\nconst interpreters: Record<string, Interpreter> = {\n  ip4: (value: string, restMa: StringTuple[]) => value,\n  ip6: (value: string, restMa: StringTuple[]) => {\n    if (restMa.length === 0) {\n      return value\n    }\n    return `[${value}]`\n  },\n  tcp: (value: string, restMa: StringTuple[]) => {\n    const tailProto = restMa.pop()\n    if (tailProto === undefined) {\n      throw new Error('Unexpected end of multiaddr')\n    }\n    return `tcp://${interpretNext(tailProto[0], tailProto[1] ?? '', restMa)}:${value}`\n  },\n  udp: (value: string, restMa: StringTuple[]) => {\n    const tailProto = restMa.pop()\n    if (tailProto === undefined) {\n      throw new Error('Unexpected end of multiaddr')\n    }\n    return `udp://${interpretNext(tailProto[0], tailProto[1] ?? '', restMa)}:${value}`\n  },\n  dnsaddr: (value: string, restMa: StringTuple[]) => value,\n  dns4: (value: string, restMa: StringTuple[]) => value,\n  dns6: (value: string, restMa: StringTuple[]) => value,\n  dns: (value: string, restMa: StringTuple[]) => value,\n  ipfs: (value: string, restMa: StringTuple[]) => {\n    const tailProto = restMa.pop()\n    if (tailProto === undefined) {\n      throw new Error('Unexpected end of multiaddr')\n    }\n    return `${interpretNext(tailProto[0], tailProto[1] ?? '', restMa)}/ipfs/${value}`\n  },\n  p2p: (value: string, restMa: StringTuple[]) => {\n    const tailProto = restMa.pop()\n    if (tailProto === undefined) {\n      throw new Error('Unexpected end of multiaddr')\n    }\n    return `${interpretNext(tailProto[0], tailProto[1] ?? '', restMa)}/p2p/${value}`\n  },\n  http: (value: string, restMa: StringTuple[]) => {\n    const maHasTLS = hasTLS(restMa)\n    const sni = extractSNI(restMa)\n    if (maHasTLS && sni !== null) {\n      return `https://${sni}`\n    }\n    const protocol = maHasTLS ? 'https://' : 'http://'\n    const tailProto = restMa.pop()\n    if (tailProto === undefined) {\n      throw new Error('Unexpected end of multiaddr')\n    }\n    let baseVal = interpretNext(tailProto[0], tailProto[1] ?? '', restMa)\n    // We are reinterpreting the base as http, so we need to remove the tcp:// if it's there\n    baseVal = baseVal.replace('tcp://', '')\n    return `${protocol}${baseVal}`\n  },\n  tls: (value: string, restMa: StringTuple[]) => {\n    // Noop, the parent context knows that it's tls. We don't need to do\n    // anything here\n    const tailProto = restMa.pop()\n    if (tailProto === undefined) {\n      throw new Error('Unexpected end of multiaddr')\n    }\n    return interpretNext(tailProto[0], tailProto[1] ?? '', restMa)\n  },\n  sni: (value: string, restMa: StringTuple[]) => {\n    // Noop, the parent context uses the sni information, we don't need to do\n    // anything here\n    const tailProto = restMa.pop()\n    if (tailProto === undefined) {\n      throw new Error('Unexpected end of multiaddr')\n    }\n    return interpretNext(tailProto[0], tailProto[1] ?? '', restMa)\n  },\n  https: (value: string, restMa: StringTuple[]) => {\n    const tailProto = restMa.pop()\n    if (tailProto === undefined) {\n      throw new Error('Unexpected end of multiaddr')\n    }\n    let baseVal = interpretNext(tailProto[0], tailProto[1] ?? '', restMa)\n    // We are reinterpreting the base as http, so we need to remove the tcp:// if it's there\n    baseVal = baseVal.replace('tcp://', '')\n    return `https://${baseVal}`\n  },\n  ws: (value: string, restMa: StringTuple[]) => {\n    const maHasTLS = hasTLS(restMa)\n    const sni = extractSNI(restMa)\n    if (maHasTLS && sni !== null) {\n      return `wss://${sni}`\n    }\n    const protocol = maHasTLS ? 'wss://' : 'ws://'\n    const tailProto = restMa.pop()\n    if (tailProto === undefined) {\n      throw new Error('Unexpected end of multiaddr')\n    }\n    let baseVal = interpretNext(tailProto[0], tailProto[1] ?? '', restMa)\n    // We are reinterpreting the base, so we need to remove the tcp:// if it's there\n    baseVal = baseVal.replace('tcp://', '')\n    return `${protocol}${baseVal}`\n  },\n  wss: (value: string, restMa: StringTuple[]) => {\n    const tailProto = restMa.pop()\n    if (tailProto === undefined) {\n      throw new Error('Unexpected end of multiaddr')\n    }\n    let baseVal = interpretNext(tailProto[0], tailProto[1] ?? '', restMa)\n    // We are reinterpreting the base as http, so we need to remove the tcp:// if it's there\n    baseVal = baseVal.replace('tcp://', '')\n    return `wss://${baseVal}`\n  },\n  'p2p-websocket-star': (value: string, restMa: StringTuple[]) => {\n    const tailProto = restMa.pop()\n    if (tailProto === undefined) {\n      throw new Error('Unexpected end of multiaddr')\n    }\n    return `${interpretNext(tailProto[0], tailProto[1] ?? '', restMa)}/p2p-websocket-star`\n  },\n  'p2p-webrtc-star': (value: string, restMa: StringTuple[]) => {\n    const tailProto = restMa.pop()\n    if (tailProto === undefined) {\n      throw new Error('Unexpected end of multiaddr')\n    }\n    return `${interpretNext(tailProto[0], tailProto[1] ?? '', restMa)}/p2p-webrtc-star`\n  },\n  'p2p-webrtc-direct': (value: string, restMa: StringTuple[]) => {\n    const tailProto = restMa.pop()\n    if (tailProto === undefined) {\n      throw new Error('Unexpected end of multiaddr')\n    }\n    return `${interpretNext(tailProto[0], tailProto[1] ?? '', restMa)}/p2p-webrtc-direct`\n  }\n}\n\nexport function multiaddrToUri (input: Multiaddr | string | Uint8Array, opts?: MultiaddrToUriOpts): string {\n  const ma = multiaddr(input)\n  const parts = ma.stringTuples()\n  const head = parts.pop()\n  if (head === undefined) {\n    throw new Error('Unexpected end of multiaddr')\n  }\n\n  const protocol = protocols(head[0])\n  const interpreter = interpreters[protocol.name]\n\n  if (interpreter == null) {\n    throw new Error(`No interpreter found for ${protocol.name}`)\n  }\n\n  let uri = interpreter(head[1] ?? '', parts)\n\n  if (opts?.assumeHttp !== false && ASSUME_HTTP_CODES.includes(head[0])) {\n    // strip any declared protocol\n    uri = uri.replace(/^.*:\\/\\//, '')\n\n    if (head[1] === '443') {\n      uri = `https://${uri}`\n    } else {\n      uri = `http://${uri}`\n    }\n  }\n\n  if (uri.startsWith('http://') || uri.startsWith('https://')) {\n    // this will strip default ports while keeping paths intact\n    uri = new URL(uri).toString()\n\n    // strip trailing slash, e.g. http://127.0.0.1/ -> http://127.0.0.1\n    if (uri.endsWith('/')) {\n      uri = uri.substring(0, uri.length - 1)\n    }\n  }\n\n  return uri\n}\n", "import type { ErrorEvent, WebSocket } from 'ws'\n\nexport default async (socket: WebSocket): Promise<void> => {\n  // if the socket is closing or closed, return end\n  if (socket.readyState >= 2) {\n    throw new Error('socket closed')\n  }\n\n  // if open, return\n  if (socket.readyState === 1) {\n    return\n  }\n\n  await new Promise<void>((resolve, reject) => {\n    function cleanup (): void {\n      socket.removeEventListener('open', handleOpen)\n      socket.removeEventListener('error', handleErr)\n    }\n\n    function handleOpen (): void {\n      cleanup()\n      resolve()\n    }\n\n    function handleErr (event: ErrorEvent): void {\n      cleanup()\n      reject(event.error ?? new Error(`connect ECONNREFUSED ${socket.url}`))\n    }\n\n    socket.addEventListener('open', handleOpen)\n    socket.addEventListener('error', handleErr)\n  })\n}\n", "import ready from './ready.js'\nimport type { Sink, Source } from 'it-stream-types'\nimport type { WebSocket } from 'ws'\n\nexport interface SinkOptions {\n  closeOnEnd?: boolean\n}\n\nexport default (socket: WebSocket, options: SinkOptions): Sink<Source<Uint8Array>, Promise<void>> => {\n  options = options ?? {}\n  options.closeOnEnd = options.closeOnEnd !== false\n\n  const sink: Sink<Source<Uint8Array>, Promise<void>> = async source => {\n    for await (const data of source) {\n      try {\n        await ready(socket)\n      } catch (err: any) {\n        if (err.message === 'socket closed') break\n        throw err\n      }\n\n      // the ready promise resolved without error but the socket was closing so\n      // exit the loop and don't send data\n      if (socket.readyState === socket.CLOSING || socket.readyState === socket.CLOSED) {\n        break\n      }\n\n      socket.send(data)\n    }\n\n    if (options.closeOnEnd != null && socket.readyState <= 1) {\n      await new Promise<void>((resolve, reject) => {\n        socket.addEventListener('close', event => {\n          if (event.wasClean || event.code === 1006) {\n            resolve()\n          } else {\n            const err = Object.assign(new Error('ws error'), { event })\n            reject(err)\n          }\n        })\n\n        setTimeout(() => { socket.close() })\n      })\n    }\n  }\n\n  return sink\n}\n", "import { EventIterator } from 'event-iterator'\nimport { fromString as uint8ArrayFromString } from 'uint8arrays/from-string'\nimport type { WebSocket, ErrorEvent, MessageEvent } from 'ws'\n\n// copied from github.com/feross/buffer\n// Some ArrayBuffers are not passing the instanceof check, so we need to do a bit more work :(\nfunction isArrayBuffer (obj: any): obj is ArrayBuffer {\n  return (obj instanceof ArrayBuffer) ||\n    (obj?.constructor?.name === 'ArrayBuffer' && typeof obj?.byteLength === 'number')\n}\n\nexport interface ConnectedSource extends AsyncGenerator<Uint8Array> {\n  connected: () => Promise<void>\n}\n\nexport default (socket: WebSocket): ConnectedSource => {\n  socket.binaryType = 'arraybuffer'\n\n  const connected = async (): Promise<void> => {\n    await new Promise<void>((resolve, reject) => {\n      if (isConnected) {\n        resolve(); return\n      }\n      if (connError != null) {\n        reject(connError); return\n      }\n\n      const cleanUp = (cont: () => void): void => {\n        socket.removeEventListener('open', onOpen)\n        socket.removeEventListener('error', onError)\n        cont()\n      }\n\n      const onOpen = (): void => { cleanUp(resolve) }\n      const onError = (event: ErrorEvent): void => {\n        cleanUp(() => { reject(event.error ?? new Error(`connect ECONNREFUSED ${socket.url}`)) })\n      }\n\n      socket.addEventListener('open', onOpen)\n      socket.addEventListener('error', onError)\n    })\n  }\n\n  const source = (async function * () {\n    const messages = new EventIterator<Uint8Array>(\n      ({ push, stop, fail }) => {\n        const onMessage = (event: MessageEvent): void => {\n          let data: Uint8Array | null = null\n\n          if (typeof event.data === 'string') {\n            data = uint8ArrayFromString(event.data)\n          }\n\n          if (isArrayBuffer(event.data)) {\n            data = new Uint8Array(event.data)\n          }\n\n          if (event.data instanceof Uint8Array) {\n            data = event.data\n          }\n\n          if (data == null) {\n            return\n          }\n\n          push(data)\n        }\n        const onError = (event: ErrorEvent): void => { fail(event.error ?? new Error('Socket error')) }\n\n        socket.addEventListener('message', onMessage)\n        socket.addEventListener('error', onError)\n        socket.addEventListener('close', stop)\n\n        return () => {\n          socket.removeEventListener('message', onMessage)\n          socket.removeEventListener('error', onError)\n          socket.removeEventListener('close', stop)\n        }\n      },\n      { highWaterMark: Infinity }\n    )\n\n    await connected()\n\n    for await (const chunk of messages) {\n      yield isArrayBuffer(chunk) ? new Uint8Array(chunk) : chunk\n    }\n  }())\n\n  let isConnected = socket.readyState === 1\n  let connError: Error | null\n\n  socket.addEventListener('open', () => {\n    isConnected = true\n    connError = null\n  })\n\n  socket.addEventListener('close', () => {\n    isConnected = false\n    connError = null\n  })\n\n  socket.addEventListener('error', event => {\n    if (!isConnected) {\n      connError = event.error ?? new Error(`connect ECONNREFUSED ${socket.url}`)\n    }\n  })\n\n  return Object.assign(source, {\n    connected\n  })\n}\n", "import sink from './sink.js'\nimport source from './source.js'\nimport type { SinkOptions } from './sink.js'\nimport type WebSocket from './web-socket.js'\nimport type { Duplex, Source } from 'it-stream-types'\n\nexport interface DuplexWebSocket extends Duplex<AsyncGenerator<Uint8Array>, Source<Uint8Array>, Promise<void>> {\n  connected: () => Promise<void>\n  localAddress?: string\n  localPort?: number\n  remoteAddress: string\n  remotePort: number\n  close: () => Promise<void>\n  destroy: () => void\n  socket: WebSocket\n}\n\nexport interface DuplexWebSocketOptions extends SinkOptions {\n  remoteAddress?: string\n  remotePort?: number\n}\n\nexport default (socket: WebSocket, options?: DuplexWebSocketOptions): DuplexWebSocket => {\n  options = options ?? {}\n\n  const connectedSource = source(socket)\n  let remoteAddress: string | undefined = options.remoteAddress\n  let remotePort: number | undefined = options.remotePort\n\n  if (socket.url != null) {\n    // only client->server sockets have urls, server->client connections do not\n    try {\n      const url = new URL(socket.url)\n      remoteAddress = url.hostname\n      remotePort = parseInt(url.port, 10)\n    } catch {}\n  }\n\n  if (remoteAddress == null || remotePort == null) {\n    throw new Error('Remote connection did not have address and/or port')\n  }\n\n  const duplex: DuplexWebSocket = {\n    sink: sink(socket, options),\n    source: connectedSource,\n    connected: async () => { await connectedSource.connected() },\n    close: async () => {\n      if (socket.readyState === socket.CONNECTING || socket.readyState === socket.OPEN) {\n        await new Promise<void>((resolve) => {\n          socket.addEventListener('close', () => {\n            resolve()\n          })\n          socket.close()\n        })\n      }\n    },\n    destroy: () => {\n      if (socket.terminate != null) {\n        socket.terminate()\n      } else {\n        socket.close()\n      }\n    },\n    remoteAddress,\n    remotePort,\n    socket\n  }\n\n  return duplex\n}\n", "/* eslint-env browser */\n\nexport default WebSocket\n", "const map = { 'http:': 'ws:', 'https:': 'wss:' }\nconst defaultProtocol = 'ws:'\n\nexport default (url: string, location?: Partial<Location>): URL => {\n  if (url.startsWith('//')) {\n    url = `${location?.protocol ?? defaultProtocol}${url}`\n  }\n\n  if (url.startsWith('/') && location != null) {\n    const proto = location.protocol ?? defaultProtocol\n    const host = location.host\n    const port = location.port != null && host?.endsWith(`:${location.port}`) !== true ? `:${location.port}` : ''\n    url = `${proto}//${host}${port}${url}`\n  }\n\n  const wsUrl = new URL(url)\n\n  for (const [httpProto, wsProto] of Object.entries(map)) {\n    if (wsUrl.protocol === httpProto) {\n      wsUrl.protocol = wsProto\n    }\n  }\n\n  return wsUrl\n}\n", "// load websocket library if we are not in the browser\nimport duplex from './duplex.js'\nimport WebSocket from './web-socket.js'\nimport wsurl from './ws-url.js'\nimport type { DuplexWebSocket } from './duplex.js'\nimport type { SinkOptions } from './sink.js'\nimport type { ClientOptions } from 'ws'\n\nexport interface WebSocketOptions extends SinkOptions {\n  websocket?: ClientOptions\n}\n\nexport function connect (addr: string, opts?: WebSocketOptions): DuplexWebSocket {\n  const location = typeof window === 'undefined' ? undefined : window.location\n  opts = opts ?? {}\n\n  const url = wsurl(addr, location)\n\n  // it's necessary to stringify the URL object otherwise react-native crashes\n  const socket = new WebSocket(url.toString(), opts.websocket)\n  return duplex(socket, opts)\n}\n", "import type { Listener } from '@libp2p/interface'\n\nexport function createListener (): Listener {\n  throw new Error('WebSocket Servers can not be created in the browser!')\n}\n", "import { CodeError } from '@libp2p/interface'\nimport { CLOSE_TIMEOUT } from './constants.js'\nimport type { AbortOptions, ComponentLogger, MultiaddrConnection } from '@libp2p/interface'\nimport type { Multiaddr } from '@multiformats/multiaddr'\nimport type { DuplexWebSocket } from 'it-ws/duplex'\n\nexport interface SocketToConnOptions {\n  localAddr?: Multiaddr\n  logger: ComponentLogger\n}\n\n// Convert a stream into a MultiaddrConnection\n// https://github.com/libp2p/interface-transport#multiaddrconnection\nexport function socketToMaConn (stream: DuplexWebSocket, remoteAddr: Multiaddr, options: SocketToConnOptions): MultiaddrConnection {\n  const log = options.logger.forComponent('libp2p:websockets:maconn')\n\n  const maConn: MultiaddrConnection = {\n    log,\n\n    async sink (source) {\n      try {\n        await stream.sink((async function * () {\n          for await (const buf of source) {\n            if (buf instanceof Uint8Array) {\n              yield buf\n            } else {\n              yield buf.subarray()\n            }\n          }\n        })())\n      } catch (err: any) {\n        if (err.type !== 'aborted') {\n          log.error(err)\n        }\n      }\n    },\n\n    source: stream.source,\n\n    remoteAddr,\n\n    timeline: { open: Date.now() },\n\n    async close (options: AbortOptions = {}) {\n      const start = Date.now()\n\n      if (options.signal == null) {\n        const signal = AbortSignal.timeout(CLOSE_TIMEOUT)\n\n        options = {\n          ...options,\n          signal\n        }\n      }\n\n      const listener = (): void => {\n        const { host, port } = maConn.remoteAddr.toOptions()\n        log('timeout closing stream to %s:%s after %dms, destroying it manually',\n          host, port, Date.now() - start)\n\n        this.abort(new CodeError('Socket close timeout', 'ERR_SOCKET_CLOSE_TIMEOUT'))\n      }\n\n      options.signal?.addEventListener('abort', listener)\n\n      try {\n        await stream.close()\n      } catch (err: any) {\n        log.error('error closing WebSocket gracefully', err)\n        this.abort(err)\n      } finally {\n        options.signal?.removeEventListener('abort', listener)\n        maConn.timeline.close = Date.now()\n      }\n    },\n\n    abort (err: Error): void {\n      const { host, port } = maConn.remoteAddr.toOptions()\n      log('timeout closing stream to %s:%s due to error',\n        host, port, err)\n\n      stream.destroy()\n      maConn.timeline.close = Date.now()\n    }\n  }\n\n  stream.socket.addEventListener('close', () => {\n    // In instances where `close` was not explicitly called,\n    // such as an iterable stream ending, ensure we have set the close\n    // timeline\n    if (maConn.timeline.close == null) {\n      maConn.timeline.close = Date.now()\n    }\n  }, { once: true })\n\n  return maConn\n}\n", "/**\n * @packageDocumentation\n *\n * A [libp2p transport](https://docs.libp2p.io/concepts/transports/overview/) based on [WebSockets](https://developer.mozilla.org/en-US/docs/Web/API/WebSockets_API).\n *\n * @example\n *\n * ```TypeScript\n * import { createLibp2p } from 'libp2p'\n * import { webSockets } from '@libp2p/websockets'\n * import { multiaddr } from '@multiformats/multiaddr'\n *\n * const node = await createLibp2p({\n *   transports: [\n *     webSockets()\n *   ]\n * //... other config\n * })\n * await node.start()\n *\n * const ma = multiaddr('/ip4/127.0.0.1/tcp/9090/ws')\n * await node.dial(ma)\n * ```\n *\n * ## Filters\n *\n * When run in a browser by default this module will only connect to secure web socket addresses.\n *\n * To change this you should pass a filter to the factory function.\n *\n * You can create your own address filters for this transports, or rely in the filters [provided](./src/filters.js).\n *\n * The available filters are:\n *\n * - `filters.all`\n *   - Returns all TCP and DNS based addresses, both with `ws` or `wss`.\n * - `filters.dnsWss`\n *   - Returns all DNS based addresses with `wss`.\n * - `filters.dnsWsOrWss`\n *   - Returns all DNS based addresses, both with `ws` or `wss`.\n *\n * @example Allow dialing insecure WebSockets\n *\n * ```TypeScript\n * import { createLibp2p } from 'libp2p'\n * import { webSockets } from '@libp2p/websockets'\n * import filters from '@libp2p/websockets/filters'\n *\n * const node = await createLibp2p({\n *   transports: [\n *     webSockets({\n *       // connect to all sockets, even insecure ones\n *       filter: filters.all\n *     })\n *   ]\n * })\n * ```\n */\n\nimport { AbortError, CodeError } from '@libp2p/interface'\nimport { type Transport, type MultiaddrFilter, transportSymbol, type CreateListenerOptions, type DialOptions, type Listener, type AbortOptions, type ComponentLogger, type Logger, type Connection } from '@libp2p/interface'\nimport { multiaddrToUri as toUri } from '@multiformats/multiaddr-to-uri'\nimport { connect, type WebSocketOptions } from 'it-ws/client'\nimport pDefer from 'p-defer'\nimport { isBrowser, isWebWorker } from 'wherearewe'\nimport * as filters from './filters.js'\nimport { createListener } from './listener.js'\nimport { socketToMaConn } from './socket-to-conn.js'\nimport type { Multiaddr } from '@multiformats/multiaddr'\nimport type { Server } from 'http'\nimport type { DuplexWebSocket } from 'it-ws/duplex'\nimport type { ClientOptions } from 'ws'\n\nexport interface WebSocketsInit extends AbortOptions, WebSocketOptions {\n  filter?: MultiaddrFilter\n  websocket?: ClientOptions\n  server?: Server\n}\n\nexport interface WebSocketsComponents {\n  logger: ComponentLogger\n}\n\nclass WebSockets implements Transport {\n  private readonly log: Logger\n  private readonly init?: WebSocketsInit\n  private readonly logger: ComponentLogger\n\n  constructor (components: WebSocketsComponents, init?: WebSocketsInit) {\n    this.log = components.logger.forComponent('libp2p:websockets')\n    this.logger = components.logger\n    this.init = init\n  }\n\n  readonly [Symbol.toStringTag] = '@libp2p/websockets'\n\n  readonly [transportSymbol] = true\n\n  async dial (ma: Multiaddr, options: DialOptions): Promise<Connection> {\n    this.log('dialing %s', ma)\n    options = options ?? {}\n\n    const socket = await this._connect(ma, options)\n    const maConn = socketToMaConn(socket, ma, {\n      logger: this.logger\n    })\n    this.log('new outbound connection %s', maConn.remoteAddr)\n\n    const conn = await options.upgrader.upgradeOutbound(maConn)\n    this.log('outbound connection %s upgraded', maConn.remoteAddr)\n    return conn\n  }\n\n  async _connect (ma: Multiaddr, options: AbortOptions): Promise<DuplexWebSocket> {\n    if (options?.signal?.aborted === true) {\n      throw new AbortError()\n    }\n    const cOpts = ma.toOptions()\n    this.log('dialing %s:%s', cOpts.host, cOpts.port)\n\n    const errorPromise = pDefer()\n    const rawSocket = connect(toUri(ma), this.init)\n    rawSocket.socket.addEventListener('error', () => {\n      // the WebSocket.ErrorEvent type doesn't actually give us any useful\n      // information about what happened\n      // https://developer.mozilla.org/en-US/docs/Web/API/WebSocket/error_event\n      const err = new CodeError(`Could not connect to ${ma.toString()}`, 'ERR_CONNECTION_FAILED')\n      this.log.error('connection error:', err)\n      errorPromise.reject(err)\n    })\n\n    if (options.signal == null) {\n      await Promise.race([rawSocket.connected(), errorPromise.promise])\n\n      this.log('connected %s', ma)\n      return rawSocket\n    }\n\n    // Allow abort via signal during connect\n    let onAbort\n    const abort = new Promise((resolve, reject) => {\n      onAbort = () => {\n        reject(new AbortError())\n        rawSocket.close().catch(err => {\n          this.log.error('error closing raw socket', err)\n        })\n      }\n\n      // Already aborted?\n      if (options?.signal?.aborted === true) {\n        onAbort(); return\n      }\n\n      options?.signal?.addEventListener('abort', onAbort)\n    })\n\n    try {\n      await Promise.race([abort, errorPromise.promise, rawSocket.connected()])\n    } finally {\n      if (onAbort != null) {\n        options?.signal?.removeEventListener('abort', onAbort)\n      }\n    }\n\n    this.log('connected %s', ma)\n    return rawSocket\n  }\n\n  /**\n   * Creates a Websockets listener. The provided `handler` function will be called\n   * anytime a new incoming Connection has been successfully upgraded via\n   * `upgrader.upgradeInbound`\n   */\n  createListener (options: CreateListenerOptions): Listener {\n    return createListener({\n      logger: this.logger\n    }, {\n      ...this.init,\n      ...options\n    })\n  }\n\n  /**\n   * Takes a list of `Multiaddr`s and returns only valid Websockets addresses.\n   * By default, in a browser environment only DNS+WSS multiaddr is accepted,\n   * while in a Node.js environment DNS+{WS, WSS} multiaddrs are accepted.\n   */\n  listenFilter (multiaddrs: Multiaddr[]): Multiaddr[] {\n    multiaddrs = Array.isArray(multiaddrs) ? multiaddrs : [multiaddrs]\n\n    if (this.init?.filter != null) {\n      return this.init?.filter(multiaddrs)\n    }\n\n    // Browser\n    if (isBrowser || isWebWorker) {\n      return filters.wss(multiaddrs)\n    }\n\n    return filters.all(multiaddrs)\n  }\n\n  /**\n   * Filter check for all Multiaddrs that this transport can dial\n   */\n  dialFilter (multiaddrs: Multiaddr[]): Multiaddr[] {\n    return this.listenFilter(multiaddrs)\n  }\n}\n\nexport function webSockets (init: WebSocketsInit = {}): (components: WebSocketsComponents) => Transport {\n  return (components) => {\n    return new WebSockets(components, init)\n  }\n}\n"],
  "mappings": "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",
  "names": ["EventIterator", "options"]
}
