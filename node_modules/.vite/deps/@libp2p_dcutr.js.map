{
  "version": 3,
  "sources": ["../../@libp2p/dcutr/src/pb/message.ts", "../../@libp2p/dcutr/src/utils.ts", "../../@libp2p/dcutr/src/dcutr.ts", "../../@libp2p/dcutr/src/index.ts"],
  "sourcesContent": ["/* eslint-disable import/export */\n/* eslint-disable complexity */\n/* eslint-disable @typescript-eslint/no-namespace */\n/* eslint-disable @typescript-eslint/no-unnecessary-boolean-literal-compare */\n/* eslint-disable @typescript-eslint/no-empty-interface */\n\nimport { enumeration, encodeMessage, decodeMessage, message } from 'protons-runtime'\nimport type { Codec } from 'protons-runtime'\nimport type { Uint8ArrayList } from 'uint8arraylist'\n\nexport interface HolePunch {\n  type?: HolePunch.Type\n  observedAddresses: Uint8Array[]\n}\n\nexport namespace HolePunch {\n  export enum Type {\n    UNUSED = 'UNUSED',\n    CONNECT = 'CONNECT',\n    SYNC = 'SYNC'\n  }\n\n  enum __TypeValues {\n    UNUSED = 0,\n    CONNECT = 100,\n    SYNC = 300\n  }\n\n  export namespace Type {\n    export const codec = (): Codec<Type> => {\n      return enumeration<Type>(__TypeValues)\n    }\n  }\n\n  let _codec: Codec<HolePunch>\n\n  export const codec = (): Codec<HolePunch> => {\n    if (_codec == null) {\n      _codec = message<HolePunch>((obj, w, opts = {}) => {\n        if (opts.lengthDelimited !== false) {\n          w.fork()\n        }\n\n        if (obj.type != null) {\n          w.uint32(8)\n          HolePunch.Type.codec().encode(obj.type, w)\n        }\n\n        if (obj.observedAddresses != null) {\n          for (const value of obj.observedAddresses) {\n            w.uint32(18)\n            w.bytes(value)\n          }\n        }\n\n        if (opts.lengthDelimited !== false) {\n          w.ldelim()\n        }\n      }, (reader, length) => {\n        const obj: any = {\n          observedAddresses: []\n        }\n\n        const end = length == null ? reader.len : reader.pos + length\n\n        while (reader.pos < end) {\n          const tag = reader.uint32()\n\n          switch (tag >>> 3) {\n            case 1:\n              obj.type = HolePunch.Type.codec().decode(reader)\n              break\n            case 2:\n              obj.observedAddresses.push(reader.bytes())\n              break\n            default:\n              reader.skipType(tag & 7)\n              break\n          }\n        }\n\n        return obj\n      })\n    }\n\n    return _codec\n  }\n\n  export const encode = (obj: Partial<HolePunch>): Uint8Array => {\n    return encodeMessage(obj, HolePunch.codec())\n  }\n\n  export const decode = (buf: Uint8Array | Uint8ArrayList): HolePunch => {\n    return decodeMessage(buf, HolePunch.codec())\n  }\n}\n", "import { isPrivateIp } from '@libp2p/utils/private-ip'\nimport { type Multiaddr } from '@multiformats/multiaddr'\nimport { Circuit, IP, DNS } from '@multiformats/multiaddr-matcher'\nimport type { TransportManager } from '@libp2p/interface-internal'\n\n/**\n * Returns true if the passed multiaddr is public, not relayed and we have a\n * transport that can dial it\n */\nexport function isPublicAndDialable (ma: Multiaddr, transportManager: TransportManager): boolean {\n  // ignore circuit relay\n  if (Circuit.matches(ma)) {\n    return false\n  }\n\n  const transport = transportManager.dialTransportForMultiaddr(ma)\n\n  if (transport == null) {\n    return false\n  }\n\n  // dns addresses are probably public?\n  if (DNS.matches(ma)) {\n    return true\n  }\n\n  // ensure we have only IPv4/IPv6 addresses\n  if (!IP.matches(ma)) {\n    return false\n  }\n\n  return isPrivateIp(ma.toOptions().host) === false\n}\n", "import { CodeError, ERR_INVALID_MESSAGE } from '@libp2p/interface'\nimport { type Multiaddr, multiaddr } from '@multiformats/multiaddr'\nimport delay from 'delay'\nimport { pbStream } from 'it-protobuf-stream'\nimport { HolePunch } from './pb/message.js'\nimport { isPublicAndDialable } from './utils.js'\nimport { multicodec } from './index.js'\nimport type { DCUtRServiceComponents, DCUtRServiceInit } from './index.js'\nimport type { Logger, Connection, Stream, PeerStore, Startable } from '@libp2p/interface'\nimport type { AddressManager, ConnectionManager, Registrar, TransportManager } from '@libp2p/interface-internal'\n\n// https://github.com/libp2p/specs/blob/master/relay/DCUtR.md#rpc-messages\nconst MAX_DCUTR_MESSAGE_SIZE = 1024 * 4\n// ensure the dial has a high priority to jump to the head of the dial queue\nconst DCUTR_DIAL_PRIORITY = 100\n\nconst defaultValues = {\n  // https://github.com/libp2p/go-libp2p/blob/8d2e54e1637041d5cf4fac1e531287560bd1f4ac/p2p/protocol/holepunch/holepuncher.go#L27\n  timeout: 5000,\n  // https://github.com/libp2p/go-libp2p/blob/8d2e54e1637041d5cf4fac1e531287560bd1f4ac/p2p/protocol/holepunch/holepuncher.go#L28\n  retries: 3,\n  maxInboundStreams: 1,\n  maxOutboundStreams: 1\n}\n\nexport class DefaultDCUtRService implements Startable {\n  private started: boolean\n  private readonly timeout: number\n  private readonly retries: number\n  private readonly maxInboundStreams: number\n  private readonly maxOutboundStreams: number\n  private readonly peerStore: PeerStore\n  private readonly registrar: Registrar\n  private readonly connectionManager: ConnectionManager\n  private readonly addressManager: AddressManager\n  private readonly transportManager: TransportManager\n  private topologyId?: string\n  private readonly log: Logger\n\n  constructor (components: DCUtRServiceComponents, init: DCUtRServiceInit) {\n    this.log = components.logger.forComponent('libp2p:dcutr')\n    this.started = false\n    this.peerStore = components.peerStore\n    this.registrar = components.registrar\n    this.addressManager = components.addressManager\n    this.connectionManager = components.connectionManager\n    this.transportManager = components.transportManager\n\n    this.timeout = init.timeout ?? defaultValues.timeout\n    this.retries = init.retries ?? defaultValues.retries\n    this.maxInboundStreams = init.maxInboundStreams ?? defaultValues.maxInboundStreams\n    this.maxOutboundStreams = init.maxOutboundStreams ?? defaultValues.maxOutboundStreams\n  }\n\n  isStarted (): boolean {\n    return this.started\n  }\n\n  async start (): Promise<void> {\n    if (this.started) {\n      return\n    }\n\n    // register for notifications of when peers that support DCUtR connect\n    // nb. requires the identify service to be enabled\n    this.topologyId = await this.registrar.register(multicodec, {\n      notifyOnTransient: true,\n      onConnect: (peerId, connection) => {\n        if (!connection.transient) {\n          // the connection is already direct, no upgrade is required\n          return\n        }\n\n        // the inbound peer starts the connection upgrade\n        if (connection.direction !== 'inbound') {\n          return\n        }\n\n        this.upgradeInbound(connection)\n          .catch(err => {\n            this.log.error('error during outgoing DCUtR attempt', err)\n          })\n      }\n    })\n\n    await this.registrar.handle(multicodec, (data) => {\n      void this.handleIncomingUpgrade(data.stream, data.connection).catch(err => {\n        this.log.error('error during incoming DCUtR attempt', err)\n        data.stream.abort(err)\n      })\n    }, {\n      maxInboundStreams: this.maxInboundStreams,\n      maxOutboundStreams: this.maxOutboundStreams,\n      runOnTransientConnection: true\n    })\n\n    this.started = true\n  }\n\n  async stop (): Promise<void> {\n    await this.registrar.unhandle(multicodec)\n\n    if (this.topologyId != null) {\n      this.registrar.unregister(this.topologyId)\n    }\n\n    this.started = false\n  }\n\n  /**\n   * Perform the inbound connection upgrade as B\n   *\n   * @see https://github.com/libp2p/specs/blob/master/relay/DCUtR.md#the-protocol\n   */\n  async upgradeInbound (relayedConnection: Connection): Promise<void> {\n    // Upon observing the new connection, the inbound peer (here B) checks the\n    // addresses advertised by A via identify.\n    //\n    // If that set includes public addresses, then A may be reachable by a direct\n    // connection, in which case B attempts a unilateral connection upgrade by\n    // initiating a direct connection to A.\n    if (await this.attemptUnilateralConnectionUpgrade(relayedConnection)) {\n      return\n    }\n\n    let stream: Stream | undefined\n\n    for (let i = 0; i < this.retries; i++) {\n      const options = {\n        signal: AbortSignal.timeout(this.timeout)\n      }\n\n      try {\n        // 1. B opens a stream to A using the /libp2p/dcutr protocol.\n        stream = await relayedConnection.newStream([multicodec], {\n          signal: options.signal,\n          runOnTransientConnection: true\n        })\n\n        const pb = pbStream(stream, {\n          maxDataLength: MAX_DCUTR_MESSAGE_SIZE\n        }).pb(HolePunch)\n\n        // 2. B sends to A a Connect message containing its observed (and\n        // possibly predicted) addresses from identify and starts a timer\n        // to measure RTT of the relay connection.\n        this.log('B sending connect to %p', relayedConnection.remotePeer)\n        const connectTimer = Date.now()\n        await pb.write({\n          type: HolePunch.Type.CONNECT,\n          observedAddresses: this.addressManager.getAddresses().map(ma => ma.bytes)\n        }, options)\n\n        this.log('B receiving connect from %p', relayedConnection.remotePeer)\n        // 4. Upon receiving the Connect, B sends a Sync message\n        const connect = await pb.read(options)\n\n        if (connect.type !== HolePunch.Type.CONNECT) {\n          this.log('A sent wrong message type')\n          throw new CodeError('DCUtR message type was incorrect', ERR_INVALID_MESSAGE)\n        }\n\n        const multiaddrs = this.getDialableMultiaddrs(connect.observedAddresses)\n\n        if (multiaddrs.length === 0) {\n          this.log('A did not have any dialable multiaddrs')\n          throw new CodeError('DCUtR connect message had no multiaddrs', ERR_INVALID_MESSAGE)\n        }\n\n        const rtt = Date.now() - connectTimer\n\n        this.log('A sending sync, rtt %dms', rtt)\n        await pb.write({\n          type: HolePunch.Type.SYNC,\n          observedAddresses: []\n        }, options)\n\n        this.log('A waiting for half RTT')\n        // ..and starts a timer for half the RTT measured from the time between\n        // sending the initial Connect and receiving the response\n        await delay(rtt / 2)\n\n        // TODO: when we have a QUIC transport, the dial step is different - for\n        // now we only have tcp support\n        // https://github.com/libp2p/specs/blob/master/relay/DCUtR.md#the-protocol\n\n        this.log('B dialing', multiaddrs)\n        // Upon expiry of the timer, B dials the address to A.\n        const conn = await this.connectionManager.openConnection(multiaddrs, {\n          signal: options.signal,\n          priority: DCUTR_DIAL_PRIORITY\n        })\n\n        this.log('DCUtR to %p succeeded to address %a, closing relayed connection', relayedConnection.remotePeer, conn.remoteAddr)\n        await relayedConnection.close(options)\n\n        break\n      } catch (err: any) {\n        this.log.error('error while attempting DCUtR on attempt %d of %d', i + 1, this.retries, err)\n        stream?.abort(err)\n\n        if (i === this.retries) {\n          throw err\n        }\n      } finally {\n        if (stream != null) {\n          await stream.close(options)\n        }\n      }\n    }\n  }\n\n  /**\n   * This is performed when A has dialed B via a relay but A also has a public\n   * address that B can dial directly\n   */\n  async attemptUnilateralConnectionUpgrade (relayedConnection: Connection): Promise<boolean> {\n    // Upon observing the new connection, the inbound peer (here B) checks the\n    // addresses advertised by A via identify.\n    const peerInfo = await this.peerStore.get(relayedConnection.remotePeer)\n\n    // If that set includes public addresses, then A may be reachable by a direct\n    // connection, in which case B attempts a unilateral connection upgrade by\n    // initiating a direct connection to A.\n    const publicAddresses = peerInfo.addresses\n      .map(address => {\n        const ma = address.multiaddr\n\n        // ensure all multiaddrs have the peer id\n        if (ma.getPeerId() == null) {\n          return ma.encapsulate(`/p2p/${relayedConnection.remotePeer}`)\n        }\n\n        return ma\n      })\n      .filter(ma => {\n        return isPublicAndDialable(ma, this.transportManager)\n      })\n\n    if (publicAddresses.length > 0) {\n      const signal = AbortSignal.timeout(this.timeout)\n\n      try {\n        this.log('attempting unilateral connection upgrade to %a', publicAddresses)\n\n        // force-dial the multiaddr(s), otherwise `connectionManager.openConnection`\n        // will return the existing relayed connection\n        const connection = await this.connectionManager.openConnection(publicAddresses, {\n          signal,\n          force: true\n        })\n\n        if (connection.transient) {\n          throw new Error('Could not open a new, non-transient, connection')\n        }\n\n        this.log('unilateral connection upgrade to %p succeeded via %a, closing relayed connection', relayedConnection.remotePeer, connection.remoteAddr)\n\n        await relayedConnection.close({\n          signal\n        })\n\n        return true\n      } catch (err) {\n        this.log.error('unilateral connection upgrade to %p on addresses %a failed', relayedConnection.remotePeer, publicAddresses, err)\n      }\n    } else {\n      this.log('peer %p has no public addresses, not attempting unilateral connection upgrade', relayedConnection.remotePeer)\n    }\n\n    // no public addresses or failed to dial public addresses\n    return false\n  }\n\n  /**\n   * Perform the connection upgrade as A\n   *\n   * @see https://github.com/libp2p/specs/blob/master/relay/DCUtR.md#the-protocol\n   */\n  async handleIncomingUpgrade (stream: Stream, relayedConnection: Connection): Promise<void> {\n    const options = {\n      signal: AbortSignal.timeout(this.timeout)\n    }\n\n    try {\n      const pb = pbStream(stream, {\n        maxDataLength: MAX_DCUTR_MESSAGE_SIZE\n      }).pb(HolePunch)\n\n      this.log('A receiving connect')\n      // 3. Upon receiving the Connect, A responds back with a Connect message\n      // containing its observed (and possibly predicted) addresses.\n      const connect = await pb.read(options)\n\n      if (connect.type !== HolePunch.Type.CONNECT) {\n        this.log('B sent wrong message type')\n        throw new CodeError('DCUtR message type was incorrect', ERR_INVALID_MESSAGE)\n      }\n\n      if (connect.observedAddresses.length === 0) {\n        this.log('B sent no multiaddrs')\n        throw new CodeError('DCUtR connect message had no multiaddrs', ERR_INVALID_MESSAGE)\n      }\n\n      const multiaddrs = this.getDialableMultiaddrs(connect.observedAddresses)\n\n      if (multiaddrs.length === 0) {\n        this.log('B had no dialable multiaddrs')\n        throw new CodeError('DCUtR connect message had no dialable multiaddrs', ERR_INVALID_MESSAGE)\n      }\n\n      this.log('A sending connect')\n      await pb.write({\n        type: HolePunch.Type.CONNECT,\n        observedAddresses: this.addressManager.getAddresses().map(ma => ma.bytes)\n      })\n\n      this.log('A receiving sync')\n      const sync = await pb.read(options)\n\n      if (sync.type !== HolePunch.Type.SYNC) {\n        throw new CodeError('DCUtR message type was incorrect', ERR_INVALID_MESSAGE)\n      }\n\n      // TODO: when we have a QUIC transport, the dial step is different - for\n      // now we only have tcp support\n      // https://github.com/libp2p/specs/blob/master/relay/DCUtR.md#the-protocol\n\n      // Upon receiving the Sync, A immediately dials the address to B\n      this.log('A dialing', multiaddrs)\n      const connection = await this.connectionManager.openConnection(multiaddrs, {\n        signal: options.signal,\n        priority: DCUTR_DIAL_PRIORITY,\n        force: true\n      })\n\n      this.log('DCUtR to %p succeeded via %a, closing relayed connection', relayedConnection.remotePeer, connection.remoteAddr)\n      await relayedConnection.close(options)\n    } catch (err: any) {\n      this.log.error('incoming DCUtR from %p failed', relayedConnection.remotePeer, err)\n      stream.abort(err)\n    } finally {\n      await stream.close(options)\n    }\n  }\n\n  /**\n   * Takes the `addr` and converts it to a Multiaddr if possible\n   */\n  getDialableMultiaddrs (addrs: Array<Uint8Array | string | null | undefined>): Multiaddr[] {\n    const output = []\n\n    for (const addr of addrs) {\n      if (addr == null || addr.length === 0) {\n        continue\n      }\n\n      try {\n        const ma = multiaddr(addr)\n\n        if (!isPublicAndDialable(ma, this.transportManager)) {\n          continue\n        }\n\n        output.push(ma)\n      } catch {}\n    }\n\n    return output\n  }\n}\n", "/**\n * @packageDocumentation\n *\n * Direct Connection Upgrade through Relay (DCUtR) is a protocol that allows two\n * nodes to connect to each other who would otherwise be prevented doing so due\n * to being behind NATed connections or firewalls.\n *\n * The protocol involves making a relayed connection between the two peers and\n * using the relay to synchronise connection timings so that they dial each other\n * at precisely the same moment.\n *\n * @example\n *\n * ```TypeScript\n * import { createLibp2p } from 'libp2p'\n * import { circuitRelayTransport } from '@libp2p/circuit-relay-v2'\n * import { tcp } from '@libp2p/tcp'\n * import { identify } from '@libp2p/identify'\n * import { dcutr } from '@libp2p/dcutr'\n * import { multiaddr } from '@multiformats/multiaddr'\n *\n * const node = await createLibp2p({\n *   transports: [\n *     circuitRelayTransport(),\n *     tcp()\n *   ],\n *   services: {\n *     identify: identify(),\n *     dcutr: dcutr()\n *   }\n * })\n *\n * // QmTarget is a peer that is behind a NAT, supports TCP and has a relay\n * // reservation\n * const ma = multiaddr('/ip4/.../p2p/QmRelay/p2p-circuit/p2p/QmTarget')\n * await node.dial(ma)\n *\n * // after a while the connection should automatically get upgraded to a\n * // direct connection (e.g. non-transient)\n * while (true) {\n *   const connections = node.getConnections()\n *\n *   if (connections.find(conn => conn.transient === false)) {\n *     console.info('have direct connection')\n *     break\n *   } else {\n *     console.info('have relayed connection')\n *\n *     // wait a few seconds to see if it's succeeded yet\n *     await new Promise<void>((resolve) => {\n *       setTimeout(() => resolve(), 5000)\n *     })\n *   }\n * }\n * ```\n */\n\nimport { DefaultDCUtRService } from './dcutr.js'\nimport type { ComponentLogger, PeerStore } from '@libp2p/interface'\nimport type { AddressManager, ConnectionManager, Registrar, TransportManager } from '@libp2p/interface-internal'\n\nexport interface DCUtRServiceInit {\n  /**\n   * How long we should wait for the connection upgrade to complete (default: 5s)\n   */\n  timeout?: number\n\n  /**\n   * How many times to retry the connection upgrade (default: 3)\n   */\n  retries?: number\n\n  /**\n   * How many simultaneous inbound DCUtR protocol streams to allow on each\n   * connection (default: 1)\n   */\n  maxInboundStreams?: number\n\n  /**\n   * How many simultaneous outbound DCUtR protocol streams to allow on each\n   * connection (default: 1)\n   */\n  maxOutboundStreams?: number\n}\n\nexport interface DCUtRServiceComponents {\n  peerStore: PeerStore\n  connectionManager: ConnectionManager\n  registrar: Registrar\n  addressManager: AddressManager\n  transportManager: TransportManager\n  logger: ComponentLogger\n}\n\n/**\n * The DCUtR protocol\n */\nexport const multicodec = '/libp2p/dcutr'\n\nexport function dcutr (init: DCUtRServiceInit = {}): (components: DCUtRServiceComponents) => unknown {\n  return (components) => new DefaultDCUtRService(components, init)\n}\n"],
  "mappings": "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",
  "names": ["HolePunch", "Type", "__TypeValues"]
}
