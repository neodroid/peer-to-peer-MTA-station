{
  "version": 3,
  "sources": ["../../@chainsafe/libp2p-yamux/src/constants.ts", "../../@chainsafe/libp2p-yamux/src/config.ts", "../../@chainsafe/libp2p-yamux/src/frame.ts", "../../@chainsafe/libp2p-yamux/src/decode.ts", "../../@chainsafe/libp2p-yamux/src/encode.ts", "../../it-foreach/src/index.ts", "../../@chainsafe/libp2p-yamux/src/stream.ts", "../../@chainsafe/libp2p-yamux/src/muxer.ts", "../../@chainsafe/libp2p-yamux/src/index.ts"],
  "sourcesContent": ["// Protocol violation errors\n\nexport const ERR_INVALID_FRAME = 'ERR_INVALID_FRAME'\nexport const ERR_UNREQUESTED_PING = 'ERR_UNREQUESTED_PING'\nexport const ERR_NOT_MATCHING_PING = 'ERR_NOT_MATCHING_PING'\nexport const ERR_STREAM_ALREADY_EXISTS = 'ERR_STREAM_ALREADY_EXISTS'\nexport const ERR_DECODE_INVALID_VERSION = 'ERR_DECODE_INVALID_VERSION'\nexport const ERR_BOTH_CLIENTS = 'ERR_BOTH_CLIENTS'\nexport const ERR_RECV_WINDOW_EXCEEDED = 'ERR_RECV_WINDOW_EXCEEDED'\n\nexport const PROTOCOL_ERRORS = new Set([\n  ERR_INVALID_FRAME,\n  ERR_UNREQUESTED_PING,\n  ERR_NOT_MATCHING_PING,\n  ERR_STREAM_ALREADY_EXISTS,\n  ERR_DECODE_INVALID_VERSION,\n  ERR_BOTH_CLIENTS,\n  ERR_RECV_WINDOW_EXCEEDED\n])\n\n// local errors\n\nexport const ERR_INVALID_CONFIG = 'ERR_INVALID_CONFIG'\nexport const ERR_MUXER_LOCAL_CLOSED = 'ERR_MUXER_LOCAL_CLOSED'\nexport const ERR_MUXER_REMOTE_CLOSED = 'ERR_MUXER_REMOTE_CLOSED'\nexport const ERR_STREAM_RESET = 'ERR_STREAM_RESET'\nexport const ERR_STREAM_ABORT = 'ERR_STREAM_ABORT'\nexport const ERR_MAX_OUTBOUND_STREAMS_EXCEEDED = 'ERROR_MAX_OUTBOUND_STREAMS_EXCEEDED'\nexport const ERR_DECODE_IN_PROGRESS = 'ERR_DECODE_IN_PROGRESS'\n\n/**\n * INITIAL_STREAM_WINDOW is the initial stream window size.\n *\n * Not an implementation choice, this is defined in the specification\n */\nexport const INITIAL_STREAM_WINDOW = 256 * 1024\n\n/**\n * Default max stream window\n */\nexport const MAX_STREAM_WINDOW = 16 * 1024 * 1024\n", "import { CodeError } from '@libp2p/interface'\nimport { ERR_INVALID_CONFIG, INITIAL_STREAM_WINDOW, MAX_STREAM_WINDOW } from './constants.js'\n\n// TOOD use config items or delete them\nexport interface Config {\n  /**\n   * Used to do periodic keep alive messages using a ping.\n   */\n  enableKeepAlive: boolean\n\n  /**\n   * How often to perform the keep alive\n   *\n   * measured in milliseconds\n   */\n  keepAliveInterval: number\n\n  /**\n   * Maximum number of concurrent inbound streams that we accept.\n   * If the peer tries to open more streams, those will be reset immediately.\n   */\n  maxInboundStreams: number\n\n  /**\n   * Maximum number of concurrent outbound streams that we accept.\n   * If the application tries to open more streams, the call to `newStream` will throw\n   */\n  maxOutboundStreams: number\n\n  /**\n   * Used to control the initial window size that we allow for a stream.\n   *\n   * measured in bytes\n   */\n  initialStreamWindowSize: number\n\n  /**\n   * Used to control the maximum window size that we allow for a stream.\n   */\n  maxStreamWindowSize: number\n\n  /**\n   * Maximum size of a message that we'll send on a stream.\n   * This ensures that a single stream doesn't hog a connection.\n   */\n  maxMessageSize: number\n}\n\nexport const defaultConfig: Config = {\n  enableKeepAlive: true,\n  keepAliveInterval: 30_000,\n  maxInboundStreams: 1_000,\n  maxOutboundStreams: 1_000,\n  initialStreamWindowSize: INITIAL_STREAM_WINDOW,\n  maxStreamWindowSize: MAX_STREAM_WINDOW,\n  maxMessageSize: 64 * 1024\n}\n\nexport function verifyConfig (config: Config): void {\n  if (config.keepAliveInterval <= 0) {\n    throw new CodeError('keep-alive interval must be positive', ERR_INVALID_CONFIG)\n  }\n  if (config.maxInboundStreams < 0) {\n    throw new CodeError('max inbound streams must be larger or equal 0', ERR_INVALID_CONFIG)\n  }\n  if (config.maxOutboundStreams < 0) {\n    throw new CodeError('max outbound streams must be larger or equal 0', ERR_INVALID_CONFIG)\n  }\n  if (config.initialStreamWindowSize < INITIAL_STREAM_WINDOW) {\n    throw new CodeError('InitialStreamWindowSize must be larger or equal 256 kB', ERR_INVALID_CONFIG)\n  }\n  if (config.maxStreamWindowSize < config.initialStreamWindowSize) {\n    throw new CodeError('MaxStreamWindowSize must be larger than the InitialStreamWindowSize', ERR_INVALID_CONFIG)\n  }\n  if (config.maxStreamWindowSize > 2 ** 32 - 1) {\n    throw new CodeError('MaxStreamWindowSize must be less than equal MAX_UINT32', ERR_INVALID_CONFIG)\n  }\n  if (config.maxMessageSize < 1024) {\n    throw new CodeError('MaxMessageSize must be greater than a kilobyte', ERR_INVALID_CONFIG)\n  }\n}\n", "export enum FrameType {\n  /** Used to transmit data. May transmit zero length payloads depending on the flags. */\n  Data = 0x0,\n  /** Used to updated the senders receive window size. This is used to implement per-session flow control. */\n  WindowUpdate = 0x1,\n  /** Used to measure RTT. It can also be used to heart-beat and do keep-alives over TCP. */\n  Ping = 0x2,\n  /** Used to close a session. */\n  GoAway = 0x3,\n}\n\nexport enum Flag {\n  /** Signals the start of a new stream. May be sent with a data or window update message. Also sent with a ping to indicate outbound. */\n  SYN = 0x1,\n  /** Acknowledges the start of a new stream. May be sent with a data or window update message. Also sent with a ping to indicate response. */\n  ACK = 0x2,\n  /** Performs a half-close of a stream. May be sent with a data message or window update. */\n  FIN = 0x4,\n  /** Reset a stream immediately. May be sent with a data or window update message. */\n  RST = 0x8,\n}\n\nconst flagCodes = Object.values(Flag).filter((x) => typeof x !== 'string') as Flag[]\n\nexport const YAMUX_VERSION = 0\n\nexport enum GoAwayCode {\n  NormalTermination = 0x0,\n  ProtocolError = 0x1,\n  InternalError = 0x2,\n}\n\nexport const HEADER_LENGTH = 12\n\nexport interface FrameHeader {\n  /**\n   * The version field is used for future backward compatibility.\n   * At the current time, the field is always set to 0, to indicate the initial version.\n   */\n  version?: number\n  /** The type field is used to switch the frame message type. */\n  type: FrameType\n  /** The flags field is used to provide additional information related to the message type. */\n  flag: number\n  /**\n   * The StreamID field is used to identify the logical stream the frame is addressing.\n   * The client side should use odd ID's, and the server even.\n   * This prevents any collisions. Additionally, the 0 ID is reserved to represent the session.\n   */\n  streamID: number\n  /**\n   * The meaning of the length field depends on the message type:\n   * * Data - provides the length of bytes following the header\n   * * Window update - provides a delta update to the window size\n   * * Ping - Contains an opaque value, echoed back\n   * * Go Away - Contains an error code\n   */\n  length: number\n}\n\nexport function stringifyHeader (header: FrameHeader): string {\n  const flags = flagCodes.filter(f => (header.flag & f) === f).map(f => Flag[f]).join('|')\n  return `streamID=${header.streamID} type=${FrameType[header.type]} flag=${flags} length=${header.length}`\n}\n", "import { CodeError } from '@libp2p/interface'\nimport { Uint8ArrayList } from 'uint8arraylist'\nimport { ERR_DECODE_INVALID_VERSION, ERR_DECODE_IN_PROGRESS } from './constants.js'\nimport { type FrameHeader, FrameType, HEADER_LENGTH, YAMUX_VERSION } from './frame.js'\nimport type { Source } from 'it-stream-types'\n\n// used to bitshift in decoding\n// native bitshift can overflow into a negative number, so we bitshift by multiplying by a power of 2\nconst twoPow24 = 2 ** 24\n\n/**\n * Decode a header from the front of a buffer\n *\n * @param data - Assumed to have enough bytes for a header\n */\nexport function decodeHeader (data: Uint8Array): FrameHeader {\n  if (data[0] !== YAMUX_VERSION) {\n    throw new CodeError('Invalid frame version', ERR_DECODE_INVALID_VERSION)\n  }\n  return {\n    type: data[1],\n    flag: (data[2] << 8) + data[3],\n    streamID: (data[4] * twoPow24) + (data[5] << 16) + (data[6] << 8) + data[7],\n    length: (data[8] * twoPow24) + (data[9] << 16) + (data[10] << 8) + data[11]\n  }\n}\n\n/**\n * Decodes yamux frames from a source\n */\nexport class Decoder {\n  private readonly source: Source<Uint8Array | Uint8ArrayList>\n  /** Buffer for in-progress frames */\n  private readonly buffer: Uint8ArrayList\n  /** Used to sanity check against decoding while in an inconsistent state */\n  private frameInProgress: boolean\n\n  constructor (source: Source<Uint8Array | Uint8ArrayList>) {\n    // Normally, when entering a for-await loop with an iterable/async iterable, the only ways to exit the loop are:\n    // 1. exhaust the iterable\n    // 2. throw an error - slow, undesirable if there's not actually an error\n    // 3. break or return - calls the iterable's `return` method, finalizing the iterable, no more iteration possible\n    //\n    // In this case, we want to enter (and exit) a for-await loop per chunked data frame and continue processing the iterable.\n    // To do this, we strip the `return` method from the iterator and can now `break` early and continue iterating.\n    // Exiting the main for-await is still possible via 1. and 2.\n    this.source = returnlessSource(source)\n    this.buffer = new Uint8ArrayList()\n    this.frameInProgress = false\n  }\n\n  /**\n   * Emits frames from the decoder source.\n   *\n   * Note: If `readData` is emitted, it _must_ be called before the next iteration\n   * Otherwise an error is thrown\n   */\n  async * emitFrames (): AsyncGenerator<{ header: FrameHeader, readData?(): Promise<Uint8ArrayList> }> {\n    for await (const chunk of this.source) {\n      this.buffer.append(chunk)\n\n      // Loop to consume as many bytes from the buffer as possible\n      // Eg: when a single chunk contains several frames\n      while (true) {\n        const header = this.readHeader()\n        if (header === undefined) {\n          break\n        }\n\n        const { type, length } = header\n        if (type === FrameType.Data) {\n          // This is a data frame, the frame body must still be read\n          // `readData` must be called before the next iteration here\n          this.frameInProgress = true\n          yield {\n            header,\n            readData: this.readBytes.bind(this, length)\n          }\n        } else {\n          yield { header }\n        }\n      }\n    }\n  }\n\n  private readHeader (): FrameHeader | undefined {\n    // Sanity check to ensure a header isn't read when another frame is partially decoded\n    // In practice this shouldn't happen\n    if (this.frameInProgress) {\n      throw new CodeError('decoding frame already in progress', ERR_DECODE_IN_PROGRESS)\n    }\n\n    if (this.buffer.length < HEADER_LENGTH) {\n      // not enough data yet\n      return\n    }\n\n    const header = decodeHeader(this.buffer.subarray(0, HEADER_LENGTH))\n    this.buffer.consume(HEADER_LENGTH)\n    return header\n  }\n\n  private async readBytes (length: number): Promise<Uint8ArrayList> {\n    if (this.buffer.length < length) {\n      for await (const chunk of this.source) {\n        this.buffer.append(chunk)\n\n        if (this.buffer.length >= length) {\n          // see note above, the iterator is not `return`ed here\n          break\n        }\n      }\n    }\n\n    const out = this.buffer.sublist(0, length)\n    this.buffer.consume(length)\n\n    // The next frame can now be decoded\n    this.frameInProgress = false\n\n    return out\n  }\n}\n\n/**\n * Strip the `return` method from a `Source`\n */\nexport function returnlessSource<T> (source: Source<T>): Source<T> {\n  if ((source as Iterable<T>)[Symbol.iterator] !== undefined) {\n    const iterator = (source as Iterable<T>)[Symbol.iterator]()\n    iterator.return = undefined\n    return {\n      [Symbol.iterator] () { return iterator }\n    }\n  } else if ((source as AsyncIterable<T>)[Symbol.asyncIterator] !== undefined) {\n    const iterator = (source as AsyncIterable<T>)[Symbol.asyncIterator]()\n    iterator.return = undefined\n    return {\n      [Symbol.asyncIterator] () { return iterator }\n    }\n  } else {\n    throw new Error('a source must be either an iterable or an async iterable')\n  }\n}\n", "import { HEADER_LENGTH } from './frame.js'\nimport type { FrameHeader } from './frame.js'\n\nexport function encodeHeader (header: FrameHeader): Uint8Array {\n  const frame = new Uint8Array(HEADER_LENGTH)\n\n  // always assume version 0\n  // frameView.setUint8(0, header.version)\n\n  frame[1] = header.type\n\n  frame[2] = header.flag >>> 8\n  frame[3] = header.flag\n\n  frame[4] = header.streamID >>> 24\n  frame[5] = header.streamID >>> 16\n  frame[6] = header.streamID >>> 8\n  frame[7] = header.streamID\n\n  frame[8] = header.length >>> 24\n  frame[9] = header.length >>> 16\n  frame[10] = header.length >>> 8\n  frame[11] = header.length\n\n  return frame\n}\n", "/**\n * @packageDocumentation\n *\n * Calls a function for each value in an (async)iterable.\n *\n * The function can be sync or async.\n *\n * Async functions can be awaited on so may slow down processing of the (async)iterable.\n *\n * @example\n *\n * ```javascript\n * import each from 'it-foreach'\n * import drain from 'it-drain'\n *\n * // This can also be an iterator, generator, etc\n * const values = [0, 1, 2, 3, 4]\n *\n * // prints [0, 0], [1, 1], [2, 2], [3, 3], [4, 4]\n * const arr = drain(\n *   each(values, console.info)\n * )\n * ```\n *\n * Async sources and callbacks must be awaited:\n *\n * ```javascript\n * import each from 'it-foreach'\n * import drain from 'it-drain'\n *\n * const values = async function * () {\n *   yield * [0, 1, 2, 3, 4]\n * }\n *\n * // prints [0, 0], [1, 1], [2, 2], [3, 3], [4, 4]\n * const arr = await drain(\n *   each(values(), console.info)\n * )\n * ```\n */\n\nimport peek from 'it-peekable'\n\nfunction isAsyncIterable <T> (thing: any): thing is AsyncIterable<T> {\n  return thing[Symbol.asyncIterator] != null\n}\n\nfunction isPromise <T = unknown> (thing: any): thing is Promise<T> {\n  return thing?.then != null\n}\n\n/**\n * Invokes the passed function for each item in an iterable\n */\nfunction forEach <T> (source: Iterable<T>, fn: (thing: T, index: number) => Promise<void>): AsyncGenerator<T, void, undefined>\nfunction forEach <T> (source: Iterable<T>, fn: (thing: T, index: number) => void): Generator<T, void, undefined>\nfunction forEach <T> (source: Iterable<T> | AsyncIterable<T>, fn: (thing: T, index: number) => void | Promise<void>): AsyncGenerator<T, void, undefined>\nfunction forEach <T> (source: Iterable<T> | AsyncIterable<T>, fn: (thing: T, index: number) => void | Promise<void>): AsyncGenerator<T, void, undefined> | Generator<T, void, undefined> {\n  let index = 0\n\n  if (isAsyncIterable(source)) {\n    return (async function * () {\n      for await (const val of source) {\n        const res = fn(val, index++)\n\n        if (isPromise(res)) {\n          await res\n        }\n\n        yield val\n      }\n    })()\n  }\n\n  // if fn function returns a promise we have to return an async generator\n  const peekable = peek(source)\n  const { value, done } = peekable.next()\n\n  if (done === true) {\n    return (function * () {}())\n  }\n\n  const res = fn(value, index++)\n\n  if (typeof res?.then === 'function') {\n    return (async function * () {\n      yield value\n\n      for await (const val of peekable) {\n        const res = fn(val, index++)\n\n        if (isPromise(res)) {\n          await res\n        }\n\n        yield val\n      }\n    })()\n  }\n\n  const func = fn as (val: T, index: number) => void\n\n  return (function * () {\n    yield value\n\n    for (const val of peekable) {\n      func(val, index++)\n      yield val\n    }\n  })()\n}\n\nexport default forEach\n", "import { CodeError } from '@libp2p/interface'\nimport { AbstractStream, type AbstractStreamInit } from '@libp2p/utils/abstract-stream'\nimport each from 'it-foreach'\nimport { ERR_RECV_WINDOW_EXCEEDED, ERR_STREAM_ABORT, INITIAL_STREAM_WINDOW } from './constants.js'\nimport { Flag, type FrameHeader, FrameType, HEADER_LENGTH } from './frame.js'\nimport type { Config } from './config.js'\nimport type { AbortOptions } from '@libp2p/interface'\nimport type { Uint8ArrayList } from 'uint8arraylist'\n\nexport enum StreamState {\n  Init,\n  SYNSent,\n  SYNReceived,\n  Established,\n  Finished,\n}\n\nexport interface YamuxStreamInit extends AbstractStreamInit {\n  name?: string\n  sendFrame(header: FrameHeader, body?: Uint8ArrayList): void\n  getRTT(): number\n  config: Config\n  state: StreamState\n}\n\n/** YamuxStream is used to represent a logical stream within a session */\nexport class YamuxStream extends AbstractStream {\n  name?: string\n  state: StreamState\n\n  private readonly config: Config\n  private readonly _id: number\n\n  /** The number of available bytes to send */\n  private sendWindowCapacity: number\n  /** Callback to notify that the sendWindowCapacity has been updated */\n  private sendWindowCapacityUpdate?: () => void\n\n  /** The number of bytes available to receive in a full window */\n  private recvWindow: number\n  /** The number of available bytes to receive */\n  private recvWindowCapacity: number\n\n  /**\n   * An 'epoch' is the time it takes to process and read data\n   *\n   * Used in conjunction with RTT to determine whether to increase the recvWindow\n   */\n  private epochStart: number\n  private readonly getRTT: () => number\n\n  private readonly sendFrame: (header: FrameHeader, body?: Uint8ArrayList) => void\n\n  constructor (init: YamuxStreamInit) {\n    super({\n      ...init,\n      onEnd: (err?: Error) => {\n        this.state = StreamState.Finished\n        init.onEnd?.(err)\n      }\n    })\n\n    this.config = init.config\n    this._id = parseInt(init.id, 10)\n    this.name = init.name\n    this.state = init.state\n    this.sendWindowCapacity = INITIAL_STREAM_WINDOW\n    this.recvWindow = this.config.initialStreamWindowSize\n    this.recvWindowCapacity = this.recvWindow\n    this.epochStart = Date.now()\n    this.getRTT = init.getRTT\n\n    this.sendFrame = init.sendFrame\n\n    this.source = each(this.source, () => {\n      this.sendWindowUpdate()\n    })\n  }\n\n  /**\n   * Send a message to the remote muxer informing them a new stream is being\n   * opened.\n   *\n   * This is a noop for Yamux because the first window update is sent when\n   * .newStream is called on the muxer which opens the stream on the remote.\n   */\n  async sendNewStream (): Promise<void> {\n\n  }\n\n  /**\n   * Send a data message to the remote muxer\n   */\n  async sendData (buf: Uint8ArrayList, options: AbortOptions = {}): Promise<void> {\n    buf = buf.sublist()\n\n    // send in chunks, waiting for window updates\n    while (buf.byteLength !== 0) {\n      // wait for the send window to refill\n      if (this.sendWindowCapacity === 0) {\n        this.log?.trace('wait for send window capacity, status %s', this.status)\n        await this.waitForSendWindowCapacity(options)\n\n        // check we didn't close while waiting for send window capacity\n        if (this.status === 'closed' || this.status === 'aborted' || this.status === 'reset') {\n          this.log?.trace('%s while waiting for send window capacity', this.status)\n          return\n        }\n      }\n\n      // send as much as we can\n      const toSend = Math.min(this.sendWindowCapacity, this.config.maxMessageSize - HEADER_LENGTH, buf.length)\n      const flags = this.getSendFlags()\n\n      this.sendFrame({\n        type: FrameType.Data,\n        flag: flags,\n        streamID: this._id,\n        length: toSend\n      }, buf.sublist(0, toSend))\n\n      this.sendWindowCapacity -= toSend\n\n      buf.consume(toSend)\n    }\n  }\n\n  /**\n   * Send a reset message to the remote muxer\n   */\n  async sendReset (): Promise<void> {\n    this.sendFrame({\n      type: FrameType.WindowUpdate,\n      flag: Flag.RST,\n      streamID: this._id,\n      length: 0\n    })\n  }\n\n  /**\n   * Send a message to the remote muxer, informing them no more data messages\n   * will be sent by this end of the stream\n   */\n  async sendCloseWrite (): Promise<void> {\n    const flags = this.getSendFlags() | Flag.FIN\n    this.sendFrame({\n      type: FrameType.WindowUpdate,\n      flag: flags,\n      streamID: this._id,\n      length: 0\n    })\n  }\n\n  /**\n   * Send a message to the remote muxer, informing them no more data messages\n   * will be read by this end of the stream\n   */\n  async sendCloseRead (): Promise<void> {\n\n  }\n\n  /**\n   * Wait for the send window to be non-zero\n   *\n   * Will throw with ERR_STREAM_ABORT if the stream gets aborted\n   */\n  async waitForSendWindowCapacity (options: AbortOptions = {}): Promise<void> {\n    if (this.sendWindowCapacity > 0) {\n      return\n    }\n\n    let resolve: () => void\n    let reject: (err: Error) => void\n    const abort = (): void => {\n      if (this.status === 'open' || this.status === 'closing') {\n        reject(new CodeError('stream aborted', ERR_STREAM_ABORT))\n      } else {\n        // the stream was closed already, ignore the failure to send\n        resolve()\n      }\n    }\n    options.signal?.addEventListener('abort', abort)\n\n    try {\n      await new Promise<void>((_resolve, _reject) => {\n        this.sendWindowCapacityUpdate = () => {\n          _resolve()\n        }\n        reject = _reject\n        resolve = _resolve\n      })\n    } finally {\n      options.signal?.removeEventListener('abort', abort)\n    }\n  }\n\n  /**\n   * handleWindowUpdate is called when the stream receives a window update frame\n   */\n  handleWindowUpdate (header: FrameHeader): void {\n    this.log?.trace('stream received window update id=%s', this._id)\n    this.processFlags(header.flag)\n\n    // increase send window\n    const available = this.sendWindowCapacity\n    this.sendWindowCapacity += header.length\n    // if the update increments a 0 availability, notify the stream that sending can resume\n    if (available === 0 && header.length > 0) {\n      this.sendWindowCapacityUpdate?.()\n    }\n  }\n\n  /**\n   * handleData is called when the stream receives a data frame\n   */\n  async handleData (header: FrameHeader, readData: () => Promise<Uint8ArrayList>): Promise<void> {\n    this.log?.trace('stream received data id=%s', this._id)\n    this.processFlags(header.flag)\n\n    // check that our recv window is not exceeded\n    if (this.recvWindowCapacity < header.length) {\n      throw new CodeError('receive window exceeded', ERR_RECV_WINDOW_EXCEEDED, { available: this.recvWindowCapacity, recv: header.length })\n    }\n\n    const data = await readData()\n    this.recvWindowCapacity -= header.length\n\n    this.sourcePush(data)\n  }\n\n  /**\n   * processFlags is used to update the state of the stream based on set flags, if any.\n   */\n  private processFlags (flags: number): void {\n    if ((flags & Flag.ACK) === Flag.ACK) {\n      if (this.state === StreamState.SYNSent) {\n        this.state = StreamState.Established\n      }\n    }\n    if ((flags & Flag.FIN) === Flag.FIN) {\n      this.remoteCloseWrite()\n    }\n    if ((flags & Flag.RST) === Flag.RST) {\n      this.reset()\n    }\n  }\n\n  /**\n   * getSendFlags determines any flags that are appropriate\n   * based on the current stream state.\n   *\n   * The state is updated as a side-effect.\n   */\n  private getSendFlags (): number {\n    switch (this.state) {\n      case StreamState.Init:\n        this.state = StreamState.SYNSent\n        return Flag.SYN\n      case StreamState.SYNReceived:\n        this.state = StreamState.Established\n        return Flag.ACK\n      default:\n        return 0\n    }\n  }\n\n  /**\n   * potentially sends a window update enabling further writes to take place.\n   */\n  sendWindowUpdate (): void {\n    // determine the flags if any\n    const flags = this.getSendFlags()\n\n    // If the stream has already been established\n    // and we've processed data within the time it takes for 4 round trips\n    // then we (up to) double the recvWindow\n    const now = Date.now()\n    const rtt = this.getRTT()\n    if (flags === 0 && rtt > -1 && now - this.epochStart < rtt * 4) {\n      // we've already validated that maxStreamWindowSize can't be more than MAX_UINT32\n      this.recvWindow = Math.min(this.recvWindow * 2, this.config.maxStreamWindowSize)\n    }\n\n    if (this.recvWindowCapacity >= this.recvWindow && flags === 0) {\n      // a window update isn't needed\n      return\n    }\n\n    // update the receive window\n    const delta = this.recvWindow - this.recvWindowCapacity\n    this.recvWindowCapacity = this.recvWindow\n\n    // update the epoch start\n    this.epochStart = now\n\n    // send window update\n    this.sendFrame({\n      type: FrameType.WindowUpdate,\n      flag: flags,\n      streamID: this._id,\n      length: delta\n    })\n  }\n}\n", "import { CodeError, setMaxListeners } from '@libp2p/interface'\nimport { getIterator } from 'get-iterator'\nimport { pushable, type Pushable } from 'it-pushable'\nimport { Uint8ArrayList } from 'uint8arraylist'\nimport { type Config, defaultConfig, verifyConfig } from './config.js'\nimport { ERR_BOTH_CLIENTS, ERR_INVALID_FRAME, ERR_MAX_OUTBOUND_STREAMS_EXCEEDED, ERR_MUXER_LOCAL_CLOSED, ERR_MUXER_REMOTE_CLOSED, ERR_NOT_MATCHING_PING, ERR_STREAM_ALREADY_EXISTS, ERR_UNREQUESTED_PING, PROTOCOL_ERRORS } from './constants.js'\nimport { Decoder } from './decode.js'\nimport { encodeHeader } from './encode.js'\nimport { Flag, type FrameHeader, FrameType, GoAwayCode } from './frame.js'\nimport { StreamState, YamuxStream } from './stream.js'\nimport type { YamuxMuxerComponents } from './index.js'\nimport type { AbortOptions, ComponentLogger, Logger, Stream, StreamMuxer, StreamMuxerFactory, StreamMuxerInit } from '@libp2p/interface'\nimport type { Sink, Source } from 'it-stream-types'\n\nconst YAMUX_PROTOCOL_ID = '/yamux/1.0.0'\nconst CLOSE_TIMEOUT = 500\n\nexport interface YamuxMuxerInit extends StreamMuxerInit, Partial<Config> {\n}\n\nexport class Yamux implements StreamMuxerFactory {\n  protocol = YAMUX_PROTOCOL_ID\n  private readonly _components: YamuxMuxerComponents\n  private readonly _init: YamuxMuxerInit\n\n  constructor (components: YamuxMuxerComponents, init: YamuxMuxerInit = {}) {\n    this._components = components\n    this._init = init\n  }\n\n  createStreamMuxer (init?: YamuxMuxerInit): YamuxMuxer {\n    return new YamuxMuxer(this._components, {\n      ...this._init,\n      ...init\n    })\n  }\n}\n\nexport interface CloseOptions extends AbortOptions {\n  reason?: GoAwayCode\n}\n\nexport class YamuxMuxer implements StreamMuxer {\n  protocol = YAMUX_PROTOCOL_ID\n  source: Pushable<Uint8ArrayList | Uint8Array>\n  sink: Sink<Source<Uint8ArrayList | Uint8Array>, Promise<void>>\n\n  private readonly config: Config\n  private readonly log?: Logger\n  private readonly logger: ComponentLogger\n\n  /** Used to close the muxer from either the sink or source */\n  private readonly closeController: AbortController\n\n  /** The next stream id to be used when initiating a new stream */\n  private nextStreamID: number\n  /** Primary stream mapping, streamID => stream */\n  private readonly _streams: Map<number, YamuxStream>\n\n  /** The next ping id to be used when pinging */\n  private nextPingID: number\n  /** Tracking info for the currently active ping */\n  private activePing?: { id: number, promise: Promise<void>, resolve(): void }\n  /** Round trip time */\n  private rtt: number\n\n  /** True if client, false if server */\n  private readonly client: boolean\n\n  private localGoAway?: GoAwayCode\n  private remoteGoAway?: GoAwayCode\n\n  /** Number of tracked inbound streams */\n  private numInboundStreams: number\n  /** Number of tracked outbound streams */\n  private numOutboundStreams: number\n\n  private readonly onIncomingStream?: (stream: Stream) => void\n  private readonly onStreamEnd?: (stream: Stream) => void\n\n  constructor (components: YamuxMuxerComponents, init: YamuxMuxerInit) {\n    this.client = init.direction === 'outbound'\n    this.config = { ...defaultConfig, ...init }\n    this.logger = components.logger\n    this.log = this.logger.forComponent('libp2p:yamux')\n    verifyConfig(this.config)\n\n    this.closeController = new AbortController()\n    setMaxListeners(Infinity, this.closeController.signal)\n\n    this.onIncomingStream = init.onIncomingStream\n    this.onStreamEnd = init.onStreamEnd\n\n    this._streams = new Map()\n\n    this.source = pushable({\n      onEnd: (): void => {\n        this.log?.trace('muxer source ended')\n\n        this._streams.forEach(stream => {\n          stream.destroy()\n        })\n      }\n    })\n\n    this.sink = async (source: Source<Uint8ArrayList | Uint8Array>): Promise<void> => {\n      const shutDownListener = (): void => {\n        const iterator = getIterator(source)\n\n        if (iterator.return != null) {\n          const res = iterator.return()\n\n          if (isPromise(res)) {\n            res.catch(err => {\n              this.log?.('could not cause sink source to return', err)\n            })\n          }\n        }\n      }\n\n      let reason, error\n      try {\n        const decoder = new Decoder(source)\n\n        try {\n          this.closeController.signal.addEventListener('abort', shutDownListener)\n\n          for await (const frame of decoder.emitFrames()) {\n            await this.handleFrame(frame.header, frame.readData)\n          }\n        } finally {\n          this.closeController.signal.removeEventListener('abort', shutDownListener)\n        }\n\n        reason = GoAwayCode.NormalTermination\n      } catch (err: unknown) {\n        // either a protocol or internal error\n        const errCode = (err as { code: string }).code\n        if (PROTOCOL_ERRORS.has(errCode)) {\n          this.log?.error('protocol error in sink', err)\n          reason = GoAwayCode.ProtocolError\n        } else {\n          this.log?.error('internal error in sink', err)\n          reason = GoAwayCode.InternalError\n        }\n\n        error = err as Error\n      }\n\n      this.log?.trace('muxer sink ended')\n\n      if (error != null) {\n        this.abort(error, reason)\n      } else {\n        await this.close({ reason })\n      }\n    }\n\n    this.numInboundStreams = 0\n    this.numOutboundStreams = 0\n\n    // client uses odd streamIDs, server uses even streamIDs\n    this.nextStreamID = this.client ? 1 : 2\n\n    this.nextPingID = 0\n    this.rtt = -1\n\n    this.log?.trace('muxer created')\n\n    if (this.config.enableKeepAlive) {\n      this.keepAliveLoop().catch(e => this.log?.error('keepalive error: %s', e))\n    }\n\n    // send an initial ping to establish RTT\n    this.ping().catch(e => this.log?.error('ping error: %s', e))\n  }\n\n  get streams (): YamuxStream[] {\n    return Array.from(this._streams.values())\n  }\n\n  newStream (name?: string | undefined): YamuxStream {\n    if (this.remoteGoAway !== undefined) {\n      throw new CodeError('muxer closed remotely', ERR_MUXER_REMOTE_CLOSED)\n    }\n    if (this.localGoAway !== undefined) {\n      throw new CodeError('muxer closed locally', ERR_MUXER_LOCAL_CLOSED)\n    }\n\n    const id = this.nextStreamID\n    this.nextStreamID += 2\n\n    // check against our configured maximum number of outbound streams\n    if (this.numOutboundStreams >= this.config.maxOutboundStreams) {\n      throw new CodeError('max outbound streams exceeded', ERR_MAX_OUTBOUND_STREAMS_EXCEEDED)\n    }\n\n    this.log?.trace('new outgoing stream id=%s', id)\n\n    const stream = this._newStream(id, name, StreamState.Init, 'outbound')\n    this._streams.set(id, stream)\n\n    this.numOutboundStreams++\n\n    // send a window update to open the stream on the receiver end\n    stream.sendWindowUpdate()\n\n    return stream\n  }\n\n  /**\n   * Initiate a ping and wait for a response\n   *\n   * Note: only a single ping will be initiated at a time.\n   * If a ping is already in progress, a new ping will not be initiated.\n   *\n   * @returns the round-trip-time in milliseconds\n   */\n  async ping (): Promise<number> {\n    if (this.remoteGoAway !== undefined) {\n      throw new CodeError('muxer closed remotely', ERR_MUXER_REMOTE_CLOSED)\n    }\n    if (this.localGoAway !== undefined) {\n      throw new CodeError('muxer closed locally', ERR_MUXER_LOCAL_CLOSED)\n    }\n\n    // An active ping does not yet exist, handle the process here\n    if (this.activePing === undefined) {\n      // create active ping\n      let _resolve = (): void => {}\n      this.activePing = {\n        id: this.nextPingID++,\n        // this promise awaits resolution or the close controller aborting\n        promise: new Promise<void>((resolve, reject) => {\n          const closed = (): void => {\n            reject(new CodeError('muxer closed locally', ERR_MUXER_LOCAL_CLOSED))\n          }\n          this.closeController.signal.addEventListener('abort', closed, { once: true })\n          _resolve = (): void => {\n            this.closeController.signal.removeEventListener('abort', closed)\n            resolve()\n          }\n        }),\n        resolve: _resolve\n      }\n      // send ping\n      const start = Date.now()\n      this.sendPing(this.activePing.id)\n      // await pong\n      try {\n        await this.activePing.promise\n      } finally {\n        // clean-up active ping\n        delete this.activePing\n      }\n      // update rtt\n      const end = Date.now()\n      this.rtt = end - start\n    } else {\n      // an active ping is already in progress, piggyback off that\n      await this.activePing.promise\n    }\n    return this.rtt\n  }\n\n  /**\n   * Get the ping round trip time\n   *\n   * Note: Will return 0 if no successful ping has yet been completed\n   *\n   * @returns the round-trip-time in milliseconds\n   */\n  getRTT (): number {\n    return this.rtt\n  }\n\n  /**\n   * Close the muxer\n   */\n  async close (options: CloseOptions = {}): Promise<void> {\n    if (this.closeController.signal.aborted) {\n      // already closed\n      return\n    }\n\n    const reason = options?.reason ?? GoAwayCode.NormalTermination\n\n    this.log?.trace('muxer close reason=%s', reason)\n\n    if (options.signal == null) {\n      const signal = AbortSignal.timeout(CLOSE_TIMEOUT)\n      setMaxListeners(Infinity, signal)\n\n      options = {\n        ...options,\n        signal\n      }\n    }\n\n    try {\n      await Promise.all(\n        [...this._streams.values()].map(async s => s.close(options))\n      )\n\n      // send reason to the other side, allow the other side to close gracefully\n      this.sendGoAway(reason)\n\n      this._closeMuxer()\n    } catch (err: any) {\n      this.abort(err)\n    }\n  }\n\n  abort (err: Error, reason?: GoAwayCode): void {\n    if (this.closeController.signal.aborted) {\n      // already closed\n      return\n    }\n\n    reason = reason ?? GoAwayCode.InternalError\n\n    // If reason was provided, use that, otherwise use the presence of `err` to determine the reason\n    this.log?.error('muxer abort reason=%s error=%s', reason, err)\n\n    // Abort all underlying streams\n    for (const stream of this._streams.values()) {\n      stream.abort(err)\n    }\n\n    // send reason to the other side, allow the other side to close gracefully\n    this.sendGoAway(reason)\n\n    this._closeMuxer()\n  }\n\n  isClosed (): boolean {\n    return this.closeController.signal.aborted\n  }\n\n  /**\n   * Called when either the local or remote shuts down the muxer\n   */\n  private _closeMuxer (): void {\n    // stop the sink and any other processes\n    this.closeController.abort()\n\n    // stop the source\n    this.source.end()\n  }\n\n  /** Create a new stream */\n  private _newStream (id: number, name: string | undefined, state: StreamState, direction: 'inbound' | 'outbound'): YamuxStream {\n    if (this._streams.get(id) != null) {\n      throw new CodeError('Stream already exists', ERR_STREAM_ALREADY_EXISTS, { id })\n    }\n\n    const stream = new YamuxStream({\n      id: id.toString(),\n      name,\n      state,\n      direction,\n      sendFrame: this.sendFrame.bind(this),\n      onEnd: () => {\n        this.closeStream(id)\n        this.onStreamEnd?.(stream)\n      },\n      log: this.logger.forComponent(`libp2p:yamux:${direction}:${id}`),\n      config: this.config,\n      getRTT: this.getRTT.bind(this)\n    })\n\n    return stream\n  }\n\n  /**\n   * closeStream is used to close a stream once both sides have\n   * issued a close.\n   */\n  private closeStream (id: number): void {\n    if (this.client === (id % 2 === 0)) {\n      this.numInboundStreams--\n    } else {\n      this.numOutboundStreams--\n    }\n    this._streams.delete(id)\n  }\n\n  private async keepAliveLoop (): Promise<void> {\n    const abortPromise = new Promise((_resolve, reject) => { this.closeController.signal.addEventListener('abort', reject, { once: true }) })\n    this.log?.trace('muxer keepalive enabled interval=%s', this.config.keepAliveInterval)\n    while (true) {\n      let timeoutId\n      try {\n        await Promise.race([\n          abortPromise,\n          new Promise((resolve) => {\n            timeoutId = setTimeout(resolve, this.config.keepAliveInterval)\n          })\n        ])\n        this.ping().catch(e => this.log?.error('ping error: %s', e))\n      } catch (e) {\n        // closed\n        clearInterval(timeoutId)\n        return\n      }\n    }\n  }\n\n  private async handleFrame (header: FrameHeader, readData?: () => Promise<Uint8ArrayList>): Promise<void> {\n    const {\n      streamID,\n      type,\n      length\n    } = header\n    this.log?.trace('received frame %o', header)\n\n    if (streamID === 0) {\n      switch (type) {\n        case FrameType.Ping:\n        { this.handlePing(header); return }\n        case FrameType.GoAway:\n        { this.handleGoAway(length); return }\n        default:\n          // Invalid state\n          throw new CodeError('Invalid frame type', ERR_INVALID_FRAME, { header })\n      }\n    } else {\n      switch (header.type) {\n        case FrameType.Data:\n        case FrameType.WindowUpdate:\n        { await this.handleStreamMessage(header, readData); return }\n        default:\n          // Invalid state\n          throw new CodeError('Invalid frame type', ERR_INVALID_FRAME, { header })\n      }\n    }\n  }\n\n  private handlePing (header: FrameHeader): void {\n    // If the ping  is initiated by the sender, send a response\n    if (header.flag === Flag.SYN) {\n      this.log?.trace('received ping request pingId=%s', header.length)\n      this.sendPing(header.length, Flag.ACK)\n    } else if (header.flag === Flag.ACK) {\n      this.log?.trace('received ping response pingId=%s', header.length)\n      this.handlePingResponse(header.length)\n    } else {\n      // Invalid state\n      throw new CodeError('Invalid frame flag', ERR_INVALID_FRAME, { header })\n    }\n  }\n\n  private handlePingResponse (pingId: number): void {\n    if (this.activePing === undefined) {\n      // this ping was not requested\n      throw new CodeError('ping not requested', ERR_UNREQUESTED_PING)\n    }\n    if (this.activePing.id !== pingId) {\n      // this ping doesn't match our active ping request\n      throw new CodeError('ping doesn\\'t match our id', ERR_NOT_MATCHING_PING)\n    }\n\n    // valid ping response\n    this.activePing.resolve()\n  }\n\n  private handleGoAway (reason: GoAwayCode): void {\n    this.log?.trace('received GoAway reason=%s', GoAwayCode[reason] ?? 'unknown')\n    this.remoteGoAway = reason\n\n    // If the other side is friendly, they would have already closed all streams before sending a GoAway\n    // In case they weren't, reset all streams\n    for (const stream of this._streams.values()) {\n      stream.reset()\n    }\n\n    this._closeMuxer()\n  }\n\n  private async handleStreamMessage (header: FrameHeader, readData?: () => Promise<Uint8ArrayList>): Promise<void> {\n    const { streamID, flag, type } = header\n\n    if ((flag & Flag.SYN) === Flag.SYN) {\n      this.incomingStream(streamID)\n    }\n\n    const stream = this._streams.get(streamID)\n    if (stream === undefined) {\n      if (type === FrameType.Data) {\n        this.log?.('discarding data for stream id=%s', streamID)\n        if (readData === undefined) {\n          throw new Error('unreachable')\n        }\n        await readData()\n      } else {\n        this.log?.('frame for missing stream id=%s', streamID)\n      }\n      return\n    }\n\n    switch (type) {\n      case FrameType.WindowUpdate: {\n        stream.handleWindowUpdate(header); return\n      }\n      case FrameType.Data: {\n        if (readData === undefined) {\n          throw new Error('unreachable')\n        }\n\n        await stream.handleData(header, readData); return\n      }\n      default:\n        throw new Error('unreachable')\n    }\n  }\n\n  private incomingStream (id: number): void {\n    if (this.client !== (id % 2 === 0)) {\n      throw new CodeError('both endpoints are clients', ERR_BOTH_CLIENTS)\n    }\n    if (this._streams.has(id)) {\n      return\n    }\n\n    this.log?.trace('new incoming stream id=%s', id)\n\n    if (this.localGoAway !== undefined) {\n      // reject (reset) immediately if we are doing a go away\n      this.sendFrame({\n        type: FrameType.WindowUpdate,\n        flag: Flag.RST,\n        streamID: id,\n        length: 0\n      }); return\n    }\n\n    // check against our configured maximum number of inbound streams\n    if (this.numInboundStreams >= this.config.maxInboundStreams) {\n      this.log?.('maxIncomingStreams exceeded, forcing stream reset')\n      this.sendFrame({\n        type: FrameType.WindowUpdate,\n        flag: Flag.RST,\n        streamID: id,\n        length: 0\n      }); return\n    }\n\n    // allocate a new stream\n    const stream = this._newStream(id, undefined, StreamState.SYNReceived, 'inbound')\n\n    this.numInboundStreams++\n    // the stream should now be tracked\n    this._streams.set(id, stream)\n\n    this.onIncomingStream?.(stream)\n  }\n\n  private sendFrame (header: FrameHeader, data?: Uint8ArrayList): void {\n    this.log?.trace('sending frame %o', header)\n    if (header.type === FrameType.Data) {\n      if (data === undefined) {\n        throw new CodeError('invalid frame', ERR_INVALID_FRAME)\n      }\n      this.source.push(\n        new Uint8ArrayList(encodeHeader(header), data)\n      )\n    } else {\n      this.source.push(encodeHeader(header))\n    }\n  }\n\n  private sendPing (pingId: number, flag: Flag = Flag.SYN): void {\n    if (flag === Flag.SYN) {\n      this.log?.trace('sending ping request pingId=%s', pingId)\n    } else {\n      this.log?.trace('sending ping response pingId=%s', pingId)\n    }\n    this.sendFrame({\n      type: FrameType.Ping,\n      flag,\n      streamID: 0,\n      length: pingId\n    })\n  }\n\n  private sendGoAway (reason: GoAwayCode = GoAwayCode.NormalTermination): void {\n    this.log?.('sending GoAway reason=%s', GoAwayCode[reason])\n    this.localGoAway = reason\n    this.sendFrame({\n      type: FrameType.GoAway,\n      flag: 0,\n      streamID: 0,\n      length: reason\n    })\n  }\n}\n\nfunction isPromise <T = unknown> (thing: any): thing is Promise<T> {\n  return thing != null && typeof thing.then === 'function'\n}\n", "/**\n * @packageDocumentation\n *\n * This module is a JavaScript implementation of [Yamux from Hashicorp](https://github.com/hashicorp/yamux/blob/master/spec.md) designed to be used with [js-libp2p](https://github.com/libp2p/js-libp2p).\n *\n * @example Configure libp2p with Yamux\n *\n * ```typescript\n * import { createLibp2p } from 'libp2p'\n * import { yamux } from '@chainsafe/libp2p-yamux'\n *\n * const node = await createLibp2p({\n *   // ... other options\n *   streamMuxers: [\n *     yamux()\n *   ]\n * })\n * ```\n *\n * @example Using the low-level API\n *\n * ```js\n * import { yamux } from '@chainsafe/libp2p-yamux'\n * import { pipe } from 'it-pipe'\n * import { duplexPair } from 'it-pair/duplex'\n * import all from 'it-all'\n *\n * // Connect two yamux muxers to demo basic stream multiplexing functionality\n *\n * const clientMuxer = yamux({\n *   client: true,\n *   onIncomingStream: stream => {\n *     // echo data on incoming streams\n *     pipe(stream, stream)\n *   },\n *   onStreamEnd: stream => {\n *     // do nothing\n *   }\n * })()\n *\n * const serverMuxer = yamux({\n *   client: false,\n *   onIncomingStream: stream => {\n *     // echo data on incoming streams\n *     pipe(stream, stream)\n *   },\n *   onStreamEnd: stream => {\n *     // do nothing\n *   }\n * })()\n *\n * // `p` is our \"connections\", what we use to connect the two sides\n * // In a real application, a connection is usually to a remote computer\n * const p = duplexPair()\n *\n * // connect the muxers together\n * pipe(p[0], clientMuxer, p[0])\n * pipe(p[1], serverMuxer, p[1])\n *\n * // now either side can open streams\n * const stream0 = clientMuxer.newStream()\n * const stream1 = serverMuxer.newStream()\n *\n * // Send some data to the other side\n * const encoder = new TextEncoder()\n * const data = [encoder.encode('hello'), encoder.encode('world')]\n * pipe(data, stream0)\n *\n * // Receive data back\n * const result = await pipe(stream0, all)\n *\n * // close a stream\n * stream1.close()\n *\n * // close the muxer\n * clientMuxer.close()\n * ```\n */\n\nimport { Yamux } from './muxer.js'\nimport type { YamuxMuxerInit } from './muxer.js'\nimport type { ComponentLogger, StreamMuxerFactory } from '@libp2p/interface'\n\nexport { GoAwayCode, type FrameHeader, type FrameType } from './frame.js'\nexport type { YamuxMuxerInit }\n\nexport interface YamuxMuxerComponents {\n  logger: ComponentLogger\n}\n\nexport function yamux (init: YamuxMuxerInit = {}): (components: YamuxMuxerComponents) => StreamMuxerFactory {\n  return (components) => new Yamux(components, init)\n}\n"],
  "mappings": "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",
  "names": ["FrameType", "Flag", "GoAwayCode", "res", "src_default", "StreamState", "src_default", "isPromise"]
}
