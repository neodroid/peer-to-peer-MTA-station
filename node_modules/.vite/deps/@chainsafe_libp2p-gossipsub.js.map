{
  "version": 3,
  "sources": ["../../@protobufjs/aspromise/index.js", "../../@protobufjs/base64/index.js", "../../@protobufjs/eventemitter/index.js", "../../@protobufjs/float/index.js", "../../@protobufjs/inquire/index.js", "../../@protobufjs/utf8/index.js", "../../@protobufjs/pool/index.js", "../../protobufjs/src/util/longbits.js", "../../protobufjs/src/util/minimal.js", "../../protobufjs/src/writer.js", "../../protobufjs/src/writer_buffer.js", "../../protobufjs/src/reader.js", "../../protobufjs/src/reader_buffer.js", "../../protobufjs/src/rpc/service.js", "../../protobufjs/src/rpc.js", "../../protobufjs/src/roots.js", "../../protobufjs/src/index-minimal.js", "../../protobufjs/minimal.js", "../../@chainsafe/libp2p-gossipsub/dist/src/message/rpc.cjs", "../../denque/index.js", "../../@chainsafe/libp2p-gossipsub/src/constants.ts", "../../@chainsafe/libp2p-gossipsub/src/message/decodeRpc.ts", "../../@chainsafe/libp2p-gossipsub/dist/src/message/rpc.js", "../../@chainsafe/libp2p-gossipsub/src/message-cache.ts", "../../@chainsafe/libp2p-gossipsub/src/types.ts", "../../@chainsafe/libp2p-gossipsub/src/metrics.ts", "../../@chainsafe/libp2p-gossipsub/src/score/constants.ts", "../../@chainsafe/libp2p-gossipsub/src/score/peer-score-params.ts", "../../@chainsafe/libp2p-gossipsub/src/score/peer-score-thresholds.ts", "../../@chainsafe/libp2p-gossipsub/src/utils/set.ts", "../../@chainsafe/libp2p-gossipsub/src/score/compute-score.ts", "../../@chainsafe/libp2p-gossipsub/src/score/message-deliveries.ts", "../../@chainsafe/libp2p-gossipsub/src/score/peer-score.ts", "../../@chainsafe/libp2p-gossipsub/src/score/scoreMetrics.ts", "../../@chainsafe/libp2p-gossipsub/src/stream.ts", "../../@chainsafe/libp2p-gossipsub/src/tracer.ts", "../../@chainsafe/libp2p-gossipsub/src/utils/buildRawMessage.ts", "../../@chainsafe/libp2p-gossipsub/src/utils/shuffle.ts", "../../@chainsafe/libp2p-gossipsub/src/utils/messageIdToString.ts", "../../@chainsafe/libp2p-gossipsub/src/utils/publishConfig.ts", "../../@libp2p/pubsub/src/utils.ts", "../../@chainsafe/libp2p-gossipsub/src/utils/msgIdFn.ts", "../../@chainsafe/libp2p-gossipsub/src/utils/multiaddr.ts", "../../@chainsafe/libp2p-gossipsub/src/utils/time-cache.ts", "../../@chainsafe/libp2p-gossipsub/src/index.ts"],
  "sourcesContent": ["\"use strict\";\r\nmodule.exports = asPromise;\r\n\r\n/**\r\n * Callback as used by {@link util.asPromise}.\r\n * @typedef asPromiseCallback\r\n * @type {function}\r\n * @param {Error|null} error Error, if any\r\n * @param {...*} params Additional arguments\r\n * @returns {undefined}\r\n */\r\n\r\n/**\r\n * Returns a promise from a node-style callback function.\r\n * @memberof util\r\n * @param {asPromiseCallback} fn Function to call\r\n * @param {*} ctx Function context\r\n * @param {...*} params Function arguments\r\n * @returns {Promise<*>} Promisified function\r\n */\r\nfunction asPromise(fn, ctx/*, varargs */) {\r\n    var params  = new Array(arguments.length - 1),\r\n        offset  = 0,\r\n        index   = 2,\r\n        pending = true;\r\n    while (index < arguments.length)\r\n        params[offset++] = arguments[index++];\r\n    return new Promise(function executor(resolve, reject) {\r\n        params[offset] = function callback(err/*, varargs */) {\r\n            if (pending) {\r\n                pending = false;\r\n                if (err)\r\n                    reject(err);\r\n                else {\r\n                    var params = new Array(arguments.length - 1),\r\n                        offset = 0;\r\n                    while (offset < params.length)\r\n                        params[offset++] = arguments[offset];\r\n                    resolve.apply(null, params);\r\n                }\r\n            }\r\n        };\r\n        try {\r\n            fn.apply(ctx || null, params);\r\n        } catch (err) {\r\n            if (pending) {\r\n                pending = false;\r\n                reject(err);\r\n            }\r\n        }\r\n    });\r\n}\r\n", "\"use strict\";\r\n\r\n/**\r\n * A minimal base64 implementation for number arrays.\r\n * @memberof util\r\n * @namespace\r\n */\r\nvar base64 = exports;\r\n\r\n/**\r\n * Calculates the byte length of a base64 encoded string.\r\n * @param {string} string Base64 encoded string\r\n * @returns {number} Byte length\r\n */\r\nbase64.length = function length(string) {\r\n    var p = string.length;\r\n    if (!p)\r\n        return 0;\r\n    var n = 0;\r\n    while (--p % 4 > 1 && string.charAt(p) === \"=\")\r\n        ++n;\r\n    return Math.ceil(string.length * 3) / 4 - n;\r\n};\r\n\r\n// Base64 encoding table\r\nvar b64 = new Array(64);\r\n\r\n// Base64 decoding table\r\nvar s64 = new Array(123);\r\n\r\n// 65..90, 97..122, 48..57, 43, 47\r\nfor (var i = 0; i < 64;)\r\n    s64[b64[i] = i < 26 ? i + 65 : i < 52 ? i + 71 : i < 62 ? i - 4 : i - 59 | 43] = i++;\r\n\r\n/**\r\n * Encodes a buffer to a base64 encoded string.\r\n * @param {Uint8Array} buffer Source buffer\r\n * @param {number} start Source start\r\n * @param {number} end Source end\r\n * @returns {string} Base64 encoded string\r\n */\r\nbase64.encode = function encode(buffer, start, end) {\r\n    var parts = null,\r\n        chunk = [];\r\n    var i = 0, // output index\r\n        j = 0, // goto index\r\n        t;     // temporary\r\n    while (start < end) {\r\n        var b = buffer[start++];\r\n        switch (j) {\r\n            case 0:\r\n                chunk[i++] = b64[b >> 2];\r\n                t = (b & 3) << 4;\r\n                j = 1;\r\n                break;\r\n            case 1:\r\n                chunk[i++] = b64[t | b >> 4];\r\n                t = (b & 15) << 2;\r\n                j = 2;\r\n                break;\r\n            case 2:\r\n                chunk[i++] = b64[t | b >> 6];\r\n                chunk[i++] = b64[b & 63];\r\n                j = 0;\r\n                break;\r\n        }\r\n        if (i > 8191) {\r\n            (parts || (parts = [])).push(String.fromCharCode.apply(String, chunk));\r\n            i = 0;\r\n        }\r\n    }\r\n    if (j) {\r\n        chunk[i++] = b64[t];\r\n        chunk[i++] = 61;\r\n        if (j === 1)\r\n            chunk[i++] = 61;\r\n    }\r\n    if (parts) {\r\n        if (i)\r\n            parts.push(String.fromCharCode.apply(String, chunk.slice(0, i)));\r\n        return parts.join(\"\");\r\n    }\r\n    return String.fromCharCode.apply(String, chunk.slice(0, i));\r\n};\r\n\r\nvar invalidEncoding = \"invalid encoding\";\r\n\r\n/**\r\n * Decodes a base64 encoded string to a buffer.\r\n * @param {string} string Source string\r\n * @param {Uint8Array} buffer Destination buffer\r\n * @param {number} offset Destination offset\r\n * @returns {number} Number of bytes written\r\n * @throws {Error} If encoding is invalid\r\n */\r\nbase64.decode = function decode(string, buffer, offset) {\r\n    var start = offset;\r\n    var j = 0, // goto index\r\n        t;     // temporary\r\n    for (var i = 0; i < string.length;) {\r\n        var c = string.charCodeAt(i++);\r\n        if (c === 61 && j > 1)\r\n            break;\r\n        if ((c = s64[c]) === undefined)\r\n            throw Error(invalidEncoding);\r\n        switch (j) {\r\n            case 0:\r\n                t = c;\r\n                j = 1;\r\n                break;\r\n            case 1:\r\n                buffer[offset++] = t << 2 | (c & 48) >> 4;\r\n                t = c;\r\n                j = 2;\r\n                break;\r\n            case 2:\r\n                buffer[offset++] = (t & 15) << 4 | (c & 60) >> 2;\r\n                t = c;\r\n                j = 3;\r\n                break;\r\n            case 3:\r\n                buffer[offset++] = (t & 3) << 6 | c;\r\n                j = 0;\r\n                break;\r\n        }\r\n    }\r\n    if (j === 1)\r\n        throw Error(invalidEncoding);\r\n    return offset - start;\r\n};\r\n\r\n/**\r\n * Tests if the specified string appears to be base64 encoded.\r\n * @param {string} string String to test\r\n * @returns {boolean} `true` if probably base64 encoded, otherwise false\r\n */\r\nbase64.test = function test(string) {\r\n    return /^(?:[A-Za-z0-9+/]{4})*(?:[A-Za-z0-9+/]{2}==|[A-Za-z0-9+/]{3}=)?$/.test(string);\r\n};\r\n", "\"use strict\";\r\nmodule.exports = EventEmitter;\r\n\r\n/**\r\n * Constructs a new event emitter instance.\r\n * @classdesc A minimal event emitter.\r\n * @memberof util\r\n * @constructor\r\n */\r\nfunction EventEmitter() {\r\n\r\n    /**\r\n     * Registered listeners.\r\n     * @type {Object.<string,*>}\r\n     * @private\r\n     */\r\n    this._listeners = {};\r\n}\r\n\r\n/**\r\n * Registers an event listener.\r\n * @param {string} evt Event name\r\n * @param {function} fn Listener\r\n * @param {*} [ctx] Listener context\r\n * @returns {util.EventEmitter} `this`\r\n */\r\nEventEmitter.prototype.on = function on(evt, fn, ctx) {\r\n    (this._listeners[evt] || (this._listeners[evt] = [])).push({\r\n        fn  : fn,\r\n        ctx : ctx || this\r\n    });\r\n    return this;\r\n};\r\n\r\n/**\r\n * Removes an event listener or any matching listeners if arguments are omitted.\r\n * @param {string} [evt] Event name. Removes all listeners if omitted.\r\n * @param {function} [fn] Listener to remove. Removes all listeners of `evt` if omitted.\r\n * @returns {util.EventEmitter} `this`\r\n */\r\nEventEmitter.prototype.off = function off(evt, fn) {\r\n    if (evt === undefined)\r\n        this._listeners = {};\r\n    else {\r\n        if (fn === undefined)\r\n            this._listeners[evt] = [];\r\n        else {\r\n            var listeners = this._listeners[evt];\r\n            for (var i = 0; i < listeners.length;)\r\n                if (listeners[i].fn === fn)\r\n                    listeners.splice(i, 1);\r\n                else\r\n                    ++i;\r\n        }\r\n    }\r\n    return this;\r\n};\r\n\r\n/**\r\n * Emits an event by calling its listeners with the specified arguments.\r\n * @param {string} evt Event name\r\n * @param {...*} args Arguments\r\n * @returns {util.EventEmitter} `this`\r\n */\r\nEventEmitter.prototype.emit = function emit(evt) {\r\n    var listeners = this._listeners[evt];\r\n    if (listeners) {\r\n        var args = [],\r\n            i = 1;\r\n        for (; i < arguments.length;)\r\n            args.push(arguments[i++]);\r\n        for (i = 0; i < listeners.length;)\r\n            listeners[i].fn.apply(listeners[i++].ctx, args);\r\n    }\r\n    return this;\r\n};\r\n", "\"use strict\";\r\n\r\nmodule.exports = factory(factory);\r\n\r\n/**\r\n * Reads / writes floats / doubles from / to buffers.\r\n * @name util.float\r\n * @namespace\r\n */\r\n\r\n/**\r\n * Writes a 32 bit float to a buffer using little endian byte order.\r\n * @name util.float.writeFloatLE\r\n * @function\r\n * @param {number} val Value to write\r\n * @param {Uint8Array} buf Target buffer\r\n * @param {number} pos Target buffer offset\r\n * @returns {undefined}\r\n */\r\n\r\n/**\r\n * Writes a 32 bit float to a buffer using big endian byte order.\r\n * @name util.float.writeFloatBE\r\n * @function\r\n * @param {number} val Value to write\r\n * @param {Uint8Array} buf Target buffer\r\n * @param {number} pos Target buffer offset\r\n * @returns {undefined}\r\n */\r\n\r\n/**\r\n * Reads a 32 bit float from a buffer using little endian byte order.\r\n * @name util.float.readFloatLE\r\n * @function\r\n * @param {Uint8Array} buf Source buffer\r\n * @param {number} pos Source buffer offset\r\n * @returns {number} Value read\r\n */\r\n\r\n/**\r\n * Reads a 32 bit float from a buffer using big endian byte order.\r\n * @name util.float.readFloatBE\r\n * @function\r\n * @param {Uint8Array} buf Source buffer\r\n * @param {number} pos Source buffer offset\r\n * @returns {number} Value read\r\n */\r\n\r\n/**\r\n * Writes a 64 bit double to a buffer using little endian byte order.\r\n * @name util.float.writeDoubleLE\r\n * @function\r\n * @param {number} val Value to write\r\n * @param {Uint8Array} buf Target buffer\r\n * @param {number} pos Target buffer offset\r\n * @returns {undefined}\r\n */\r\n\r\n/**\r\n * Writes a 64 bit double to a buffer using big endian byte order.\r\n * @name util.float.writeDoubleBE\r\n * @function\r\n * @param {number} val Value to write\r\n * @param {Uint8Array} buf Target buffer\r\n * @param {number} pos Target buffer offset\r\n * @returns {undefined}\r\n */\r\n\r\n/**\r\n * Reads a 64 bit double from a buffer using little endian byte order.\r\n * @name util.float.readDoubleLE\r\n * @function\r\n * @param {Uint8Array} buf Source buffer\r\n * @param {number} pos Source buffer offset\r\n * @returns {number} Value read\r\n */\r\n\r\n/**\r\n * Reads a 64 bit double from a buffer using big endian byte order.\r\n * @name util.float.readDoubleBE\r\n * @function\r\n * @param {Uint8Array} buf Source buffer\r\n * @param {number} pos Source buffer offset\r\n * @returns {number} Value read\r\n */\r\n\r\n// Factory function for the purpose of node-based testing in modified global environments\r\nfunction factory(exports) {\r\n\r\n    // float: typed array\r\n    if (typeof Float32Array !== \"undefined\") (function() {\r\n\r\n        var f32 = new Float32Array([ -0 ]),\r\n            f8b = new Uint8Array(f32.buffer),\r\n            le  = f8b[3] === 128;\r\n\r\n        function writeFloat_f32_cpy(val, buf, pos) {\r\n            f32[0] = val;\r\n            buf[pos    ] = f8b[0];\r\n            buf[pos + 1] = f8b[1];\r\n            buf[pos + 2] = f8b[2];\r\n            buf[pos + 3] = f8b[3];\r\n        }\r\n\r\n        function writeFloat_f32_rev(val, buf, pos) {\r\n            f32[0] = val;\r\n            buf[pos    ] = f8b[3];\r\n            buf[pos + 1] = f8b[2];\r\n            buf[pos + 2] = f8b[1];\r\n            buf[pos + 3] = f8b[0];\r\n        }\r\n\r\n        /* istanbul ignore next */\r\n        exports.writeFloatLE = le ? writeFloat_f32_cpy : writeFloat_f32_rev;\r\n        /* istanbul ignore next */\r\n        exports.writeFloatBE = le ? writeFloat_f32_rev : writeFloat_f32_cpy;\r\n\r\n        function readFloat_f32_cpy(buf, pos) {\r\n            f8b[0] = buf[pos    ];\r\n            f8b[1] = buf[pos + 1];\r\n            f8b[2] = buf[pos + 2];\r\n            f8b[3] = buf[pos + 3];\r\n            return f32[0];\r\n        }\r\n\r\n        function readFloat_f32_rev(buf, pos) {\r\n            f8b[3] = buf[pos    ];\r\n            f8b[2] = buf[pos + 1];\r\n            f8b[1] = buf[pos + 2];\r\n            f8b[0] = buf[pos + 3];\r\n            return f32[0];\r\n        }\r\n\r\n        /* istanbul ignore next */\r\n        exports.readFloatLE = le ? readFloat_f32_cpy : readFloat_f32_rev;\r\n        /* istanbul ignore next */\r\n        exports.readFloatBE = le ? readFloat_f32_rev : readFloat_f32_cpy;\r\n\r\n    // float: ieee754\r\n    })(); else (function() {\r\n\r\n        function writeFloat_ieee754(writeUint, val, buf, pos) {\r\n            var sign = val < 0 ? 1 : 0;\r\n            if (sign)\r\n                val = -val;\r\n            if (val === 0)\r\n                writeUint(1 / val > 0 ? /* positive */ 0 : /* negative 0 */ 2147483648, buf, pos);\r\n            else if (isNaN(val))\r\n                writeUint(2143289344, buf, pos);\r\n            else if (val > 3.4028234663852886e+38) // +-Infinity\r\n                writeUint((sign << 31 | 2139095040) >>> 0, buf, pos);\r\n            else if (val < 1.1754943508222875e-38) // denormal\r\n                writeUint((sign << 31 | Math.round(val / 1.401298464324817e-45)) >>> 0, buf, pos);\r\n            else {\r\n                var exponent = Math.floor(Math.log(val) / Math.LN2),\r\n                    mantissa = Math.round(val * Math.pow(2, -exponent) * 8388608) & 8388607;\r\n                writeUint((sign << 31 | exponent + 127 << 23 | mantissa) >>> 0, buf, pos);\r\n            }\r\n        }\r\n\r\n        exports.writeFloatLE = writeFloat_ieee754.bind(null, writeUintLE);\r\n        exports.writeFloatBE = writeFloat_ieee754.bind(null, writeUintBE);\r\n\r\n        function readFloat_ieee754(readUint, buf, pos) {\r\n            var uint = readUint(buf, pos),\r\n                sign = (uint >> 31) * 2 + 1,\r\n                exponent = uint >>> 23 & 255,\r\n                mantissa = uint & 8388607;\r\n            return exponent === 255\r\n                ? mantissa\r\n                ? NaN\r\n                : sign * Infinity\r\n                : exponent === 0 // denormal\r\n                ? sign * 1.401298464324817e-45 * mantissa\r\n                : sign * Math.pow(2, exponent - 150) * (mantissa + 8388608);\r\n        }\r\n\r\n        exports.readFloatLE = readFloat_ieee754.bind(null, readUintLE);\r\n        exports.readFloatBE = readFloat_ieee754.bind(null, readUintBE);\r\n\r\n    })();\r\n\r\n    // double: typed array\r\n    if (typeof Float64Array !== \"undefined\") (function() {\r\n\r\n        var f64 = new Float64Array([-0]),\r\n            f8b = new Uint8Array(f64.buffer),\r\n            le  = f8b[7] === 128;\r\n\r\n        function writeDouble_f64_cpy(val, buf, pos) {\r\n            f64[0] = val;\r\n            buf[pos    ] = f8b[0];\r\n            buf[pos + 1] = f8b[1];\r\n            buf[pos + 2] = f8b[2];\r\n            buf[pos + 3] = f8b[3];\r\n            buf[pos + 4] = f8b[4];\r\n            buf[pos + 5] = f8b[5];\r\n            buf[pos + 6] = f8b[6];\r\n            buf[pos + 7] = f8b[7];\r\n        }\r\n\r\n        function writeDouble_f64_rev(val, buf, pos) {\r\n            f64[0] = val;\r\n            buf[pos    ] = f8b[7];\r\n            buf[pos + 1] = f8b[6];\r\n            buf[pos + 2] = f8b[5];\r\n            buf[pos + 3] = f8b[4];\r\n            buf[pos + 4] = f8b[3];\r\n            buf[pos + 5] = f8b[2];\r\n            buf[pos + 6] = f8b[1];\r\n            buf[pos + 7] = f8b[0];\r\n        }\r\n\r\n        /* istanbul ignore next */\r\n        exports.writeDoubleLE = le ? writeDouble_f64_cpy : writeDouble_f64_rev;\r\n        /* istanbul ignore next */\r\n        exports.writeDoubleBE = le ? writeDouble_f64_rev : writeDouble_f64_cpy;\r\n\r\n        function readDouble_f64_cpy(buf, pos) {\r\n            f8b[0] = buf[pos    ];\r\n            f8b[1] = buf[pos + 1];\r\n            f8b[2] = buf[pos + 2];\r\n            f8b[3] = buf[pos + 3];\r\n            f8b[4] = buf[pos + 4];\r\n            f8b[5] = buf[pos + 5];\r\n            f8b[6] = buf[pos + 6];\r\n            f8b[7] = buf[pos + 7];\r\n            return f64[0];\r\n        }\r\n\r\n        function readDouble_f64_rev(buf, pos) {\r\n            f8b[7] = buf[pos    ];\r\n            f8b[6] = buf[pos + 1];\r\n            f8b[5] = buf[pos + 2];\r\n            f8b[4] = buf[pos + 3];\r\n            f8b[3] = buf[pos + 4];\r\n            f8b[2] = buf[pos + 5];\r\n            f8b[1] = buf[pos + 6];\r\n            f8b[0] = buf[pos + 7];\r\n            return f64[0];\r\n        }\r\n\r\n        /* istanbul ignore next */\r\n        exports.readDoubleLE = le ? readDouble_f64_cpy : readDouble_f64_rev;\r\n        /* istanbul ignore next */\r\n        exports.readDoubleBE = le ? readDouble_f64_rev : readDouble_f64_cpy;\r\n\r\n    // double: ieee754\r\n    })(); else (function() {\r\n\r\n        function writeDouble_ieee754(writeUint, off0, off1, val, buf, pos) {\r\n            var sign = val < 0 ? 1 : 0;\r\n            if (sign)\r\n                val = -val;\r\n            if (val === 0) {\r\n                writeUint(0, buf, pos + off0);\r\n                writeUint(1 / val > 0 ? /* positive */ 0 : /* negative 0 */ 2147483648, buf, pos + off1);\r\n            } else if (isNaN(val)) {\r\n                writeUint(0, buf, pos + off0);\r\n                writeUint(2146959360, buf, pos + off1);\r\n            } else if (val > 1.7976931348623157e+308) { // +-Infinity\r\n                writeUint(0, buf, pos + off0);\r\n                writeUint((sign << 31 | 2146435072) >>> 0, buf, pos + off1);\r\n            } else {\r\n                var mantissa;\r\n                if (val < 2.2250738585072014e-308) { // denormal\r\n                    mantissa = val / 5e-324;\r\n                    writeUint(mantissa >>> 0, buf, pos + off0);\r\n                    writeUint((sign << 31 | mantissa / 4294967296) >>> 0, buf, pos + off1);\r\n                } else {\r\n                    var exponent = Math.floor(Math.log(val) / Math.LN2);\r\n                    if (exponent === 1024)\r\n                        exponent = 1023;\r\n                    mantissa = val * Math.pow(2, -exponent);\r\n                    writeUint(mantissa * 4503599627370496 >>> 0, buf, pos + off0);\r\n                    writeUint((sign << 31 | exponent + 1023 << 20 | mantissa * 1048576 & 1048575) >>> 0, buf, pos + off1);\r\n                }\r\n            }\r\n        }\r\n\r\n        exports.writeDoubleLE = writeDouble_ieee754.bind(null, writeUintLE, 0, 4);\r\n        exports.writeDoubleBE = writeDouble_ieee754.bind(null, writeUintBE, 4, 0);\r\n\r\n        function readDouble_ieee754(readUint, off0, off1, buf, pos) {\r\n            var lo = readUint(buf, pos + off0),\r\n                hi = readUint(buf, pos + off1);\r\n            var sign = (hi >> 31) * 2 + 1,\r\n                exponent = hi >>> 20 & 2047,\r\n                mantissa = 4294967296 * (hi & 1048575) + lo;\r\n            return exponent === 2047\r\n                ? mantissa\r\n                ? NaN\r\n                : sign * Infinity\r\n                : exponent === 0 // denormal\r\n                ? sign * 5e-324 * mantissa\r\n                : sign * Math.pow(2, exponent - 1075) * (mantissa + 4503599627370496);\r\n        }\r\n\r\n        exports.readDoubleLE = readDouble_ieee754.bind(null, readUintLE, 0, 4);\r\n        exports.readDoubleBE = readDouble_ieee754.bind(null, readUintBE, 4, 0);\r\n\r\n    })();\r\n\r\n    return exports;\r\n}\r\n\r\n// uint helpers\r\n\r\nfunction writeUintLE(val, buf, pos) {\r\n    buf[pos    ] =  val        & 255;\r\n    buf[pos + 1] =  val >>> 8  & 255;\r\n    buf[pos + 2] =  val >>> 16 & 255;\r\n    buf[pos + 3] =  val >>> 24;\r\n}\r\n\r\nfunction writeUintBE(val, buf, pos) {\r\n    buf[pos    ] =  val >>> 24;\r\n    buf[pos + 1] =  val >>> 16 & 255;\r\n    buf[pos + 2] =  val >>> 8  & 255;\r\n    buf[pos + 3] =  val        & 255;\r\n}\r\n\r\nfunction readUintLE(buf, pos) {\r\n    return (buf[pos    ]\r\n          | buf[pos + 1] << 8\r\n          | buf[pos + 2] << 16\r\n          | buf[pos + 3] << 24) >>> 0;\r\n}\r\n\r\nfunction readUintBE(buf, pos) {\r\n    return (buf[pos    ] << 24\r\n          | buf[pos + 1] << 16\r\n          | buf[pos + 2] << 8\r\n          | buf[pos + 3]) >>> 0;\r\n}\r\n", "\"use strict\";\r\nmodule.exports = inquire;\r\n\r\n/**\r\n * Requires a module only if available.\r\n * @memberof util\r\n * @param {string} moduleName Module to require\r\n * @returns {?Object} Required module if available and not empty, otherwise `null`\r\n */\r\nfunction inquire(moduleName) {\r\n    try {\r\n        var mod = eval(\"quire\".replace(/^/,\"re\"))(moduleName); // eslint-disable-line no-eval\r\n        if (mod && (mod.length || Object.keys(mod).length))\r\n            return mod;\r\n    } catch (e) {} // eslint-disable-line no-empty\r\n    return null;\r\n}\r\n", "\"use strict\";\r\n\r\n/**\r\n * A minimal UTF8 implementation for number arrays.\r\n * @memberof util\r\n * @namespace\r\n */\r\nvar utf8 = exports;\r\n\r\n/**\r\n * Calculates the UTF8 byte length of a string.\r\n * @param {string} string String\r\n * @returns {number} Byte length\r\n */\r\nutf8.length = function utf8_length(string) {\r\n    var len = 0,\r\n        c = 0;\r\n    for (var i = 0; i < string.length; ++i) {\r\n        c = string.charCodeAt(i);\r\n        if (c < 128)\r\n            len += 1;\r\n        else if (c < 2048)\r\n            len += 2;\r\n        else if ((c & 0xFC00) === 0xD800 && (string.charCodeAt(i + 1) & 0xFC00) === 0xDC00) {\r\n            ++i;\r\n            len += 4;\r\n        } else\r\n            len += 3;\r\n    }\r\n    return len;\r\n};\r\n\r\n/**\r\n * Reads UTF8 bytes as a string.\r\n * @param {Uint8Array} buffer Source buffer\r\n * @param {number} start Source start\r\n * @param {number} end Source end\r\n * @returns {string} String read\r\n */\r\nutf8.read = function utf8_read(buffer, start, end) {\r\n    var len = end - start;\r\n    if (len < 1)\r\n        return \"\";\r\n    var parts = null,\r\n        chunk = [],\r\n        i = 0, // char offset\r\n        t;     // temporary\r\n    while (start < end) {\r\n        t = buffer[start++];\r\n        if (t < 128)\r\n            chunk[i++] = t;\r\n        else if (t > 191 && t < 224)\r\n            chunk[i++] = (t & 31) << 6 | buffer[start++] & 63;\r\n        else if (t > 239 && t < 365) {\r\n            t = ((t & 7) << 18 | (buffer[start++] & 63) << 12 | (buffer[start++] & 63) << 6 | buffer[start++] & 63) - 0x10000;\r\n            chunk[i++] = 0xD800 + (t >> 10);\r\n            chunk[i++] = 0xDC00 + (t & 1023);\r\n        } else\r\n            chunk[i++] = (t & 15) << 12 | (buffer[start++] & 63) << 6 | buffer[start++] & 63;\r\n        if (i > 8191) {\r\n            (parts || (parts = [])).push(String.fromCharCode.apply(String, chunk));\r\n            i = 0;\r\n        }\r\n    }\r\n    if (parts) {\r\n        if (i)\r\n            parts.push(String.fromCharCode.apply(String, chunk.slice(0, i)));\r\n        return parts.join(\"\");\r\n    }\r\n    return String.fromCharCode.apply(String, chunk.slice(0, i));\r\n};\r\n\r\n/**\r\n * Writes a string as UTF8 bytes.\r\n * @param {string} string Source string\r\n * @param {Uint8Array} buffer Destination buffer\r\n * @param {number} offset Destination offset\r\n * @returns {number} Bytes written\r\n */\r\nutf8.write = function utf8_write(string, buffer, offset) {\r\n    var start = offset,\r\n        c1, // character 1\r\n        c2; // character 2\r\n    for (var i = 0; i < string.length; ++i) {\r\n        c1 = string.charCodeAt(i);\r\n        if (c1 < 128) {\r\n            buffer[offset++] = c1;\r\n        } else if (c1 < 2048) {\r\n            buffer[offset++] = c1 >> 6       | 192;\r\n            buffer[offset++] = c1       & 63 | 128;\r\n        } else if ((c1 & 0xFC00) === 0xD800 && ((c2 = string.charCodeAt(i + 1)) & 0xFC00) === 0xDC00) {\r\n            c1 = 0x10000 + ((c1 & 0x03FF) << 10) + (c2 & 0x03FF);\r\n            ++i;\r\n            buffer[offset++] = c1 >> 18      | 240;\r\n            buffer[offset++] = c1 >> 12 & 63 | 128;\r\n            buffer[offset++] = c1 >> 6  & 63 | 128;\r\n            buffer[offset++] = c1       & 63 | 128;\r\n        } else {\r\n            buffer[offset++] = c1 >> 12      | 224;\r\n            buffer[offset++] = c1 >> 6  & 63 | 128;\r\n            buffer[offset++] = c1       & 63 | 128;\r\n        }\r\n    }\r\n    return offset - start;\r\n};\r\n", "\"use strict\";\r\nmodule.exports = pool;\r\n\r\n/**\r\n * An allocator as used by {@link util.pool}.\r\n * @typedef PoolAllocator\r\n * @type {function}\r\n * @param {number} size Buffer size\r\n * @returns {Uint8Array} Buffer\r\n */\r\n\r\n/**\r\n * A slicer as used by {@link util.pool}.\r\n * @typedef PoolSlicer\r\n * @type {function}\r\n * @param {number} start Start offset\r\n * @param {number} end End offset\r\n * @returns {Uint8Array} Buffer slice\r\n * @this {Uint8Array}\r\n */\r\n\r\n/**\r\n * A general purpose buffer pool.\r\n * @memberof util\r\n * @function\r\n * @param {PoolAllocator} alloc Allocator\r\n * @param {PoolSlicer} slice Slicer\r\n * @param {number} [size=8192] Slab size\r\n * @returns {PoolAllocator} Pooled allocator\r\n */\r\nfunction pool(alloc, slice, size) {\r\n    var SIZE   = size || 8192;\r\n    var MAX    = SIZE >>> 1;\r\n    var slab   = null;\r\n    var offset = SIZE;\r\n    return function pool_alloc(size) {\r\n        if (size < 1 || size > MAX)\r\n            return alloc(size);\r\n        if (offset + size > SIZE) {\r\n            slab = alloc(SIZE);\r\n            offset = 0;\r\n        }\r\n        var buf = slice.call(slab, offset, offset += size);\r\n        if (offset & 7) // align to 32 bit\r\n            offset = (offset | 7) + 1;\r\n        return buf;\r\n    };\r\n}\r\n", "\"use strict\";\nmodule.exports = LongBits;\n\nvar util = require(\"../util/minimal\");\n\n/**\n * Constructs new long bits.\n * @classdesc Helper class for working with the low and high bits of a 64 bit value.\n * @memberof util\n * @constructor\n * @param {number} lo Low 32 bits, unsigned\n * @param {number} hi High 32 bits, unsigned\n */\nfunction LongBits(lo, hi) {\n\n    // note that the casts below are theoretically unnecessary as of today, but older statically\n    // generated converter code might still call the ctor with signed 32bits. kept for compat.\n\n    /**\n     * Low bits.\n     * @type {number}\n     */\n    this.lo = lo >>> 0;\n\n    /**\n     * High bits.\n     * @type {number}\n     */\n    this.hi = hi >>> 0;\n}\n\n/**\n * Zero bits.\n * @memberof util.LongBits\n * @type {util.LongBits}\n */\nvar zero = LongBits.zero = new LongBits(0, 0);\n\nzero.toNumber = function() { return 0; };\nzero.zzEncode = zero.zzDecode = function() { return this; };\nzero.length = function() { return 1; };\n\n/**\n * Zero hash.\n * @memberof util.LongBits\n * @type {string}\n */\nvar zeroHash = LongBits.zeroHash = \"\\0\\0\\0\\0\\0\\0\\0\\0\";\n\n/**\n * Constructs new long bits from the specified number.\n * @param {number} value Value\n * @returns {util.LongBits} Instance\n */\nLongBits.fromNumber = function fromNumber(value) {\n    if (value === 0)\n        return zero;\n    var sign = value < 0;\n    if (sign)\n        value = -value;\n    var lo = value >>> 0,\n        hi = (value - lo) / 4294967296 >>> 0;\n    if (sign) {\n        hi = ~hi >>> 0;\n        lo = ~lo >>> 0;\n        if (++lo > 4294967295) {\n            lo = 0;\n            if (++hi > 4294967295)\n                hi = 0;\n        }\n    }\n    return new LongBits(lo, hi);\n};\n\n/**\n * Constructs new long bits from a number, long or string.\n * @param {Long|number|string} value Value\n * @returns {util.LongBits} Instance\n */\nLongBits.from = function from(value) {\n    if (typeof value === \"number\")\n        return LongBits.fromNumber(value);\n    if (util.isString(value)) {\n        /* istanbul ignore else */\n        if (util.Long)\n            value = util.Long.fromString(value);\n        else\n            return LongBits.fromNumber(parseInt(value, 10));\n    }\n    return value.low || value.high ? new LongBits(value.low >>> 0, value.high >>> 0) : zero;\n};\n\n/**\n * Converts this long bits to a possibly unsafe JavaScript number.\n * @param {boolean} [unsigned=false] Whether unsigned or not\n * @returns {number} Possibly unsafe number\n */\nLongBits.prototype.toNumber = function toNumber(unsigned) {\n    if (!unsigned && this.hi >>> 31) {\n        var lo = ~this.lo + 1 >>> 0,\n            hi = ~this.hi     >>> 0;\n        if (!lo)\n            hi = hi + 1 >>> 0;\n        return -(lo + hi * 4294967296);\n    }\n    return this.lo + this.hi * 4294967296;\n};\n\n/**\n * Converts this long bits to a long.\n * @param {boolean} [unsigned=false] Whether unsigned or not\n * @returns {Long} Long\n */\nLongBits.prototype.toLong = function toLong(unsigned) {\n    return util.Long\n        ? new util.Long(this.lo | 0, this.hi | 0, Boolean(unsigned))\n        /* istanbul ignore next */\n        : { low: this.lo | 0, high: this.hi | 0, unsigned: Boolean(unsigned) };\n};\n\nvar charCodeAt = String.prototype.charCodeAt;\n\n/**\n * Constructs new long bits from the specified 8 characters long hash.\n * @param {string} hash Hash\n * @returns {util.LongBits} Bits\n */\nLongBits.fromHash = function fromHash(hash) {\n    if (hash === zeroHash)\n        return zero;\n    return new LongBits(\n        ( charCodeAt.call(hash, 0)\n        | charCodeAt.call(hash, 1) << 8\n        | charCodeAt.call(hash, 2) << 16\n        | charCodeAt.call(hash, 3) << 24) >>> 0\n    ,\n        ( charCodeAt.call(hash, 4)\n        | charCodeAt.call(hash, 5) << 8\n        | charCodeAt.call(hash, 6) << 16\n        | charCodeAt.call(hash, 7) << 24) >>> 0\n    );\n};\n\n/**\n * Converts this long bits to a 8 characters long hash.\n * @returns {string} Hash\n */\nLongBits.prototype.toHash = function toHash() {\n    return String.fromCharCode(\n        this.lo        & 255,\n        this.lo >>> 8  & 255,\n        this.lo >>> 16 & 255,\n        this.lo >>> 24      ,\n        this.hi        & 255,\n        this.hi >>> 8  & 255,\n        this.hi >>> 16 & 255,\n        this.hi >>> 24\n    );\n};\n\n/**\n * Zig-zag encodes this long bits.\n * @returns {util.LongBits} `this`\n */\nLongBits.prototype.zzEncode = function zzEncode() {\n    var mask =   this.hi >> 31;\n    this.hi  = ((this.hi << 1 | this.lo >>> 31) ^ mask) >>> 0;\n    this.lo  = ( this.lo << 1                   ^ mask) >>> 0;\n    return this;\n};\n\n/**\n * Zig-zag decodes this long bits.\n * @returns {util.LongBits} `this`\n */\nLongBits.prototype.zzDecode = function zzDecode() {\n    var mask = -(this.lo & 1);\n    this.lo  = ((this.lo >>> 1 | this.hi << 31) ^ mask) >>> 0;\n    this.hi  = ( this.hi >>> 1                  ^ mask) >>> 0;\n    return this;\n};\n\n/**\n * Calculates the length of this longbits when encoded as a varint.\n * @returns {number} Length\n */\nLongBits.prototype.length = function length() {\n    var part0 =  this.lo,\n        part1 = (this.lo >>> 28 | this.hi << 4) >>> 0,\n        part2 =  this.hi >>> 24;\n    return part2 === 0\n         ? part1 === 0\n           ? part0 < 16384\n             ? part0 < 128 ? 1 : 2\n             : part0 < 2097152 ? 3 : 4\n           : part1 < 16384\n             ? part1 < 128 ? 5 : 6\n             : part1 < 2097152 ? 7 : 8\n         : part2 < 128 ? 9 : 10;\n};\n", "\"use strict\";\nvar util = exports;\n\n// used to return a Promise where callback is omitted\nutil.asPromise = require(\"@protobufjs/aspromise\");\n\n// converts to / from base64 encoded strings\nutil.base64 = require(\"@protobufjs/base64\");\n\n// base class of rpc.Service\nutil.EventEmitter = require(\"@protobufjs/eventemitter\");\n\n// float handling accross browsers\nutil.float = require(\"@protobufjs/float\");\n\n// requires modules optionally and hides the call from bundlers\nutil.inquire = require(\"@protobufjs/inquire\");\n\n// converts to / from utf8 encoded strings\nutil.utf8 = require(\"@protobufjs/utf8\");\n\n// provides a node-like buffer pool in the browser\nutil.pool = require(\"@protobufjs/pool\");\n\n// utility to work with the low and high bits of a 64 bit value\nutil.LongBits = require(\"./longbits\");\n\n/**\n * Whether running within node or not.\n * @memberof util\n * @type {boolean}\n */\nutil.isNode = Boolean(typeof global !== \"undefined\"\n                   && global\n                   && global.process\n                   && global.process.versions\n                   && global.process.versions.node);\n\n/**\n * Global object reference.\n * @memberof util\n * @type {Object}\n */\nutil.global = util.isNode && global\n           || typeof window !== \"undefined\" && window\n           || typeof self   !== \"undefined\" && self\n           || this; // eslint-disable-line no-invalid-this\n\n/**\n * An immuable empty array.\n * @memberof util\n * @type {Array.<*>}\n * @const\n */\nutil.emptyArray = Object.freeze ? Object.freeze([]) : /* istanbul ignore next */ []; // used on prototypes\n\n/**\n * An immutable empty object.\n * @type {Object}\n * @const\n */\nutil.emptyObject = Object.freeze ? Object.freeze({}) : /* istanbul ignore next */ {}; // used on prototypes\n\n/**\n * Tests if the specified value is an integer.\n * @function\n * @param {*} value Value to test\n * @returns {boolean} `true` if the value is an integer\n */\nutil.isInteger = Number.isInteger || /* istanbul ignore next */ function isInteger(value) {\n    return typeof value === \"number\" && isFinite(value) && Math.floor(value) === value;\n};\n\n/**\n * Tests if the specified value is a string.\n * @param {*} value Value to test\n * @returns {boolean} `true` if the value is a string\n */\nutil.isString = function isString(value) {\n    return typeof value === \"string\" || value instanceof String;\n};\n\n/**\n * Tests if the specified value is a non-null object.\n * @param {*} value Value to test\n * @returns {boolean} `true` if the value is a non-null object\n */\nutil.isObject = function isObject(value) {\n    return value && typeof value === \"object\";\n};\n\n/**\n * Checks if a property on a message is considered to be present.\n * This is an alias of {@link util.isSet}.\n * @function\n * @param {Object} obj Plain object or message instance\n * @param {string} prop Property name\n * @returns {boolean} `true` if considered to be present, otherwise `false`\n */\nutil.isset =\n\n/**\n * Checks if a property on a message is considered to be present.\n * @param {Object} obj Plain object or message instance\n * @param {string} prop Property name\n * @returns {boolean} `true` if considered to be present, otherwise `false`\n */\nutil.isSet = function isSet(obj, prop) {\n    var value = obj[prop];\n    if (value != null && obj.hasOwnProperty(prop)) // eslint-disable-line eqeqeq, no-prototype-builtins\n        return typeof value !== \"object\" || (Array.isArray(value) ? value.length : Object.keys(value).length) > 0;\n    return false;\n};\n\n/**\n * Any compatible Buffer instance.\n * This is a minimal stand-alone definition of a Buffer instance. The actual type is that exported by node's typings.\n * @interface Buffer\n * @extends Uint8Array\n */\n\n/**\n * Node's Buffer class if available.\n * @type {Constructor<Buffer>}\n */\nutil.Buffer = (function() {\n    try {\n        var Buffer = util.inquire(\"buffer\").Buffer;\n        // refuse to use non-node buffers if not explicitly assigned (perf reasons):\n        return Buffer.prototype.utf8Write ? Buffer : /* istanbul ignore next */ null;\n    } catch (e) {\n        /* istanbul ignore next */\n        return null;\n    }\n})();\n\n// Internal alias of or polyfull for Buffer.from.\nutil._Buffer_from = null;\n\n// Internal alias of or polyfill for Buffer.allocUnsafe.\nutil._Buffer_allocUnsafe = null;\n\n/**\n * Creates a new buffer of whatever type supported by the environment.\n * @param {number|number[]} [sizeOrArray=0] Buffer size or number array\n * @returns {Uint8Array|Buffer} Buffer\n */\nutil.newBuffer = function newBuffer(sizeOrArray) {\n    /* istanbul ignore next */\n    return typeof sizeOrArray === \"number\"\n        ? util.Buffer\n            ? util._Buffer_allocUnsafe(sizeOrArray)\n            : new util.Array(sizeOrArray)\n        : util.Buffer\n            ? util._Buffer_from(sizeOrArray)\n            : typeof Uint8Array === \"undefined\"\n                ? sizeOrArray\n                : new Uint8Array(sizeOrArray);\n};\n\n/**\n * Array implementation used in the browser. `Uint8Array` if supported, otherwise `Array`.\n * @type {Constructor<Uint8Array>}\n */\nutil.Array = typeof Uint8Array !== \"undefined\" ? Uint8Array /* istanbul ignore next */ : Array;\n\n/**\n * Any compatible Long instance.\n * This is a minimal stand-alone definition of a Long instance. The actual type is that exported by long.js.\n * @interface Long\n * @property {number} low Low bits\n * @property {number} high High bits\n * @property {boolean} unsigned Whether unsigned or not\n */\n\n/**\n * Long.js's Long class if available.\n * @type {Constructor<Long>}\n */\nutil.Long = /* istanbul ignore next */ util.global.dcodeIO && /* istanbul ignore next */ util.global.dcodeIO.Long\n         || /* istanbul ignore next */ util.global.Long\n         || util.inquire(\"long\");\n\n/**\n * Regular expression used to verify 2 bit (`bool`) map keys.\n * @type {RegExp}\n * @const\n */\nutil.key2Re = /^true|false|0|1$/;\n\n/**\n * Regular expression used to verify 32 bit (`int32` etc.) map keys.\n * @type {RegExp}\n * @const\n */\nutil.key32Re = /^-?(?:0|[1-9][0-9]*)$/;\n\n/**\n * Regular expression used to verify 64 bit (`int64` etc.) map keys.\n * @type {RegExp}\n * @const\n */\nutil.key64Re = /^(?:[\\\\x00-\\\\xff]{8}|-?(?:0|[1-9][0-9]*))$/;\n\n/**\n * Converts a number or long to an 8 characters long hash string.\n * @param {Long|number} value Value to convert\n * @returns {string} Hash\n */\nutil.longToHash = function longToHash(value) {\n    return value\n        ? util.LongBits.from(value).toHash()\n        : util.LongBits.zeroHash;\n};\n\n/**\n * Converts an 8 characters long hash string to a long or number.\n * @param {string} hash Hash\n * @param {boolean} [unsigned=false] Whether unsigned or not\n * @returns {Long|number} Original value\n */\nutil.longFromHash = function longFromHash(hash, unsigned) {\n    var bits = util.LongBits.fromHash(hash);\n    if (util.Long)\n        return util.Long.fromBits(bits.lo, bits.hi, unsigned);\n    return bits.toNumber(Boolean(unsigned));\n};\n\n/**\n * Merges the properties of the source object into the destination object.\n * @memberof util\n * @param {Object.<string,*>} dst Destination object\n * @param {Object.<string,*>} src Source object\n * @param {boolean} [ifNotSet=false] Merges only if the key is not already set\n * @returns {Object.<string,*>} Destination object\n */\nfunction merge(dst, src, ifNotSet) { // used by converters\n    for (var keys = Object.keys(src), i = 0; i < keys.length; ++i)\n        if (dst[keys[i]] === undefined || !ifNotSet)\n            dst[keys[i]] = src[keys[i]];\n    return dst;\n}\n\nutil.merge = merge;\n\n/**\n * Converts the first character of a string to lower case.\n * @param {string} str String to convert\n * @returns {string} Converted string\n */\nutil.lcFirst = function lcFirst(str) {\n    return str.charAt(0).toLowerCase() + str.substring(1);\n};\n\n/**\n * Creates a custom error constructor.\n * @memberof util\n * @param {string} name Error name\n * @returns {Constructor<Error>} Custom error constructor\n */\nfunction newError(name) {\n\n    function CustomError(message, properties) {\n\n        if (!(this instanceof CustomError))\n            return new CustomError(message, properties);\n\n        // Error.call(this, message);\n        // ^ just returns a new error instance because the ctor can be called as a function\n\n        Object.defineProperty(this, \"message\", { get: function() { return message; } });\n\n        /* istanbul ignore next */\n        if (Error.captureStackTrace) // node\n            Error.captureStackTrace(this, CustomError);\n        else\n            Object.defineProperty(this, \"stack\", { value: new Error().stack || \"\" });\n\n        if (properties)\n            merge(this, properties);\n    }\n\n    CustomError.prototype = Object.create(Error.prototype, {\n        constructor: {\n            value: CustomError,\n            writable: true,\n            enumerable: false,\n            configurable: true,\n        },\n        name: {\n            get: function get() { return name; },\n            set: undefined,\n            enumerable: false,\n            // configurable: false would accurately preserve the behavior of\n            // the original, but I'm guessing that was not intentional.\n            // For an actual error subclass, this property would\n            // be configurable.\n            configurable: true,\n        },\n        toString: {\n            value: function value() { return this.name + \": \" + this.message; },\n            writable: true,\n            enumerable: false,\n            configurable: true,\n        },\n    });\n\n    return CustomError;\n}\n\nutil.newError = newError;\n\n/**\n * Constructs a new protocol error.\n * @classdesc Error subclass indicating a protocol specifc error.\n * @memberof util\n * @extends Error\n * @template T extends Message<T>\n * @constructor\n * @param {string} message Error message\n * @param {Object.<string,*>} [properties] Additional properties\n * @example\n * try {\n *     MyMessage.decode(someBuffer); // throws if required fields are missing\n * } catch (e) {\n *     if (e instanceof ProtocolError && e.instance)\n *         console.log(\"decoded so far: \" + JSON.stringify(e.instance));\n * }\n */\nutil.ProtocolError = newError(\"ProtocolError\");\n\n/**\n * So far decoded message instance.\n * @name util.ProtocolError#instance\n * @type {Message<T>}\n */\n\n/**\n * A OneOf getter as returned by {@link util.oneOfGetter}.\n * @typedef OneOfGetter\n * @type {function}\n * @returns {string|undefined} Set field name, if any\n */\n\n/**\n * Builds a getter for a oneof's present field name.\n * @param {string[]} fieldNames Field names\n * @returns {OneOfGetter} Unbound getter\n */\nutil.oneOfGetter = function getOneOf(fieldNames) {\n    var fieldMap = {};\n    for (var i = 0; i < fieldNames.length; ++i)\n        fieldMap[fieldNames[i]] = 1;\n\n    /**\n     * @returns {string|undefined} Set field name, if any\n     * @this Object\n     * @ignore\n     */\n    return function() { // eslint-disable-line consistent-return\n        for (var keys = Object.keys(this), i = keys.length - 1; i > -1; --i)\n            if (fieldMap[keys[i]] === 1 && this[keys[i]] !== undefined && this[keys[i]] !== null)\n                return keys[i];\n    };\n};\n\n/**\n * A OneOf setter as returned by {@link util.oneOfSetter}.\n * @typedef OneOfSetter\n * @type {function}\n * @param {string|undefined} value Field name\n * @returns {undefined}\n */\n\n/**\n * Builds a setter for a oneof's present field name.\n * @param {string[]} fieldNames Field names\n * @returns {OneOfSetter} Unbound setter\n */\nutil.oneOfSetter = function setOneOf(fieldNames) {\n\n    /**\n     * @param {string} name Field name\n     * @returns {undefined}\n     * @this Object\n     * @ignore\n     */\n    return function(name) {\n        for (var i = 0; i < fieldNames.length; ++i)\n            if (fieldNames[i] !== name)\n                delete this[fieldNames[i]];\n    };\n};\n\n/**\n * Default conversion options used for {@link Message#toJSON} implementations.\n *\n * These options are close to proto3's JSON mapping with the exception that internal types like Any are handled just like messages. More precisely:\n *\n * - Longs become strings\n * - Enums become string keys\n * - Bytes become base64 encoded strings\n * - (Sub-)Messages become plain objects\n * - Maps become plain objects with all string keys\n * - Repeated fields become arrays\n * - NaN and Infinity for float and double fields become strings\n *\n * @type {IConversionOptions}\n * @see https://developers.google.com/protocol-buffers/docs/proto3?hl=en#json\n */\nutil.toJSONOptions = {\n    longs: String,\n    enums: String,\n    bytes: String,\n    json: true\n};\n\n// Sets up buffer utility according to the environment (called in index-minimal)\nutil._configure = function() {\n    var Buffer = util.Buffer;\n    /* istanbul ignore if */\n    if (!Buffer) {\n        util._Buffer_from = util._Buffer_allocUnsafe = null;\n        return;\n    }\n    // because node 4.x buffers are incompatible & immutable\n    // see: https://github.com/dcodeIO/protobuf.js/pull/665\n    util._Buffer_from = Buffer.from !== Uint8Array.from && Buffer.from ||\n        /* istanbul ignore next */\n        function Buffer_from(value, encoding) {\n            return new Buffer(value, encoding);\n        };\n    util._Buffer_allocUnsafe = Buffer.allocUnsafe ||\n        /* istanbul ignore next */\n        function Buffer_allocUnsafe(size) {\n            return new Buffer(size);\n        };\n};\n", "\"use strict\";\nmodule.exports = Writer;\n\nvar util      = require(\"./util/minimal\");\n\nvar BufferWriter; // cyclic\n\nvar LongBits  = util.LongBits,\n    base64    = util.base64,\n    utf8      = util.utf8;\n\n/**\n * Constructs a new writer operation instance.\n * @classdesc Scheduled writer operation.\n * @constructor\n * @param {function(*, Uint8Array, number)} fn Function to call\n * @param {number} len Value byte length\n * @param {*} val Value to write\n * @ignore\n */\nfunction Op(fn, len, val) {\n\n    /**\n     * Function to call.\n     * @type {function(Uint8Array, number, *)}\n     */\n    this.fn = fn;\n\n    /**\n     * Value byte length.\n     * @type {number}\n     */\n    this.len = len;\n\n    /**\n     * Next operation.\n     * @type {Writer.Op|undefined}\n     */\n    this.next = undefined;\n\n    /**\n     * Value to write.\n     * @type {*}\n     */\n    this.val = val; // type varies\n}\n\n/* istanbul ignore next */\nfunction noop() {} // eslint-disable-line no-empty-function\n\n/**\n * Constructs a new writer state instance.\n * @classdesc Copied writer state.\n * @memberof Writer\n * @constructor\n * @param {Writer} writer Writer to copy state from\n * @ignore\n */\nfunction State(writer) {\n\n    /**\n     * Current head.\n     * @type {Writer.Op}\n     */\n    this.head = writer.head;\n\n    /**\n     * Current tail.\n     * @type {Writer.Op}\n     */\n    this.tail = writer.tail;\n\n    /**\n     * Current buffer length.\n     * @type {number}\n     */\n    this.len = writer.len;\n\n    /**\n     * Next state.\n     * @type {State|null}\n     */\n    this.next = writer.states;\n}\n\n/**\n * Constructs a new writer instance.\n * @classdesc Wire format writer using `Uint8Array` if available, otherwise `Array`.\n * @constructor\n */\nfunction Writer() {\n\n    /**\n     * Current length.\n     * @type {number}\n     */\n    this.len = 0;\n\n    /**\n     * Operations head.\n     * @type {Object}\n     */\n    this.head = new Op(noop, 0, 0);\n\n    /**\n     * Operations tail\n     * @type {Object}\n     */\n    this.tail = this.head;\n\n    /**\n     * Linked forked states.\n     * @type {Object|null}\n     */\n    this.states = null;\n\n    // When a value is written, the writer calculates its byte length and puts it into a linked\n    // list of operations to perform when finish() is called. This both allows us to allocate\n    // buffers of the exact required size and reduces the amount of work we have to do compared\n    // to first calculating over objects and then encoding over objects. In our case, the encoding\n    // part is just a linked list walk calling operations with already prepared values.\n}\n\nvar create = function create() {\n    return util.Buffer\n        ? function create_buffer_setup() {\n            return (Writer.create = function create_buffer() {\n                return new BufferWriter();\n            })();\n        }\n        /* istanbul ignore next */\n        : function create_array() {\n            return new Writer();\n        };\n};\n\n/**\n * Creates a new writer.\n * @function\n * @returns {BufferWriter|Writer} A {@link BufferWriter} when Buffers are supported, otherwise a {@link Writer}\n */\nWriter.create = create();\n\n/**\n * Allocates a buffer of the specified size.\n * @param {number} size Buffer size\n * @returns {Uint8Array} Buffer\n */\nWriter.alloc = function alloc(size) {\n    return new util.Array(size);\n};\n\n// Use Uint8Array buffer pool in the browser, just like node does with buffers\n/* istanbul ignore else */\nif (util.Array !== Array)\n    Writer.alloc = util.pool(Writer.alloc, util.Array.prototype.subarray);\n\n/**\n * Pushes a new operation to the queue.\n * @param {function(Uint8Array, number, *)} fn Function to call\n * @param {number} len Value byte length\n * @param {number} val Value to write\n * @returns {Writer} `this`\n * @private\n */\nWriter.prototype._push = function push(fn, len, val) {\n    this.tail = this.tail.next = new Op(fn, len, val);\n    this.len += len;\n    return this;\n};\n\nfunction writeByte(val, buf, pos) {\n    buf[pos] = val & 255;\n}\n\nfunction writeVarint32(val, buf, pos) {\n    while (val > 127) {\n        buf[pos++] = val & 127 | 128;\n        val >>>= 7;\n    }\n    buf[pos] = val;\n}\n\n/**\n * Constructs a new varint writer operation instance.\n * @classdesc Scheduled varint writer operation.\n * @extends Op\n * @constructor\n * @param {number} len Value byte length\n * @param {number} val Value to write\n * @ignore\n */\nfunction VarintOp(len, val) {\n    this.len = len;\n    this.next = undefined;\n    this.val = val;\n}\n\nVarintOp.prototype = Object.create(Op.prototype);\nVarintOp.prototype.fn = writeVarint32;\n\n/**\n * Writes an unsigned 32 bit value as a varint.\n * @param {number} value Value to write\n * @returns {Writer} `this`\n */\nWriter.prototype.uint32 = function write_uint32(value) {\n    // here, the call to this.push has been inlined and a varint specific Op subclass is used.\n    // uint32 is by far the most frequently used operation and benefits significantly from this.\n    this.len += (this.tail = this.tail.next = new VarintOp(\n        (value = value >>> 0)\n                < 128       ? 1\n        : value < 16384     ? 2\n        : value < 2097152   ? 3\n        : value < 268435456 ? 4\n        :                     5,\n    value)).len;\n    return this;\n};\n\n/**\n * Writes a signed 32 bit value as a varint.\n * @function\n * @param {number} value Value to write\n * @returns {Writer} `this`\n */\nWriter.prototype.int32 = function write_int32(value) {\n    return value < 0\n        ? this._push(writeVarint64, 10, LongBits.fromNumber(value)) // 10 bytes per spec\n        : this.uint32(value);\n};\n\n/**\n * Writes a 32 bit value as a varint, zig-zag encoded.\n * @param {number} value Value to write\n * @returns {Writer} `this`\n */\nWriter.prototype.sint32 = function write_sint32(value) {\n    return this.uint32((value << 1 ^ value >> 31) >>> 0);\n};\n\nfunction writeVarint64(val, buf, pos) {\n    while (val.hi) {\n        buf[pos++] = val.lo & 127 | 128;\n        val.lo = (val.lo >>> 7 | val.hi << 25) >>> 0;\n        val.hi >>>= 7;\n    }\n    while (val.lo > 127) {\n        buf[pos++] = val.lo & 127 | 128;\n        val.lo = val.lo >>> 7;\n    }\n    buf[pos++] = val.lo;\n}\n\n/**\n * Writes an unsigned 64 bit value as a varint.\n * @param {Long|number|string} value Value to write\n * @returns {Writer} `this`\n * @throws {TypeError} If `value` is a string and no long library is present.\n */\nWriter.prototype.uint64 = function write_uint64(value) {\n    var bits = LongBits.from(value);\n    return this._push(writeVarint64, bits.length(), bits);\n};\n\n/**\n * Writes a signed 64 bit value as a varint.\n * @function\n * @param {Long|number|string} value Value to write\n * @returns {Writer} `this`\n * @throws {TypeError} If `value` is a string and no long library is present.\n */\nWriter.prototype.int64 = Writer.prototype.uint64;\n\n/**\n * Writes a signed 64 bit value as a varint, zig-zag encoded.\n * @param {Long|number|string} value Value to write\n * @returns {Writer} `this`\n * @throws {TypeError} If `value` is a string and no long library is present.\n */\nWriter.prototype.sint64 = function write_sint64(value) {\n    var bits = LongBits.from(value).zzEncode();\n    return this._push(writeVarint64, bits.length(), bits);\n};\n\n/**\n * Writes a boolish value as a varint.\n * @param {boolean} value Value to write\n * @returns {Writer} `this`\n */\nWriter.prototype.bool = function write_bool(value) {\n    return this._push(writeByte, 1, value ? 1 : 0);\n};\n\nfunction writeFixed32(val, buf, pos) {\n    buf[pos    ] =  val         & 255;\n    buf[pos + 1] =  val >>> 8   & 255;\n    buf[pos + 2] =  val >>> 16  & 255;\n    buf[pos + 3] =  val >>> 24;\n}\n\n/**\n * Writes an unsigned 32 bit value as fixed 32 bits.\n * @param {number} value Value to write\n * @returns {Writer} `this`\n */\nWriter.prototype.fixed32 = function write_fixed32(value) {\n    return this._push(writeFixed32, 4, value >>> 0);\n};\n\n/**\n * Writes a signed 32 bit value as fixed 32 bits.\n * @function\n * @param {number} value Value to write\n * @returns {Writer} `this`\n */\nWriter.prototype.sfixed32 = Writer.prototype.fixed32;\n\n/**\n * Writes an unsigned 64 bit value as fixed 64 bits.\n * @param {Long|number|string} value Value to write\n * @returns {Writer} `this`\n * @throws {TypeError} If `value` is a string and no long library is present.\n */\nWriter.prototype.fixed64 = function write_fixed64(value) {\n    var bits = LongBits.from(value);\n    return this._push(writeFixed32, 4, bits.lo)._push(writeFixed32, 4, bits.hi);\n};\n\n/**\n * Writes a signed 64 bit value as fixed 64 bits.\n * @function\n * @param {Long|number|string} value Value to write\n * @returns {Writer} `this`\n * @throws {TypeError} If `value` is a string and no long library is present.\n */\nWriter.prototype.sfixed64 = Writer.prototype.fixed64;\n\n/**\n * Writes a float (32 bit).\n * @function\n * @param {number} value Value to write\n * @returns {Writer} `this`\n */\nWriter.prototype.float = function write_float(value) {\n    return this._push(util.float.writeFloatLE, 4, value);\n};\n\n/**\n * Writes a double (64 bit float).\n * @function\n * @param {number} value Value to write\n * @returns {Writer} `this`\n */\nWriter.prototype.double = function write_double(value) {\n    return this._push(util.float.writeDoubleLE, 8, value);\n};\n\nvar writeBytes = util.Array.prototype.set\n    ? function writeBytes_set(val, buf, pos) {\n        buf.set(val, pos); // also works for plain array values\n    }\n    /* istanbul ignore next */\n    : function writeBytes_for(val, buf, pos) {\n        for (var i = 0; i < val.length; ++i)\n            buf[pos + i] = val[i];\n    };\n\n/**\n * Writes a sequence of bytes.\n * @param {Uint8Array|string} value Buffer or base64 encoded string to write\n * @returns {Writer} `this`\n */\nWriter.prototype.bytes = function write_bytes(value) {\n    var len = value.length >>> 0;\n    if (!len)\n        return this._push(writeByte, 1, 0);\n    if (util.isString(value)) {\n        var buf = Writer.alloc(len = base64.length(value));\n        base64.decode(value, buf, 0);\n        value = buf;\n    }\n    return this.uint32(len)._push(writeBytes, len, value);\n};\n\n/**\n * Writes a string.\n * @param {string} value Value to write\n * @returns {Writer} `this`\n */\nWriter.prototype.string = function write_string(value) {\n    var len = utf8.length(value);\n    return len\n        ? this.uint32(len)._push(utf8.write, len, value)\n        : this._push(writeByte, 1, 0);\n};\n\n/**\n * Forks this writer's state by pushing it to a stack.\n * Calling {@link Writer#reset|reset} or {@link Writer#ldelim|ldelim} resets the writer to the previous state.\n * @returns {Writer} `this`\n */\nWriter.prototype.fork = function fork() {\n    this.states = new State(this);\n    this.head = this.tail = new Op(noop, 0, 0);\n    this.len = 0;\n    return this;\n};\n\n/**\n * Resets this instance to the last state.\n * @returns {Writer} `this`\n */\nWriter.prototype.reset = function reset() {\n    if (this.states) {\n        this.head   = this.states.head;\n        this.tail   = this.states.tail;\n        this.len    = this.states.len;\n        this.states = this.states.next;\n    } else {\n        this.head = this.tail = new Op(noop, 0, 0);\n        this.len  = 0;\n    }\n    return this;\n};\n\n/**\n * Resets to the last state and appends the fork state's current write length as a varint followed by its operations.\n * @returns {Writer} `this`\n */\nWriter.prototype.ldelim = function ldelim() {\n    var head = this.head,\n        tail = this.tail,\n        len  = this.len;\n    this.reset().uint32(len);\n    if (len) {\n        this.tail.next = head.next; // skip noop\n        this.tail = tail;\n        this.len += len;\n    }\n    return this;\n};\n\n/**\n * Finishes the write operation.\n * @returns {Uint8Array} Finished buffer\n */\nWriter.prototype.finish = function finish() {\n    var head = this.head.next, // skip noop\n        buf  = this.constructor.alloc(this.len),\n        pos  = 0;\n    while (head) {\n        head.fn(head.val, buf, pos);\n        pos += head.len;\n        head = head.next;\n    }\n    // this.head = this.tail = null;\n    return buf;\n};\n\nWriter._configure = function(BufferWriter_) {\n    BufferWriter = BufferWriter_;\n    Writer.create = create();\n    BufferWriter._configure();\n};\n", "\"use strict\";\nmodule.exports = BufferWriter;\n\n// extends Writer\nvar Writer = require(\"./writer\");\n(BufferWriter.prototype = Object.create(Writer.prototype)).constructor = BufferWriter;\n\nvar util = require(\"./util/minimal\");\n\n/**\n * Constructs a new buffer writer instance.\n * @classdesc Wire format writer using node buffers.\n * @extends Writer\n * @constructor\n */\nfunction BufferWriter() {\n    Writer.call(this);\n}\n\nBufferWriter._configure = function () {\n    /**\n     * Allocates a buffer of the specified size.\n     * @function\n     * @param {number} size Buffer size\n     * @returns {Buffer} Buffer\n     */\n    BufferWriter.alloc = util._Buffer_allocUnsafe;\n\n    BufferWriter.writeBytesBuffer = util.Buffer && util.Buffer.prototype instanceof Uint8Array && util.Buffer.prototype.set.name === \"set\"\n        ? function writeBytesBuffer_set(val, buf, pos) {\n          buf.set(val, pos); // faster than copy (requires node >= 4 where Buffers extend Uint8Array and set is properly inherited)\n          // also works for plain array values\n        }\n        /* istanbul ignore next */\n        : function writeBytesBuffer_copy(val, buf, pos) {\n          if (val.copy) // Buffer values\n            val.copy(buf, pos, 0, val.length);\n          else for (var i = 0; i < val.length;) // plain array values\n            buf[pos++] = val[i++];\n        };\n};\n\n\n/**\n * @override\n */\nBufferWriter.prototype.bytes = function write_bytes_buffer(value) {\n    if (util.isString(value))\n        value = util._Buffer_from(value, \"base64\");\n    var len = value.length >>> 0;\n    this.uint32(len);\n    if (len)\n        this._push(BufferWriter.writeBytesBuffer, len, value);\n    return this;\n};\n\nfunction writeStringBuffer(val, buf, pos) {\n    if (val.length < 40) // plain js is faster for short strings (probably due to redundant assertions)\n        util.utf8.write(val, buf, pos);\n    else if (buf.utf8Write)\n        buf.utf8Write(val, pos);\n    else\n        buf.write(val, pos);\n}\n\n/**\n * @override\n */\nBufferWriter.prototype.string = function write_string_buffer(value) {\n    var len = util.Buffer.byteLength(value);\n    this.uint32(len);\n    if (len)\n        this._push(writeStringBuffer, len, value);\n    return this;\n};\n\n\n/**\n * Finishes the write operation.\n * @name BufferWriter#finish\n * @function\n * @returns {Buffer} Finished buffer\n */\n\nBufferWriter._configure();\n", "\"use strict\";\nmodule.exports = Reader;\n\nvar util      = require(\"./util/minimal\");\n\nvar BufferReader; // cyclic\n\nvar LongBits  = util.LongBits,\n    utf8      = util.utf8;\n\n/* istanbul ignore next */\nfunction indexOutOfRange(reader, writeLength) {\n    return RangeError(\"index out of range: \" + reader.pos + \" + \" + (writeLength || 1) + \" > \" + reader.len);\n}\n\n/**\n * Constructs a new reader instance using the specified buffer.\n * @classdesc Wire format reader using `Uint8Array` if available, otherwise `Array`.\n * @constructor\n * @param {Uint8Array} buffer Buffer to read from\n */\nfunction Reader(buffer) {\n\n    /**\n     * Read buffer.\n     * @type {Uint8Array}\n     */\n    this.buf = buffer;\n\n    /**\n     * Read buffer position.\n     * @type {number}\n     */\n    this.pos = 0;\n\n    /**\n     * Read buffer length.\n     * @type {number}\n     */\n    this.len = buffer.length;\n}\n\nvar create_array = typeof Uint8Array !== \"undefined\"\n    ? function create_typed_array(buffer) {\n        if (buffer instanceof Uint8Array || Array.isArray(buffer))\n            return new Reader(buffer);\n        throw Error(\"illegal buffer\");\n    }\n    /* istanbul ignore next */\n    : function create_array(buffer) {\n        if (Array.isArray(buffer))\n            return new Reader(buffer);\n        throw Error(\"illegal buffer\");\n    };\n\nvar create = function create() {\n    return util.Buffer\n        ? function create_buffer_setup(buffer) {\n            return (Reader.create = function create_buffer(buffer) {\n                return util.Buffer.isBuffer(buffer)\n                    ? new BufferReader(buffer)\n                    /* istanbul ignore next */\n                    : create_array(buffer);\n            })(buffer);\n        }\n        /* istanbul ignore next */\n        : create_array;\n};\n\n/**\n * Creates a new reader using the specified buffer.\n * @function\n * @param {Uint8Array|Buffer} buffer Buffer to read from\n * @returns {Reader|BufferReader} A {@link BufferReader} if `buffer` is a Buffer, otherwise a {@link Reader}\n * @throws {Error} If `buffer` is not a valid buffer\n */\nReader.create = create();\n\nReader.prototype._slice = util.Array.prototype.subarray || /* istanbul ignore next */ util.Array.prototype.slice;\n\n/**\n * Reads a varint as an unsigned 32 bit value.\n * @function\n * @returns {number} Value read\n */\nReader.prototype.uint32 = (function read_uint32_setup() {\n    var value = 4294967295; // optimizer type-hint, tends to deopt otherwise (?!)\n    return function read_uint32() {\n        value = (         this.buf[this.pos] & 127       ) >>> 0; if (this.buf[this.pos++] < 128) return value;\n        value = (value | (this.buf[this.pos] & 127) <<  7) >>> 0; if (this.buf[this.pos++] < 128) return value;\n        value = (value | (this.buf[this.pos] & 127) << 14) >>> 0; if (this.buf[this.pos++] < 128) return value;\n        value = (value | (this.buf[this.pos] & 127) << 21) >>> 0; if (this.buf[this.pos++] < 128) return value;\n        value = (value | (this.buf[this.pos] &  15) << 28) >>> 0; if (this.buf[this.pos++] < 128) return value;\n\n        /* istanbul ignore if */\n        if ((this.pos += 5) > this.len) {\n            this.pos = this.len;\n            throw indexOutOfRange(this, 10);\n        }\n        return value;\n    };\n})();\n\n/**\n * Reads a varint as a signed 32 bit value.\n * @returns {number} Value read\n */\nReader.prototype.int32 = function read_int32() {\n    return this.uint32() | 0;\n};\n\n/**\n * Reads a zig-zag encoded varint as a signed 32 bit value.\n * @returns {number} Value read\n */\nReader.prototype.sint32 = function read_sint32() {\n    var value = this.uint32();\n    return value >>> 1 ^ -(value & 1) | 0;\n};\n\n/* eslint-disable no-invalid-this */\n\nfunction readLongVarint() {\n    // tends to deopt with local vars for octet etc.\n    var bits = new LongBits(0, 0);\n    var i = 0;\n    if (this.len - this.pos > 4) { // fast route (lo)\n        for (; i < 4; ++i) {\n            // 1st..4th\n            bits.lo = (bits.lo | (this.buf[this.pos] & 127) << i * 7) >>> 0;\n            if (this.buf[this.pos++] < 128)\n                return bits;\n        }\n        // 5th\n        bits.lo = (bits.lo | (this.buf[this.pos] & 127) << 28) >>> 0;\n        bits.hi = (bits.hi | (this.buf[this.pos] & 127) >>  4) >>> 0;\n        if (this.buf[this.pos++] < 128)\n            return bits;\n        i = 0;\n    } else {\n        for (; i < 3; ++i) {\n            /* istanbul ignore if */\n            if (this.pos >= this.len)\n                throw indexOutOfRange(this);\n            // 1st..3th\n            bits.lo = (bits.lo | (this.buf[this.pos] & 127) << i * 7) >>> 0;\n            if (this.buf[this.pos++] < 128)\n                return bits;\n        }\n        // 4th\n        bits.lo = (bits.lo | (this.buf[this.pos++] & 127) << i * 7) >>> 0;\n        return bits;\n    }\n    if (this.len - this.pos > 4) { // fast route (hi)\n        for (; i < 5; ++i) {\n            // 6th..10th\n            bits.hi = (bits.hi | (this.buf[this.pos] & 127) << i * 7 + 3) >>> 0;\n            if (this.buf[this.pos++] < 128)\n                return bits;\n        }\n    } else {\n        for (; i < 5; ++i) {\n            /* istanbul ignore if */\n            if (this.pos >= this.len)\n                throw indexOutOfRange(this);\n            // 6th..10th\n            bits.hi = (bits.hi | (this.buf[this.pos] & 127) << i * 7 + 3) >>> 0;\n            if (this.buf[this.pos++] < 128)\n                return bits;\n        }\n    }\n    /* istanbul ignore next */\n    throw Error(\"invalid varint encoding\");\n}\n\n/* eslint-enable no-invalid-this */\n\n/**\n * Reads a varint as a signed 64 bit value.\n * @name Reader#int64\n * @function\n * @returns {Long} Value read\n */\n\n/**\n * Reads a varint as an unsigned 64 bit value.\n * @name Reader#uint64\n * @function\n * @returns {Long} Value read\n */\n\n/**\n * Reads a zig-zag encoded varint as a signed 64 bit value.\n * @name Reader#sint64\n * @function\n * @returns {Long} Value read\n */\n\n/**\n * Reads a varint as a boolean.\n * @returns {boolean} Value read\n */\nReader.prototype.bool = function read_bool() {\n    return this.uint32() !== 0;\n};\n\nfunction readFixed32_end(buf, end) { // note that this uses `end`, not `pos`\n    return (buf[end - 4]\n          | buf[end - 3] << 8\n          | buf[end - 2] << 16\n          | buf[end - 1] << 24) >>> 0;\n}\n\n/**\n * Reads fixed 32 bits as an unsigned 32 bit integer.\n * @returns {number} Value read\n */\nReader.prototype.fixed32 = function read_fixed32() {\n\n    /* istanbul ignore if */\n    if (this.pos + 4 > this.len)\n        throw indexOutOfRange(this, 4);\n\n    return readFixed32_end(this.buf, this.pos += 4);\n};\n\n/**\n * Reads fixed 32 bits as a signed 32 bit integer.\n * @returns {number} Value read\n */\nReader.prototype.sfixed32 = function read_sfixed32() {\n\n    /* istanbul ignore if */\n    if (this.pos + 4 > this.len)\n        throw indexOutOfRange(this, 4);\n\n    return readFixed32_end(this.buf, this.pos += 4) | 0;\n};\n\n/* eslint-disable no-invalid-this */\n\nfunction readFixed64(/* this: Reader */) {\n\n    /* istanbul ignore if */\n    if (this.pos + 8 > this.len)\n        throw indexOutOfRange(this, 8);\n\n    return new LongBits(readFixed32_end(this.buf, this.pos += 4), readFixed32_end(this.buf, this.pos += 4));\n}\n\n/* eslint-enable no-invalid-this */\n\n/**\n * Reads fixed 64 bits.\n * @name Reader#fixed64\n * @function\n * @returns {Long} Value read\n */\n\n/**\n * Reads zig-zag encoded fixed 64 bits.\n * @name Reader#sfixed64\n * @function\n * @returns {Long} Value read\n */\n\n/**\n * Reads a float (32 bit) as a number.\n * @function\n * @returns {number} Value read\n */\nReader.prototype.float = function read_float() {\n\n    /* istanbul ignore if */\n    if (this.pos + 4 > this.len)\n        throw indexOutOfRange(this, 4);\n\n    var value = util.float.readFloatLE(this.buf, this.pos);\n    this.pos += 4;\n    return value;\n};\n\n/**\n * Reads a double (64 bit float) as a number.\n * @function\n * @returns {number} Value read\n */\nReader.prototype.double = function read_double() {\n\n    /* istanbul ignore if */\n    if (this.pos + 8 > this.len)\n        throw indexOutOfRange(this, 4);\n\n    var value = util.float.readDoubleLE(this.buf, this.pos);\n    this.pos += 8;\n    return value;\n};\n\n/**\n * Reads a sequence of bytes preceeded by its length as a varint.\n * @returns {Uint8Array} Value read\n */\nReader.prototype.bytes = function read_bytes() {\n    var length = this.uint32(),\n        start  = this.pos,\n        end    = this.pos + length;\n\n    /* istanbul ignore if */\n    if (end > this.len)\n        throw indexOutOfRange(this, length);\n\n    this.pos += length;\n    if (Array.isArray(this.buf)) // plain array\n        return this.buf.slice(start, end);\n\n    if (start === end) { // fix for IE 10/Win8 and others' subarray returning array of size 1\n        var nativeBuffer = util.Buffer;\n        return nativeBuffer\n            ? nativeBuffer.alloc(0)\n            : new this.buf.constructor(0);\n    }\n    return this._slice.call(this.buf, start, end);\n};\n\n/**\n * Reads a string preceeded by its byte length as a varint.\n * @returns {string} Value read\n */\nReader.prototype.string = function read_string() {\n    var bytes = this.bytes();\n    return utf8.read(bytes, 0, bytes.length);\n};\n\n/**\n * Skips the specified number of bytes if specified, otherwise skips a varint.\n * @param {number} [length] Length if known, otherwise a varint is assumed\n * @returns {Reader} `this`\n */\nReader.prototype.skip = function skip(length) {\n    if (typeof length === \"number\") {\n        /* istanbul ignore if */\n        if (this.pos + length > this.len)\n            throw indexOutOfRange(this, length);\n        this.pos += length;\n    } else {\n        do {\n            /* istanbul ignore if */\n            if (this.pos >= this.len)\n                throw indexOutOfRange(this);\n        } while (this.buf[this.pos++] & 128);\n    }\n    return this;\n};\n\n/**\n * Skips the next element of the specified wire type.\n * @param {number} wireType Wire type received\n * @returns {Reader} `this`\n */\nReader.prototype.skipType = function(wireType) {\n    switch (wireType) {\n        case 0:\n            this.skip();\n            break;\n        case 1:\n            this.skip(8);\n            break;\n        case 2:\n            this.skip(this.uint32());\n            break;\n        case 3:\n            while ((wireType = this.uint32() & 7) !== 4) {\n                this.skipType(wireType);\n            }\n            break;\n        case 5:\n            this.skip(4);\n            break;\n\n        /* istanbul ignore next */\n        default:\n            throw Error(\"invalid wire type \" + wireType + \" at offset \" + this.pos);\n    }\n    return this;\n};\n\nReader._configure = function(BufferReader_) {\n    BufferReader = BufferReader_;\n    Reader.create = create();\n    BufferReader._configure();\n\n    var fn = util.Long ? \"toLong\" : /* istanbul ignore next */ \"toNumber\";\n    util.merge(Reader.prototype, {\n\n        int64: function read_int64() {\n            return readLongVarint.call(this)[fn](false);\n        },\n\n        uint64: function read_uint64() {\n            return readLongVarint.call(this)[fn](true);\n        },\n\n        sint64: function read_sint64() {\n            return readLongVarint.call(this).zzDecode()[fn](false);\n        },\n\n        fixed64: function read_fixed64() {\n            return readFixed64.call(this)[fn](true);\n        },\n\n        sfixed64: function read_sfixed64() {\n            return readFixed64.call(this)[fn](false);\n        }\n\n    });\n};\n", "\"use strict\";\nmodule.exports = BufferReader;\n\n// extends Reader\nvar Reader = require(\"./reader\");\n(BufferReader.prototype = Object.create(Reader.prototype)).constructor = BufferReader;\n\nvar util = require(\"./util/minimal\");\n\n/**\n * Constructs a new buffer reader instance.\n * @classdesc Wire format reader using node buffers.\n * @extends Reader\n * @constructor\n * @param {Buffer} buffer Buffer to read from\n */\nfunction BufferReader(buffer) {\n    Reader.call(this, buffer);\n\n    /**\n     * Read buffer.\n     * @name BufferReader#buf\n     * @type {Buffer}\n     */\n}\n\nBufferReader._configure = function () {\n    /* istanbul ignore else */\n    if (util.Buffer)\n        BufferReader.prototype._slice = util.Buffer.prototype.slice;\n};\n\n\n/**\n * @override\n */\nBufferReader.prototype.string = function read_string_buffer() {\n    var len = this.uint32(); // modifies pos\n    return this.buf.utf8Slice\n        ? this.buf.utf8Slice(this.pos, this.pos = Math.min(this.pos + len, this.len))\n        : this.buf.toString(\"utf-8\", this.pos, this.pos = Math.min(this.pos + len, this.len));\n};\n\n/**\n * Reads a sequence of bytes preceeded by its length as a varint.\n * @name BufferReader#bytes\n * @function\n * @returns {Buffer} Value read\n */\n\nBufferReader._configure();\n", "\"use strict\";\nmodule.exports = Service;\n\nvar util = require(\"../util/minimal\");\n\n// Extends EventEmitter\n(Service.prototype = Object.create(util.EventEmitter.prototype)).constructor = Service;\n\n/**\n * A service method callback as used by {@link rpc.ServiceMethod|ServiceMethod}.\n *\n * Differs from {@link RPCImplCallback} in that it is an actual callback of a service method which may not return `response = null`.\n * @typedef rpc.ServiceMethodCallback\n * @template TRes extends Message<TRes>\n * @type {function}\n * @param {Error|null} error Error, if any\n * @param {TRes} [response] Response message\n * @returns {undefined}\n */\n\n/**\n * A service method part of a {@link rpc.Service} as created by {@link Service.create}.\n * @typedef rpc.ServiceMethod\n * @template TReq extends Message<TReq>\n * @template TRes extends Message<TRes>\n * @type {function}\n * @param {TReq|Properties<TReq>} request Request message or plain object\n * @param {rpc.ServiceMethodCallback<TRes>} [callback] Node-style callback called with the error, if any, and the response message\n * @returns {Promise<Message<TRes>>} Promise if `callback` has been omitted, otherwise `undefined`\n */\n\n/**\n * Constructs a new RPC service instance.\n * @classdesc An RPC service as returned by {@link Service#create}.\n * @exports rpc.Service\n * @extends util.EventEmitter\n * @constructor\n * @param {RPCImpl} rpcImpl RPC implementation\n * @param {boolean} [requestDelimited=false] Whether requests are length-delimited\n * @param {boolean} [responseDelimited=false] Whether responses are length-delimited\n */\nfunction Service(rpcImpl, requestDelimited, responseDelimited) {\n\n    if (typeof rpcImpl !== \"function\")\n        throw TypeError(\"rpcImpl must be a function\");\n\n    util.EventEmitter.call(this);\n\n    /**\n     * RPC implementation. Becomes `null` once the service is ended.\n     * @type {RPCImpl|null}\n     */\n    this.rpcImpl = rpcImpl;\n\n    /**\n     * Whether requests are length-delimited.\n     * @type {boolean}\n     */\n    this.requestDelimited = Boolean(requestDelimited);\n\n    /**\n     * Whether responses are length-delimited.\n     * @type {boolean}\n     */\n    this.responseDelimited = Boolean(responseDelimited);\n}\n\n/**\n * Calls a service method through {@link rpc.Service#rpcImpl|rpcImpl}.\n * @param {Method|rpc.ServiceMethod<TReq,TRes>} method Reflected or static method\n * @param {Constructor<TReq>} requestCtor Request constructor\n * @param {Constructor<TRes>} responseCtor Response constructor\n * @param {TReq|Properties<TReq>} request Request message or plain object\n * @param {rpc.ServiceMethodCallback<TRes>} callback Service callback\n * @returns {undefined}\n * @template TReq extends Message<TReq>\n * @template TRes extends Message<TRes>\n */\nService.prototype.rpcCall = function rpcCall(method, requestCtor, responseCtor, request, callback) {\n\n    if (!request)\n        throw TypeError(\"request must be specified\");\n\n    var self = this;\n    if (!callback)\n        return util.asPromise(rpcCall, self, method, requestCtor, responseCtor, request);\n\n    if (!self.rpcImpl) {\n        setTimeout(function() { callback(Error(\"already ended\")); }, 0);\n        return undefined;\n    }\n\n    try {\n        return self.rpcImpl(\n            method,\n            requestCtor[self.requestDelimited ? \"encodeDelimited\" : \"encode\"](request).finish(),\n            function rpcCallback(err, response) {\n\n                if (err) {\n                    self.emit(\"error\", err, method);\n                    return callback(err);\n                }\n\n                if (response === null) {\n                    self.end(/* endedByRPC */ true);\n                    return undefined;\n                }\n\n                if (!(response instanceof responseCtor)) {\n                    try {\n                        response = responseCtor[self.responseDelimited ? \"decodeDelimited\" : \"decode\"](response);\n                    } catch (err) {\n                        self.emit(\"error\", err, method);\n                        return callback(err);\n                    }\n                }\n\n                self.emit(\"data\", response, method);\n                return callback(null, response);\n            }\n        );\n    } catch (err) {\n        self.emit(\"error\", err, method);\n        setTimeout(function() { callback(err); }, 0);\n        return undefined;\n    }\n};\n\n/**\n * Ends this service and emits the `end` event.\n * @param {boolean} [endedByRPC=false] Whether the service has been ended by the RPC implementation.\n * @returns {rpc.Service} `this`\n */\nService.prototype.end = function end(endedByRPC) {\n    if (this.rpcImpl) {\n        if (!endedByRPC) // signal end to rpcImpl\n            this.rpcImpl(null, null, null);\n        this.rpcImpl = null;\n        this.emit(\"end\").off();\n    }\n    return this;\n};\n", "\"use strict\";\n\n/**\n * Streaming RPC helpers.\n * @namespace\n */\nvar rpc = exports;\n\n/**\n * RPC implementation passed to {@link Service#create} performing a service request on network level, i.e. by utilizing http requests or websockets.\n * @typedef RPCImpl\n * @type {function}\n * @param {Method|rpc.ServiceMethod<Message<{}>,Message<{}>>} method Reflected or static method being called\n * @param {Uint8Array} requestData Request data\n * @param {RPCImplCallback} callback Callback function\n * @returns {undefined}\n * @example\n * function rpcImpl(method, requestData, callback) {\n *     if (protobuf.util.lcFirst(method.name) !== \"myMethod\") // compatible with static code\n *         throw Error(\"no such method\");\n *     asynchronouslyObtainAResponse(requestData, function(err, responseData) {\n *         callback(err, responseData);\n *     });\n * }\n */\n\n/**\n * Node-style callback as used by {@link RPCImpl}.\n * @typedef RPCImplCallback\n * @type {function}\n * @param {Error|null} error Error, if any, otherwise `null`\n * @param {Uint8Array|null} [response] Response data or `null` to signal end of stream, if there hasn't been an error\n * @returns {undefined}\n */\n\nrpc.Service = require(\"./rpc/service\");\n", "\"use strict\";\nmodule.exports = {};\n\n/**\n * Named roots.\n * This is where pbjs stores generated structures (the option `-r, --root` specifies a name).\n * Can also be used manually to make roots available across modules.\n * @name roots\n * @type {Object.<string,Root>}\n * @example\n * // pbjs -r myroot -o compiled.js ...\n *\n * // in another module:\n * require(\"./compiled.js\");\n *\n * // in any subsequent module:\n * var root = protobuf.roots[\"myroot\"];\n */\n", "\"use strict\";\nvar protobuf = exports;\n\n/**\n * Build type, one of `\"full\"`, `\"light\"` or `\"minimal\"`.\n * @name build\n * @type {string}\n * @const\n */\nprotobuf.build = \"minimal\";\n\n// Serialization\nprotobuf.Writer       = require(\"./writer\");\nprotobuf.BufferWriter = require(\"./writer_buffer\");\nprotobuf.Reader       = require(\"./reader\");\nprotobuf.BufferReader = require(\"./reader_buffer\");\n\n// Utility\nprotobuf.util         = require(\"./util/minimal\");\nprotobuf.rpc          = require(\"./rpc\");\nprotobuf.roots        = require(\"./roots\");\nprotobuf.configure    = configure;\n\n/* istanbul ignore next */\n/**\n * Reconfigures the library according to the environment.\n * @returns {undefined}\n */\nfunction configure() {\n    protobuf.util._configure();\n    protobuf.Writer._configure(protobuf.BufferWriter);\n    protobuf.Reader._configure(protobuf.BufferReader);\n}\n\n// Set up buffer utility according to the environment\nconfigure();\n", "// minimal library entry point.\n\n\"use strict\";\nmodule.exports = require(\"./src/index-minimal\");\n", "// @ts-nocheck\n/*eslint-disable*/\n(function(global, factory) { /* global define, require, module */\n\n    /* AMD */ if (typeof define === 'function' && define.amd)\n        define([\"protobufjs/minimal\"], factory);\n\n    /* CommonJS */ else if (typeof require === 'function' && typeof module === 'object' && module && module.exports)\n        module.exports = factory(require(\"protobufjs/minimal\"));\n\n})(this, function($protobuf) {\n    \"use strict\";\n\n    // Common aliases\n    var $Reader = $protobuf.Reader, $Writer = $protobuf.Writer, $util = $protobuf.util;\n\n    // Exported root namespace\n    var $root = $protobuf.roots[\"default\"] || ($protobuf.roots[\"default\"] = {});\n\n    $root.RPC = (function() {\n\n        /**\n         * Properties of a RPC.\n         * @exports IRPC\n         * @interface IRPC\n         * @property {Array.<RPC.ISubOpts>|null} [subscriptions] RPC subscriptions\n         * @property {Array.<RPC.IMessage>|null} [messages] RPC messages\n         * @property {RPC.IControlMessage|null} [control] RPC control\n         */\n\n        /**\n         * Constructs a new RPC.\n         * @exports RPC\n         * @classdesc Represents a RPC.\n         * @implements IRPC\n         * @constructor\n         * @param {IRPC=} [p] Properties to set\n         */\n        function RPC(p) {\n            this.subscriptions = [];\n            this.messages = [];\n            if (p)\n                for (var ks = Object.keys(p), i = 0; i < ks.length; ++i)\n                    if (p[ks[i]] != null)\n                        this[ks[i]] = p[ks[i]];\n        }\n\n        /**\n         * RPC subscriptions.\n         * @member {Array.<RPC.ISubOpts>} subscriptions\n         * @memberof RPC\n         * @instance\n         */\n        RPC.prototype.subscriptions = $util.emptyArray;\n\n        /**\n         * RPC messages.\n         * @member {Array.<RPC.IMessage>} messages\n         * @memberof RPC\n         * @instance\n         */\n        RPC.prototype.messages = $util.emptyArray;\n\n        /**\n         * RPC control.\n         * @member {RPC.IControlMessage|null|undefined} control\n         * @memberof RPC\n         * @instance\n         */\n        RPC.prototype.control = null;\n\n        // OneOf field names bound to virtual getters and setters\n        var $oneOfFields;\n\n        /**\n         * RPC _control.\n         * @member {\"control\"|undefined} _control\n         * @memberof RPC\n         * @instance\n         */\n        Object.defineProperty(RPC.prototype, \"_control\", {\n            get: $util.oneOfGetter($oneOfFields = [\"control\"]),\n            set: $util.oneOfSetter($oneOfFields)\n        });\n\n        /**\n         * Encodes the specified RPC message. Does not implicitly {@link RPC.verify|verify} messages.\n         * @function encode\n         * @memberof RPC\n         * @static\n         * @param {IRPC} m RPC message or plain object to encode\n         * @param {$protobuf.Writer} [w] Writer to encode to\n         * @returns {$protobuf.Writer} Writer\n         */\n        RPC.encode = function encode(m, w) {\n            if (!w)\n                w = $Writer.create();\n            if (m.subscriptions != null && m.subscriptions.length) {\n                for (var i = 0; i < m.subscriptions.length; ++i)\n                    $root.RPC.SubOpts.encode(m.subscriptions[i], w.uint32(10).fork()).ldelim();\n            }\n            if (m.messages != null && m.messages.length) {\n                for (var i = 0; i < m.messages.length; ++i)\n                    $root.RPC.Message.encode(m.messages[i], w.uint32(18).fork()).ldelim();\n            }\n            if (m.control != null && Object.hasOwnProperty.call(m, \"control\"))\n                $root.RPC.ControlMessage.encode(m.control, w.uint32(26).fork()).ldelim();\n            return w;\n        };\n\n        /**\n         * Decodes a RPC message from the specified reader or buffer.\n         * @function decode\n         * @memberof RPC\n         * @static\n         * @param {$protobuf.Reader|Uint8Array} r Reader or buffer to decode from\n         * @param {number} [l] Message length if known beforehand\n         * @returns {RPC} RPC\n         * @throws {Error} If the payload is not a reader or valid buffer\n         * @throws {$protobuf.util.ProtocolError} If required fields are missing\n         */\n        RPC.decode = function decode(r, l) {\n            if (!(r instanceof $Reader))\n                r = $Reader.create(r);\n            var c = l === undefined ? r.len : r.pos + l, m = new $root.RPC();\n            while (r.pos < c) {\n                var t = r.uint32();\n                switch (t >>> 3) {\n                case 1:\n                    if (!(m.subscriptions && m.subscriptions.length))\n                        m.subscriptions = [];\n                    m.subscriptions.push($root.RPC.SubOpts.decode(r, r.uint32()));\n                    break;\n                case 2:\n                    if (!(m.messages && m.messages.length))\n                        m.messages = [];\n                    m.messages.push($root.RPC.Message.decode(r, r.uint32()));\n                    break;\n                case 3:\n                    m.control = $root.RPC.ControlMessage.decode(r, r.uint32());\n                    break;\n                default:\n                    r.skipType(t & 7);\n                    break;\n                }\n            }\n            return m;\n        };\n\n        /**\n         * Creates a RPC message from a plain object. Also converts values to their respective internal types.\n         * @function fromObject\n         * @memberof RPC\n         * @static\n         * @param {Object.<string,*>} d Plain object\n         * @returns {RPC} RPC\n         */\n        RPC.fromObject = function fromObject(d) {\n            if (d instanceof $root.RPC)\n                return d;\n            var m = new $root.RPC();\n            if (d.subscriptions) {\n                if (!Array.isArray(d.subscriptions))\n                    throw TypeError(\".RPC.subscriptions: array expected\");\n                m.subscriptions = [];\n                for (var i = 0; i < d.subscriptions.length; ++i) {\n                    if (typeof d.subscriptions[i] !== \"object\")\n                        throw TypeError(\".RPC.subscriptions: object expected\");\n                    m.subscriptions[i] = $root.RPC.SubOpts.fromObject(d.subscriptions[i]);\n                }\n            }\n            if (d.messages) {\n                if (!Array.isArray(d.messages))\n                    throw TypeError(\".RPC.messages: array expected\");\n                m.messages = [];\n                for (var i = 0; i < d.messages.length; ++i) {\n                    if (typeof d.messages[i] !== \"object\")\n                        throw TypeError(\".RPC.messages: object expected\");\n                    m.messages[i] = $root.RPC.Message.fromObject(d.messages[i]);\n                }\n            }\n            if (d.control != null) {\n                if (typeof d.control !== \"object\")\n                    throw TypeError(\".RPC.control: object expected\");\n                m.control = $root.RPC.ControlMessage.fromObject(d.control);\n            }\n            return m;\n        };\n\n        /**\n         * Creates a plain object from a RPC message. Also converts values to other types if specified.\n         * @function toObject\n         * @memberof RPC\n         * @static\n         * @param {RPC} m RPC\n         * @param {$protobuf.IConversionOptions} [o] Conversion options\n         * @returns {Object.<string,*>} Plain object\n         */\n        RPC.toObject = function toObject(m, o) {\n            if (!o)\n                o = {};\n            var d = {};\n            if (o.arrays || o.defaults) {\n                d.subscriptions = [];\n                d.messages = [];\n            }\n            if (m.subscriptions && m.subscriptions.length) {\n                d.subscriptions = [];\n                for (var j = 0; j < m.subscriptions.length; ++j) {\n                    d.subscriptions[j] = $root.RPC.SubOpts.toObject(m.subscriptions[j], o);\n                }\n            }\n            if (m.messages && m.messages.length) {\n                d.messages = [];\n                for (var j = 0; j < m.messages.length; ++j) {\n                    d.messages[j] = $root.RPC.Message.toObject(m.messages[j], o);\n                }\n            }\n            if (m.control != null && m.hasOwnProperty(\"control\")) {\n                d.control = $root.RPC.ControlMessage.toObject(m.control, o);\n                if (o.oneofs)\n                    d._control = \"control\";\n            }\n            return d;\n        };\n\n        /**\n         * Converts this RPC to JSON.\n         * @function toJSON\n         * @memberof RPC\n         * @instance\n         * @returns {Object.<string,*>} JSON object\n         */\n        RPC.prototype.toJSON = function toJSON() {\n            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);\n        };\n\n        RPC.SubOpts = (function() {\n\n            /**\n             * Properties of a SubOpts.\n             * @memberof RPC\n             * @interface ISubOpts\n             * @property {boolean|null} [subscribe] SubOpts subscribe\n             * @property {string|null} [topic] SubOpts topic\n             */\n\n            /**\n             * Constructs a new SubOpts.\n             * @memberof RPC\n             * @classdesc Represents a SubOpts.\n             * @implements ISubOpts\n             * @constructor\n             * @param {RPC.ISubOpts=} [p] Properties to set\n             */\n            function SubOpts(p) {\n                if (p)\n                    for (var ks = Object.keys(p), i = 0; i < ks.length; ++i)\n                        if (p[ks[i]] != null)\n                            this[ks[i]] = p[ks[i]];\n            }\n\n            /**\n             * SubOpts subscribe.\n             * @member {boolean|null|undefined} subscribe\n             * @memberof RPC.SubOpts\n             * @instance\n             */\n            SubOpts.prototype.subscribe = null;\n\n            /**\n             * SubOpts topic.\n             * @member {string|null|undefined} topic\n             * @memberof RPC.SubOpts\n             * @instance\n             */\n            SubOpts.prototype.topic = null;\n\n            // OneOf field names bound to virtual getters and setters\n            var $oneOfFields;\n\n            /**\n             * SubOpts _subscribe.\n             * @member {\"subscribe\"|undefined} _subscribe\n             * @memberof RPC.SubOpts\n             * @instance\n             */\n            Object.defineProperty(SubOpts.prototype, \"_subscribe\", {\n                get: $util.oneOfGetter($oneOfFields = [\"subscribe\"]),\n                set: $util.oneOfSetter($oneOfFields)\n            });\n\n            /**\n             * SubOpts _topic.\n             * @member {\"topic\"|undefined} _topic\n             * @memberof RPC.SubOpts\n             * @instance\n             */\n            Object.defineProperty(SubOpts.prototype, \"_topic\", {\n                get: $util.oneOfGetter($oneOfFields = [\"topic\"]),\n                set: $util.oneOfSetter($oneOfFields)\n            });\n\n            /**\n             * Encodes the specified SubOpts message. Does not implicitly {@link RPC.SubOpts.verify|verify} messages.\n             * @function encode\n             * @memberof RPC.SubOpts\n             * @static\n             * @param {RPC.ISubOpts} m SubOpts message or plain object to encode\n             * @param {$protobuf.Writer} [w] Writer to encode to\n             * @returns {$protobuf.Writer} Writer\n             */\n            SubOpts.encode = function encode(m, w) {\n                if (!w)\n                    w = $Writer.create();\n                if (m.subscribe != null && Object.hasOwnProperty.call(m, \"subscribe\"))\n                    w.uint32(8).bool(m.subscribe);\n                if (m.topic != null && Object.hasOwnProperty.call(m, \"topic\"))\n                    w.uint32(18).string(m.topic);\n                return w;\n            };\n\n            /**\n             * Decodes a SubOpts message from the specified reader or buffer.\n             * @function decode\n             * @memberof RPC.SubOpts\n             * @static\n             * @param {$protobuf.Reader|Uint8Array} r Reader or buffer to decode from\n             * @param {number} [l] Message length if known beforehand\n             * @returns {RPC.SubOpts} SubOpts\n             * @throws {Error} If the payload is not a reader or valid buffer\n             * @throws {$protobuf.util.ProtocolError} If required fields are missing\n             */\n            SubOpts.decode = function decode(r, l) {\n                if (!(r instanceof $Reader))\n                    r = $Reader.create(r);\n                var c = l === undefined ? r.len : r.pos + l, m = new $root.RPC.SubOpts();\n                while (r.pos < c) {\n                    var t = r.uint32();\n                    switch (t >>> 3) {\n                    case 1:\n                        m.subscribe = r.bool();\n                        break;\n                    case 2:\n                        m.topic = r.string();\n                        break;\n                    default:\n                        r.skipType(t & 7);\n                        break;\n                    }\n                }\n                return m;\n            };\n\n            /**\n             * Creates a SubOpts message from a plain object. Also converts values to their respective internal types.\n             * @function fromObject\n             * @memberof RPC.SubOpts\n             * @static\n             * @param {Object.<string,*>} d Plain object\n             * @returns {RPC.SubOpts} SubOpts\n             */\n            SubOpts.fromObject = function fromObject(d) {\n                if (d instanceof $root.RPC.SubOpts)\n                    return d;\n                var m = new $root.RPC.SubOpts();\n                if (d.subscribe != null) {\n                    m.subscribe = Boolean(d.subscribe);\n                }\n                if (d.topic != null) {\n                    m.topic = String(d.topic);\n                }\n                return m;\n            };\n\n            /**\n             * Creates a plain object from a SubOpts message. Also converts values to other types if specified.\n             * @function toObject\n             * @memberof RPC.SubOpts\n             * @static\n             * @param {RPC.SubOpts} m SubOpts\n             * @param {$protobuf.IConversionOptions} [o] Conversion options\n             * @returns {Object.<string,*>} Plain object\n             */\n            SubOpts.toObject = function toObject(m, o) {\n                if (!o)\n                    o = {};\n                var d = {};\n                if (m.subscribe != null && m.hasOwnProperty(\"subscribe\")) {\n                    d.subscribe = m.subscribe;\n                    if (o.oneofs)\n                        d._subscribe = \"subscribe\";\n                }\n                if (m.topic != null && m.hasOwnProperty(\"topic\")) {\n                    d.topic = m.topic;\n                    if (o.oneofs)\n                        d._topic = \"topic\";\n                }\n                return d;\n            };\n\n            /**\n             * Converts this SubOpts to JSON.\n             * @function toJSON\n             * @memberof RPC.SubOpts\n             * @instance\n             * @returns {Object.<string,*>} JSON object\n             */\n            SubOpts.prototype.toJSON = function toJSON() {\n                return this.constructor.toObject(this, $protobuf.util.toJSONOptions);\n            };\n\n            return SubOpts;\n        })();\n\n        RPC.Message = (function() {\n\n            /**\n             * Properties of a Message.\n             * @memberof RPC\n             * @interface IMessage\n             * @property {Uint8Array|null} [from] Message from\n             * @property {Uint8Array|null} [data] Message data\n             * @property {Uint8Array|null} [seqno] Message seqno\n             * @property {string} topic Message topic\n             * @property {Uint8Array|null} [signature] Message signature\n             * @property {Uint8Array|null} [key] Message key\n             */\n\n            /**\n             * Constructs a new Message.\n             * @memberof RPC\n             * @classdesc Represents a Message.\n             * @implements IMessage\n             * @constructor\n             * @param {RPC.IMessage=} [p] Properties to set\n             */\n            function Message(p) {\n                if (p)\n                    for (var ks = Object.keys(p), i = 0; i < ks.length; ++i)\n                        if (p[ks[i]] != null)\n                            this[ks[i]] = p[ks[i]];\n            }\n\n            /**\n             * Message from.\n             * @member {Uint8Array|null|undefined} from\n             * @memberof RPC.Message\n             * @instance\n             */\n            Message.prototype.from = null;\n\n            /**\n             * Message data.\n             * @member {Uint8Array|null|undefined} data\n             * @memberof RPC.Message\n             * @instance\n             */\n            Message.prototype.data = null;\n\n            /**\n             * Message seqno.\n             * @member {Uint8Array|null|undefined} seqno\n             * @memberof RPC.Message\n             * @instance\n             */\n            Message.prototype.seqno = null;\n\n            /**\n             * Message topic.\n             * @member {string} topic\n             * @memberof RPC.Message\n             * @instance\n             */\n            Message.prototype.topic = \"\";\n\n            /**\n             * Message signature.\n             * @member {Uint8Array|null|undefined} signature\n             * @memberof RPC.Message\n             * @instance\n             */\n            Message.prototype.signature = null;\n\n            /**\n             * Message key.\n             * @member {Uint8Array|null|undefined} key\n             * @memberof RPC.Message\n             * @instance\n             */\n            Message.prototype.key = null;\n\n            // OneOf field names bound to virtual getters and setters\n            var $oneOfFields;\n\n            /**\n             * Message _from.\n             * @member {\"from\"|undefined} _from\n             * @memberof RPC.Message\n             * @instance\n             */\n            Object.defineProperty(Message.prototype, \"_from\", {\n                get: $util.oneOfGetter($oneOfFields = [\"from\"]),\n                set: $util.oneOfSetter($oneOfFields)\n            });\n\n            /**\n             * Message _data.\n             * @member {\"data\"|undefined} _data\n             * @memberof RPC.Message\n             * @instance\n             */\n            Object.defineProperty(Message.prototype, \"_data\", {\n                get: $util.oneOfGetter($oneOfFields = [\"data\"]),\n                set: $util.oneOfSetter($oneOfFields)\n            });\n\n            /**\n             * Message _seqno.\n             * @member {\"seqno\"|undefined} _seqno\n             * @memberof RPC.Message\n             * @instance\n             */\n            Object.defineProperty(Message.prototype, \"_seqno\", {\n                get: $util.oneOfGetter($oneOfFields = [\"seqno\"]),\n                set: $util.oneOfSetter($oneOfFields)\n            });\n\n            /**\n             * Message _signature.\n             * @member {\"signature\"|undefined} _signature\n             * @memberof RPC.Message\n             * @instance\n             */\n            Object.defineProperty(Message.prototype, \"_signature\", {\n                get: $util.oneOfGetter($oneOfFields = [\"signature\"]),\n                set: $util.oneOfSetter($oneOfFields)\n            });\n\n            /**\n             * Message _key.\n             * @member {\"key\"|undefined} _key\n             * @memberof RPC.Message\n             * @instance\n             */\n            Object.defineProperty(Message.prototype, \"_key\", {\n                get: $util.oneOfGetter($oneOfFields = [\"key\"]),\n                set: $util.oneOfSetter($oneOfFields)\n            });\n\n            /**\n             * Encodes the specified Message message. Does not implicitly {@link RPC.Message.verify|verify} messages.\n             * @function encode\n             * @memberof RPC.Message\n             * @static\n             * @param {RPC.IMessage} m Message message or plain object to encode\n             * @param {$protobuf.Writer} [w] Writer to encode to\n             * @returns {$protobuf.Writer} Writer\n             */\n            Message.encode = function encode(m, w) {\n                if (!w)\n                    w = $Writer.create();\n                if (m.from != null && Object.hasOwnProperty.call(m, \"from\"))\n                    w.uint32(10).bytes(m.from);\n                if (m.data != null && Object.hasOwnProperty.call(m, \"data\"))\n                    w.uint32(18).bytes(m.data);\n                if (m.seqno != null && Object.hasOwnProperty.call(m, \"seqno\"))\n                    w.uint32(26).bytes(m.seqno);\n                w.uint32(34).string(m.topic);\n                if (m.signature != null && Object.hasOwnProperty.call(m, \"signature\"))\n                    w.uint32(42).bytes(m.signature);\n                if (m.key != null && Object.hasOwnProperty.call(m, \"key\"))\n                    w.uint32(50).bytes(m.key);\n                return w;\n            };\n\n            /**\n             * Decodes a Message message from the specified reader or buffer.\n             * @function decode\n             * @memberof RPC.Message\n             * @static\n             * @param {$protobuf.Reader|Uint8Array} r Reader or buffer to decode from\n             * @param {number} [l] Message length if known beforehand\n             * @returns {RPC.Message} Message\n             * @throws {Error} If the payload is not a reader or valid buffer\n             * @throws {$protobuf.util.ProtocolError} If required fields are missing\n             */\n            Message.decode = function decode(r, l) {\n                if (!(r instanceof $Reader))\n                    r = $Reader.create(r);\n                var c = l === undefined ? r.len : r.pos + l, m = new $root.RPC.Message();\n                while (r.pos < c) {\n                    var t = r.uint32();\n                    switch (t >>> 3) {\n                    case 1:\n                        m.from = r.bytes();\n                        break;\n                    case 2:\n                        m.data = r.bytes();\n                        break;\n                    case 3:\n                        m.seqno = r.bytes();\n                        break;\n                    case 4:\n                        m.topic = r.string();\n                        break;\n                    case 5:\n                        m.signature = r.bytes();\n                        break;\n                    case 6:\n                        m.key = r.bytes();\n                        break;\n                    default:\n                        r.skipType(t & 7);\n                        break;\n                    }\n                }\n                if (!m.hasOwnProperty(\"topic\"))\n                    throw $util.ProtocolError(\"missing required 'topic'\", { instance: m });\n                return m;\n            };\n\n            /**\n             * Creates a Message message from a plain object. Also converts values to their respective internal types.\n             * @function fromObject\n             * @memberof RPC.Message\n             * @static\n             * @param {Object.<string,*>} d Plain object\n             * @returns {RPC.Message} Message\n             */\n            Message.fromObject = function fromObject(d) {\n                if (d instanceof $root.RPC.Message)\n                    return d;\n                var m = new $root.RPC.Message();\n                if (d.from != null) {\n                    if (typeof d.from === \"string\")\n                        $util.base64.decode(d.from, m.from = $util.newBuffer($util.base64.length(d.from)), 0);\n                    else if (d.from.length)\n                        m.from = d.from;\n                }\n                if (d.data != null) {\n                    if (typeof d.data === \"string\")\n                        $util.base64.decode(d.data, m.data = $util.newBuffer($util.base64.length(d.data)), 0);\n                    else if (d.data.length)\n                        m.data = d.data;\n                }\n                if (d.seqno != null) {\n                    if (typeof d.seqno === \"string\")\n                        $util.base64.decode(d.seqno, m.seqno = $util.newBuffer($util.base64.length(d.seqno)), 0);\n                    else if (d.seqno.length)\n                        m.seqno = d.seqno;\n                }\n                if (d.topic != null) {\n                    m.topic = String(d.topic);\n                }\n                if (d.signature != null) {\n                    if (typeof d.signature === \"string\")\n                        $util.base64.decode(d.signature, m.signature = $util.newBuffer($util.base64.length(d.signature)), 0);\n                    else if (d.signature.length)\n                        m.signature = d.signature;\n                }\n                if (d.key != null) {\n                    if (typeof d.key === \"string\")\n                        $util.base64.decode(d.key, m.key = $util.newBuffer($util.base64.length(d.key)), 0);\n                    else if (d.key.length)\n                        m.key = d.key;\n                }\n                return m;\n            };\n\n            /**\n             * Creates a plain object from a Message message. Also converts values to other types if specified.\n             * @function toObject\n             * @memberof RPC.Message\n             * @static\n             * @param {RPC.Message} m Message\n             * @param {$protobuf.IConversionOptions} [o] Conversion options\n             * @returns {Object.<string,*>} Plain object\n             */\n            Message.toObject = function toObject(m, o) {\n                if (!o)\n                    o = {};\n                var d = {};\n                if (o.defaults) {\n                    d.topic = \"\";\n                }\n                if (m.from != null && m.hasOwnProperty(\"from\")) {\n                    d.from = o.bytes === String ? $util.base64.encode(m.from, 0, m.from.length) : o.bytes === Array ? Array.prototype.slice.call(m.from) : m.from;\n                    if (o.oneofs)\n                        d._from = \"from\";\n                }\n                if (m.data != null && m.hasOwnProperty(\"data\")) {\n                    d.data = o.bytes === String ? $util.base64.encode(m.data, 0, m.data.length) : o.bytes === Array ? Array.prototype.slice.call(m.data) : m.data;\n                    if (o.oneofs)\n                        d._data = \"data\";\n                }\n                if (m.seqno != null && m.hasOwnProperty(\"seqno\")) {\n                    d.seqno = o.bytes === String ? $util.base64.encode(m.seqno, 0, m.seqno.length) : o.bytes === Array ? Array.prototype.slice.call(m.seqno) : m.seqno;\n                    if (o.oneofs)\n                        d._seqno = \"seqno\";\n                }\n                if (m.topic != null && m.hasOwnProperty(\"topic\")) {\n                    d.topic = m.topic;\n                }\n                if (m.signature != null && m.hasOwnProperty(\"signature\")) {\n                    d.signature = o.bytes === String ? $util.base64.encode(m.signature, 0, m.signature.length) : o.bytes === Array ? Array.prototype.slice.call(m.signature) : m.signature;\n                    if (o.oneofs)\n                        d._signature = \"signature\";\n                }\n                if (m.key != null && m.hasOwnProperty(\"key\")) {\n                    d.key = o.bytes === String ? $util.base64.encode(m.key, 0, m.key.length) : o.bytes === Array ? Array.prototype.slice.call(m.key) : m.key;\n                    if (o.oneofs)\n                        d._key = \"key\";\n                }\n                return d;\n            };\n\n            /**\n             * Converts this Message to JSON.\n             * @function toJSON\n             * @memberof RPC.Message\n             * @instance\n             * @returns {Object.<string,*>} JSON object\n             */\n            Message.prototype.toJSON = function toJSON() {\n                return this.constructor.toObject(this, $protobuf.util.toJSONOptions);\n            };\n\n            return Message;\n        })();\n\n        RPC.ControlMessage = (function() {\n\n            /**\n             * Properties of a ControlMessage.\n             * @memberof RPC\n             * @interface IControlMessage\n             * @property {Array.<RPC.IControlIHave>|null} [ihave] ControlMessage ihave\n             * @property {Array.<RPC.IControlIWant>|null} [iwant] ControlMessage iwant\n             * @property {Array.<RPC.IControlGraft>|null} [graft] ControlMessage graft\n             * @property {Array.<RPC.IControlPrune>|null} [prune] ControlMessage prune\n             */\n\n            /**\n             * Constructs a new ControlMessage.\n             * @memberof RPC\n             * @classdesc Represents a ControlMessage.\n             * @implements IControlMessage\n             * @constructor\n             * @param {RPC.IControlMessage=} [p] Properties to set\n             */\n            function ControlMessage(p) {\n                this.ihave = [];\n                this.iwant = [];\n                this.graft = [];\n                this.prune = [];\n                if (p)\n                    for (var ks = Object.keys(p), i = 0; i < ks.length; ++i)\n                        if (p[ks[i]] != null)\n                            this[ks[i]] = p[ks[i]];\n            }\n\n            /**\n             * ControlMessage ihave.\n             * @member {Array.<RPC.IControlIHave>} ihave\n             * @memberof RPC.ControlMessage\n             * @instance\n             */\n            ControlMessage.prototype.ihave = $util.emptyArray;\n\n            /**\n             * ControlMessage iwant.\n             * @member {Array.<RPC.IControlIWant>} iwant\n             * @memberof RPC.ControlMessage\n             * @instance\n             */\n            ControlMessage.prototype.iwant = $util.emptyArray;\n\n            /**\n             * ControlMessage graft.\n             * @member {Array.<RPC.IControlGraft>} graft\n             * @memberof RPC.ControlMessage\n             * @instance\n             */\n            ControlMessage.prototype.graft = $util.emptyArray;\n\n            /**\n             * ControlMessage prune.\n             * @member {Array.<RPC.IControlPrune>} prune\n             * @memberof RPC.ControlMessage\n             * @instance\n             */\n            ControlMessage.prototype.prune = $util.emptyArray;\n\n            /**\n             * Encodes the specified ControlMessage message. Does not implicitly {@link RPC.ControlMessage.verify|verify} messages.\n             * @function encode\n             * @memberof RPC.ControlMessage\n             * @static\n             * @param {RPC.IControlMessage} m ControlMessage message or plain object to encode\n             * @param {$protobuf.Writer} [w] Writer to encode to\n             * @returns {$protobuf.Writer} Writer\n             */\n            ControlMessage.encode = function encode(m, w) {\n                if (!w)\n                    w = $Writer.create();\n                if (m.ihave != null && m.ihave.length) {\n                    for (var i = 0; i < m.ihave.length; ++i)\n                        $root.RPC.ControlIHave.encode(m.ihave[i], w.uint32(10).fork()).ldelim();\n                }\n                if (m.iwant != null && m.iwant.length) {\n                    for (var i = 0; i < m.iwant.length; ++i)\n                        $root.RPC.ControlIWant.encode(m.iwant[i], w.uint32(18).fork()).ldelim();\n                }\n                if (m.graft != null && m.graft.length) {\n                    for (var i = 0; i < m.graft.length; ++i)\n                        $root.RPC.ControlGraft.encode(m.graft[i], w.uint32(26).fork()).ldelim();\n                }\n                if (m.prune != null && m.prune.length) {\n                    for (var i = 0; i < m.prune.length; ++i)\n                        $root.RPC.ControlPrune.encode(m.prune[i], w.uint32(34).fork()).ldelim();\n                }\n                return w;\n            };\n\n            /**\n             * Decodes a ControlMessage message from the specified reader or buffer.\n             * @function decode\n             * @memberof RPC.ControlMessage\n             * @static\n             * @param {$protobuf.Reader|Uint8Array} r Reader or buffer to decode from\n             * @param {number} [l] Message length if known beforehand\n             * @returns {RPC.ControlMessage} ControlMessage\n             * @throws {Error} If the payload is not a reader or valid buffer\n             * @throws {$protobuf.util.ProtocolError} If required fields are missing\n             */\n            ControlMessage.decode = function decode(r, l) {\n                if (!(r instanceof $Reader))\n                    r = $Reader.create(r);\n                var c = l === undefined ? r.len : r.pos + l, m = new $root.RPC.ControlMessage();\n                while (r.pos < c) {\n                    var t = r.uint32();\n                    switch (t >>> 3) {\n                    case 1:\n                        if (!(m.ihave && m.ihave.length))\n                            m.ihave = [];\n                        m.ihave.push($root.RPC.ControlIHave.decode(r, r.uint32()));\n                        break;\n                    case 2:\n                        if (!(m.iwant && m.iwant.length))\n                            m.iwant = [];\n                        m.iwant.push($root.RPC.ControlIWant.decode(r, r.uint32()));\n                        break;\n                    case 3:\n                        if (!(m.graft && m.graft.length))\n                            m.graft = [];\n                        m.graft.push($root.RPC.ControlGraft.decode(r, r.uint32()));\n                        break;\n                    case 4:\n                        if (!(m.prune && m.prune.length))\n                            m.prune = [];\n                        m.prune.push($root.RPC.ControlPrune.decode(r, r.uint32()));\n                        break;\n                    default:\n                        r.skipType(t & 7);\n                        break;\n                    }\n                }\n                return m;\n            };\n\n            /**\n             * Creates a ControlMessage message from a plain object. Also converts values to their respective internal types.\n             * @function fromObject\n             * @memberof RPC.ControlMessage\n             * @static\n             * @param {Object.<string,*>} d Plain object\n             * @returns {RPC.ControlMessage} ControlMessage\n             */\n            ControlMessage.fromObject = function fromObject(d) {\n                if (d instanceof $root.RPC.ControlMessage)\n                    return d;\n                var m = new $root.RPC.ControlMessage();\n                if (d.ihave) {\n                    if (!Array.isArray(d.ihave))\n                        throw TypeError(\".RPC.ControlMessage.ihave: array expected\");\n                    m.ihave = [];\n                    for (var i = 0; i < d.ihave.length; ++i) {\n                        if (typeof d.ihave[i] !== \"object\")\n                            throw TypeError(\".RPC.ControlMessage.ihave: object expected\");\n                        m.ihave[i] = $root.RPC.ControlIHave.fromObject(d.ihave[i]);\n                    }\n                }\n                if (d.iwant) {\n                    if (!Array.isArray(d.iwant))\n                        throw TypeError(\".RPC.ControlMessage.iwant: array expected\");\n                    m.iwant = [];\n                    for (var i = 0; i < d.iwant.length; ++i) {\n                        if (typeof d.iwant[i] !== \"object\")\n                            throw TypeError(\".RPC.ControlMessage.iwant: object expected\");\n                        m.iwant[i] = $root.RPC.ControlIWant.fromObject(d.iwant[i]);\n                    }\n                }\n                if (d.graft) {\n                    if (!Array.isArray(d.graft))\n                        throw TypeError(\".RPC.ControlMessage.graft: array expected\");\n                    m.graft = [];\n                    for (var i = 0; i < d.graft.length; ++i) {\n                        if (typeof d.graft[i] !== \"object\")\n                            throw TypeError(\".RPC.ControlMessage.graft: object expected\");\n                        m.graft[i] = $root.RPC.ControlGraft.fromObject(d.graft[i]);\n                    }\n                }\n                if (d.prune) {\n                    if (!Array.isArray(d.prune))\n                        throw TypeError(\".RPC.ControlMessage.prune: array expected\");\n                    m.prune = [];\n                    for (var i = 0; i < d.prune.length; ++i) {\n                        if (typeof d.prune[i] !== \"object\")\n                            throw TypeError(\".RPC.ControlMessage.prune: object expected\");\n                        m.prune[i] = $root.RPC.ControlPrune.fromObject(d.prune[i]);\n                    }\n                }\n                return m;\n            };\n\n            /**\n             * Creates a plain object from a ControlMessage message. Also converts values to other types if specified.\n             * @function toObject\n             * @memberof RPC.ControlMessage\n             * @static\n             * @param {RPC.ControlMessage} m ControlMessage\n             * @param {$protobuf.IConversionOptions} [o] Conversion options\n             * @returns {Object.<string,*>} Plain object\n             */\n            ControlMessage.toObject = function toObject(m, o) {\n                if (!o)\n                    o = {};\n                var d = {};\n                if (o.arrays || o.defaults) {\n                    d.ihave = [];\n                    d.iwant = [];\n                    d.graft = [];\n                    d.prune = [];\n                }\n                if (m.ihave && m.ihave.length) {\n                    d.ihave = [];\n                    for (var j = 0; j < m.ihave.length; ++j) {\n                        d.ihave[j] = $root.RPC.ControlIHave.toObject(m.ihave[j], o);\n                    }\n                }\n                if (m.iwant && m.iwant.length) {\n                    d.iwant = [];\n                    for (var j = 0; j < m.iwant.length; ++j) {\n                        d.iwant[j] = $root.RPC.ControlIWant.toObject(m.iwant[j], o);\n                    }\n                }\n                if (m.graft && m.graft.length) {\n                    d.graft = [];\n                    for (var j = 0; j < m.graft.length; ++j) {\n                        d.graft[j] = $root.RPC.ControlGraft.toObject(m.graft[j], o);\n                    }\n                }\n                if (m.prune && m.prune.length) {\n                    d.prune = [];\n                    for (var j = 0; j < m.prune.length; ++j) {\n                        d.prune[j] = $root.RPC.ControlPrune.toObject(m.prune[j], o);\n                    }\n                }\n                return d;\n            };\n\n            /**\n             * Converts this ControlMessage to JSON.\n             * @function toJSON\n             * @memberof RPC.ControlMessage\n             * @instance\n             * @returns {Object.<string,*>} JSON object\n             */\n            ControlMessage.prototype.toJSON = function toJSON() {\n                return this.constructor.toObject(this, $protobuf.util.toJSONOptions);\n            };\n\n            return ControlMessage;\n        })();\n\n        RPC.ControlIHave = (function() {\n\n            /**\n             * Properties of a ControlIHave.\n             * @memberof RPC\n             * @interface IControlIHave\n             * @property {string|null} [topicID] ControlIHave topicID\n             * @property {Array.<Uint8Array>|null} [messageIDs] ControlIHave messageIDs\n             */\n\n            /**\n             * Constructs a new ControlIHave.\n             * @memberof RPC\n             * @classdesc Represents a ControlIHave.\n             * @implements IControlIHave\n             * @constructor\n             * @param {RPC.IControlIHave=} [p] Properties to set\n             */\n            function ControlIHave(p) {\n                this.messageIDs = [];\n                if (p)\n                    for (var ks = Object.keys(p), i = 0; i < ks.length; ++i)\n                        if (p[ks[i]] != null)\n                            this[ks[i]] = p[ks[i]];\n            }\n\n            /**\n             * ControlIHave topicID.\n             * @member {string|null|undefined} topicID\n             * @memberof RPC.ControlIHave\n             * @instance\n             */\n            ControlIHave.prototype.topicID = null;\n\n            /**\n             * ControlIHave messageIDs.\n             * @member {Array.<Uint8Array>} messageIDs\n             * @memberof RPC.ControlIHave\n             * @instance\n             */\n            ControlIHave.prototype.messageIDs = $util.emptyArray;\n\n            // OneOf field names bound to virtual getters and setters\n            var $oneOfFields;\n\n            /**\n             * ControlIHave _topicID.\n             * @member {\"topicID\"|undefined} _topicID\n             * @memberof RPC.ControlIHave\n             * @instance\n             */\n            Object.defineProperty(ControlIHave.prototype, \"_topicID\", {\n                get: $util.oneOfGetter($oneOfFields = [\"topicID\"]),\n                set: $util.oneOfSetter($oneOfFields)\n            });\n\n            /**\n             * Encodes the specified ControlIHave message. Does not implicitly {@link RPC.ControlIHave.verify|verify} messages.\n             * @function encode\n             * @memberof RPC.ControlIHave\n             * @static\n             * @param {RPC.IControlIHave} m ControlIHave message or plain object to encode\n             * @param {$protobuf.Writer} [w] Writer to encode to\n             * @returns {$protobuf.Writer} Writer\n             */\n            ControlIHave.encode = function encode(m, w) {\n                if (!w)\n                    w = $Writer.create();\n                if (m.topicID != null && Object.hasOwnProperty.call(m, \"topicID\"))\n                    w.uint32(10).string(m.topicID);\n                if (m.messageIDs != null && m.messageIDs.length) {\n                    for (var i = 0; i < m.messageIDs.length; ++i)\n                        w.uint32(18).bytes(m.messageIDs[i]);\n                }\n                return w;\n            };\n\n            /**\n             * Decodes a ControlIHave message from the specified reader or buffer.\n             * @function decode\n             * @memberof RPC.ControlIHave\n             * @static\n             * @param {$protobuf.Reader|Uint8Array} r Reader or buffer to decode from\n             * @param {number} [l] Message length if known beforehand\n             * @returns {RPC.ControlIHave} ControlIHave\n             * @throws {Error} If the payload is not a reader or valid buffer\n             * @throws {$protobuf.util.ProtocolError} If required fields are missing\n             */\n            ControlIHave.decode = function decode(r, l) {\n                if (!(r instanceof $Reader))\n                    r = $Reader.create(r);\n                var c = l === undefined ? r.len : r.pos + l, m = new $root.RPC.ControlIHave();\n                while (r.pos < c) {\n                    var t = r.uint32();\n                    switch (t >>> 3) {\n                    case 1:\n                        m.topicID = r.string();\n                        break;\n                    case 2:\n                        if (!(m.messageIDs && m.messageIDs.length))\n                            m.messageIDs = [];\n                        m.messageIDs.push(r.bytes());\n                        break;\n                    default:\n                        r.skipType(t & 7);\n                        break;\n                    }\n                }\n                return m;\n            };\n\n            /**\n             * Creates a ControlIHave message from a plain object. Also converts values to their respective internal types.\n             * @function fromObject\n             * @memberof RPC.ControlIHave\n             * @static\n             * @param {Object.<string,*>} d Plain object\n             * @returns {RPC.ControlIHave} ControlIHave\n             */\n            ControlIHave.fromObject = function fromObject(d) {\n                if (d instanceof $root.RPC.ControlIHave)\n                    return d;\n                var m = new $root.RPC.ControlIHave();\n                if (d.topicID != null) {\n                    m.topicID = String(d.topicID);\n                }\n                if (d.messageIDs) {\n                    if (!Array.isArray(d.messageIDs))\n                        throw TypeError(\".RPC.ControlIHave.messageIDs: array expected\");\n                    m.messageIDs = [];\n                    for (var i = 0; i < d.messageIDs.length; ++i) {\n                        if (typeof d.messageIDs[i] === \"string\")\n                            $util.base64.decode(d.messageIDs[i], m.messageIDs[i] = $util.newBuffer($util.base64.length(d.messageIDs[i])), 0);\n                        else if (d.messageIDs[i].length)\n                            m.messageIDs[i] = d.messageIDs[i];\n                    }\n                }\n                return m;\n            };\n\n            /**\n             * Creates a plain object from a ControlIHave message. Also converts values to other types if specified.\n             * @function toObject\n             * @memberof RPC.ControlIHave\n             * @static\n             * @param {RPC.ControlIHave} m ControlIHave\n             * @param {$protobuf.IConversionOptions} [o] Conversion options\n             * @returns {Object.<string,*>} Plain object\n             */\n            ControlIHave.toObject = function toObject(m, o) {\n                if (!o)\n                    o = {};\n                var d = {};\n                if (o.arrays || o.defaults) {\n                    d.messageIDs = [];\n                }\n                if (m.topicID != null && m.hasOwnProperty(\"topicID\")) {\n                    d.topicID = m.topicID;\n                    if (o.oneofs)\n                        d._topicID = \"topicID\";\n                }\n                if (m.messageIDs && m.messageIDs.length) {\n                    d.messageIDs = [];\n                    for (var j = 0; j < m.messageIDs.length; ++j) {\n                        d.messageIDs[j] = o.bytes === String ? $util.base64.encode(m.messageIDs[j], 0, m.messageIDs[j].length) : o.bytes === Array ? Array.prototype.slice.call(m.messageIDs[j]) : m.messageIDs[j];\n                    }\n                }\n                return d;\n            };\n\n            /**\n             * Converts this ControlIHave to JSON.\n             * @function toJSON\n             * @memberof RPC.ControlIHave\n             * @instance\n             * @returns {Object.<string,*>} JSON object\n             */\n            ControlIHave.prototype.toJSON = function toJSON() {\n                return this.constructor.toObject(this, $protobuf.util.toJSONOptions);\n            };\n\n            return ControlIHave;\n        })();\n\n        RPC.ControlIWant = (function() {\n\n            /**\n             * Properties of a ControlIWant.\n             * @memberof RPC\n             * @interface IControlIWant\n             * @property {Array.<Uint8Array>|null} [messageIDs] ControlIWant messageIDs\n             */\n\n            /**\n             * Constructs a new ControlIWant.\n             * @memberof RPC\n             * @classdesc Represents a ControlIWant.\n             * @implements IControlIWant\n             * @constructor\n             * @param {RPC.IControlIWant=} [p] Properties to set\n             */\n            function ControlIWant(p) {\n                this.messageIDs = [];\n                if (p)\n                    for (var ks = Object.keys(p), i = 0; i < ks.length; ++i)\n                        if (p[ks[i]] != null)\n                            this[ks[i]] = p[ks[i]];\n            }\n\n            /**\n             * ControlIWant messageIDs.\n             * @member {Array.<Uint8Array>} messageIDs\n             * @memberof RPC.ControlIWant\n             * @instance\n             */\n            ControlIWant.prototype.messageIDs = $util.emptyArray;\n\n            /**\n             * Encodes the specified ControlIWant message. Does not implicitly {@link RPC.ControlIWant.verify|verify} messages.\n             * @function encode\n             * @memberof RPC.ControlIWant\n             * @static\n             * @param {RPC.IControlIWant} m ControlIWant message or plain object to encode\n             * @param {$protobuf.Writer} [w] Writer to encode to\n             * @returns {$protobuf.Writer} Writer\n             */\n            ControlIWant.encode = function encode(m, w) {\n                if (!w)\n                    w = $Writer.create();\n                if (m.messageIDs != null && m.messageIDs.length) {\n                    for (var i = 0; i < m.messageIDs.length; ++i)\n                        w.uint32(10).bytes(m.messageIDs[i]);\n                }\n                return w;\n            };\n\n            /**\n             * Decodes a ControlIWant message from the specified reader or buffer.\n             * @function decode\n             * @memberof RPC.ControlIWant\n             * @static\n             * @param {$protobuf.Reader|Uint8Array} r Reader or buffer to decode from\n             * @param {number} [l] Message length if known beforehand\n             * @returns {RPC.ControlIWant} ControlIWant\n             * @throws {Error} If the payload is not a reader or valid buffer\n             * @throws {$protobuf.util.ProtocolError} If required fields are missing\n             */\n            ControlIWant.decode = function decode(r, l) {\n                if (!(r instanceof $Reader))\n                    r = $Reader.create(r);\n                var c = l === undefined ? r.len : r.pos + l, m = new $root.RPC.ControlIWant();\n                while (r.pos < c) {\n                    var t = r.uint32();\n                    switch (t >>> 3) {\n                    case 1:\n                        if (!(m.messageIDs && m.messageIDs.length))\n                            m.messageIDs = [];\n                        m.messageIDs.push(r.bytes());\n                        break;\n                    default:\n                        r.skipType(t & 7);\n                        break;\n                    }\n                }\n                return m;\n            };\n\n            /**\n             * Creates a ControlIWant message from a plain object. Also converts values to their respective internal types.\n             * @function fromObject\n             * @memberof RPC.ControlIWant\n             * @static\n             * @param {Object.<string,*>} d Plain object\n             * @returns {RPC.ControlIWant} ControlIWant\n             */\n            ControlIWant.fromObject = function fromObject(d) {\n                if (d instanceof $root.RPC.ControlIWant)\n                    return d;\n                var m = new $root.RPC.ControlIWant();\n                if (d.messageIDs) {\n                    if (!Array.isArray(d.messageIDs))\n                        throw TypeError(\".RPC.ControlIWant.messageIDs: array expected\");\n                    m.messageIDs = [];\n                    for (var i = 0; i < d.messageIDs.length; ++i) {\n                        if (typeof d.messageIDs[i] === \"string\")\n                            $util.base64.decode(d.messageIDs[i], m.messageIDs[i] = $util.newBuffer($util.base64.length(d.messageIDs[i])), 0);\n                        else if (d.messageIDs[i].length)\n                            m.messageIDs[i] = d.messageIDs[i];\n                    }\n                }\n                return m;\n            };\n\n            /**\n             * Creates a plain object from a ControlIWant message. Also converts values to other types if specified.\n             * @function toObject\n             * @memberof RPC.ControlIWant\n             * @static\n             * @param {RPC.ControlIWant} m ControlIWant\n             * @param {$protobuf.IConversionOptions} [o] Conversion options\n             * @returns {Object.<string,*>} Plain object\n             */\n            ControlIWant.toObject = function toObject(m, o) {\n                if (!o)\n                    o = {};\n                var d = {};\n                if (o.arrays || o.defaults) {\n                    d.messageIDs = [];\n                }\n                if (m.messageIDs && m.messageIDs.length) {\n                    d.messageIDs = [];\n                    for (var j = 0; j < m.messageIDs.length; ++j) {\n                        d.messageIDs[j] = o.bytes === String ? $util.base64.encode(m.messageIDs[j], 0, m.messageIDs[j].length) : o.bytes === Array ? Array.prototype.slice.call(m.messageIDs[j]) : m.messageIDs[j];\n                    }\n                }\n                return d;\n            };\n\n            /**\n             * Converts this ControlIWant to JSON.\n             * @function toJSON\n             * @memberof RPC.ControlIWant\n             * @instance\n             * @returns {Object.<string,*>} JSON object\n             */\n            ControlIWant.prototype.toJSON = function toJSON() {\n                return this.constructor.toObject(this, $protobuf.util.toJSONOptions);\n            };\n\n            return ControlIWant;\n        })();\n\n        RPC.ControlGraft = (function() {\n\n            /**\n             * Properties of a ControlGraft.\n             * @memberof RPC\n             * @interface IControlGraft\n             * @property {string|null} [topicID] ControlGraft topicID\n             */\n\n            /**\n             * Constructs a new ControlGraft.\n             * @memberof RPC\n             * @classdesc Represents a ControlGraft.\n             * @implements IControlGraft\n             * @constructor\n             * @param {RPC.IControlGraft=} [p] Properties to set\n             */\n            function ControlGraft(p) {\n                if (p)\n                    for (var ks = Object.keys(p), i = 0; i < ks.length; ++i)\n                        if (p[ks[i]] != null)\n                            this[ks[i]] = p[ks[i]];\n            }\n\n            /**\n             * ControlGraft topicID.\n             * @member {string|null|undefined} topicID\n             * @memberof RPC.ControlGraft\n             * @instance\n             */\n            ControlGraft.prototype.topicID = null;\n\n            // OneOf field names bound to virtual getters and setters\n            var $oneOfFields;\n\n            /**\n             * ControlGraft _topicID.\n             * @member {\"topicID\"|undefined} _topicID\n             * @memberof RPC.ControlGraft\n             * @instance\n             */\n            Object.defineProperty(ControlGraft.prototype, \"_topicID\", {\n                get: $util.oneOfGetter($oneOfFields = [\"topicID\"]),\n                set: $util.oneOfSetter($oneOfFields)\n            });\n\n            /**\n             * Encodes the specified ControlGraft message. Does not implicitly {@link RPC.ControlGraft.verify|verify} messages.\n             * @function encode\n             * @memberof RPC.ControlGraft\n             * @static\n             * @param {RPC.IControlGraft} m ControlGraft message or plain object to encode\n             * @param {$protobuf.Writer} [w] Writer to encode to\n             * @returns {$protobuf.Writer} Writer\n             */\n            ControlGraft.encode = function encode(m, w) {\n                if (!w)\n                    w = $Writer.create();\n                if (m.topicID != null && Object.hasOwnProperty.call(m, \"topicID\"))\n                    w.uint32(10).string(m.topicID);\n                return w;\n            };\n\n            /**\n             * Decodes a ControlGraft message from the specified reader or buffer.\n             * @function decode\n             * @memberof RPC.ControlGraft\n             * @static\n             * @param {$protobuf.Reader|Uint8Array} r Reader or buffer to decode from\n             * @param {number} [l] Message length if known beforehand\n             * @returns {RPC.ControlGraft} ControlGraft\n             * @throws {Error} If the payload is not a reader or valid buffer\n             * @throws {$protobuf.util.ProtocolError} If required fields are missing\n             */\n            ControlGraft.decode = function decode(r, l) {\n                if (!(r instanceof $Reader))\n                    r = $Reader.create(r);\n                var c = l === undefined ? r.len : r.pos + l, m = new $root.RPC.ControlGraft();\n                while (r.pos < c) {\n                    var t = r.uint32();\n                    switch (t >>> 3) {\n                    case 1:\n                        m.topicID = r.string();\n                        break;\n                    default:\n                        r.skipType(t & 7);\n                        break;\n                    }\n                }\n                return m;\n            };\n\n            /**\n             * Creates a ControlGraft message from a plain object. Also converts values to their respective internal types.\n             * @function fromObject\n             * @memberof RPC.ControlGraft\n             * @static\n             * @param {Object.<string,*>} d Plain object\n             * @returns {RPC.ControlGraft} ControlGraft\n             */\n            ControlGraft.fromObject = function fromObject(d) {\n                if (d instanceof $root.RPC.ControlGraft)\n                    return d;\n                var m = new $root.RPC.ControlGraft();\n                if (d.topicID != null) {\n                    m.topicID = String(d.topicID);\n                }\n                return m;\n            };\n\n            /**\n             * Creates a plain object from a ControlGraft message. Also converts values to other types if specified.\n             * @function toObject\n             * @memberof RPC.ControlGraft\n             * @static\n             * @param {RPC.ControlGraft} m ControlGraft\n             * @param {$protobuf.IConversionOptions} [o] Conversion options\n             * @returns {Object.<string,*>} Plain object\n             */\n            ControlGraft.toObject = function toObject(m, o) {\n                if (!o)\n                    o = {};\n                var d = {};\n                if (m.topicID != null && m.hasOwnProperty(\"topicID\")) {\n                    d.topicID = m.topicID;\n                    if (o.oneofs)\n                        d._topicID = \"topicID\";\n                }\n                return d;\n            };\n\n            /**\n             * Converts this ControlGraft to JSON.\n             * @function toJSON\n             * @memberof RPC.ControlGraft\n             * @instance\n             * @returns {Object.<string,*>} JSON object\n             */\n            ControlGraft.prototype.toJSON = function toJSON() {\n                return this.constructor.toObject(this, $protobuf.util.toJSONOptions);\n            };\n\n            return ControlGraft;\n        })();\n\n        RPC.ControlPrune = (function() {\n\n            /**\n             * Properties of a ControlPrune.\n             * @memberof RPC\n             * @interface IControlPrune\n             * @property {string|null} [topicID] ControlPrune topicID\n             * @property {Array.<RPC.IPeerInfo>|null} [peers] ControlPrune peers\n             * @property {number|null} [backoff] ControlPrune backoff\n             */\n\n            /**\n             * Constructs a new ControlPrune.\n             * @memberof RPC\n             * @classdesc Represents a ControlPrune.\n             * @implements IControlPrune\n             * @constructor\n             * @param {RPC.IControlPrune=} [p] Properties to set\n             */\n            function ControlPrune(p) {\n                this.peers = [];\n                if (p)\n                    for (var ks = Object.keys(p), i = 0; i < ks.length; ++i)\n                        if (p[ks[i]] != null)\n                            this[ks[i]] = p[ks[i]];\n            }\n\n            /**\n             * ControlPrune topicID.\n             * @member {string|null|undefined} topicID\n             * @memberof RPC.ControlPrune\n             * @instance\n             */\n            ControlPrune.prototype.topicID = null;\n\n            /**\n             * ControlPrune peers.\n             * @member {Array.<RPC.IPeerInfo>} peers\n             * @memberof RPC.ControlPrune\n             * @instance\n             */\n            ControlPrune.prototype.peers = $util.emptyArray;\n\n            /**\n             * ControlPrune backoff.\n             * @member {number|null|undefined} backoff\n             * @memberof RPC.ControlPrune\n             * @instance\n             */\n            ControlPrune.prototype.backoff = null;\n\n            // OneOf field names bound to virtual getters and setters\n            var $oneOfFields;\n\n            /**\n             * ControlPrune _topicID.\n             * @member {\"topicID\"|undefined} _topicID\n             * @memberof RPC.ControlPrune\n             * @instance\n             */\n            Object.defineProperty(ControlPrune.prototype, \"_topicID\", {\n                get: $util.oneOfGetter($oneOfFields = [\"topicID\"]),\n                set: $util.oneOfSetter($oneOfFields)\n            });\n\n            /**\n             * ControlPrune _backoff.\n             * @member {\"backoff\"|undefined} _backoff\n             * @memberof RPC.ControlPrune\n             * @instance\n             */\n            Object.defineProperty(ControlPrune.prototype, \"_backoff\", {\n                get: $util.oneOfGetter($oneOfFields = [\"backoff\"]),\n                set: $util.oneOfSetter($oneOfFields)\n            });\n\n            /**\n             * Encodes the specified ControlPrune message. Does not implicitly {@link RPC.ControlPrune.verify|verify} messages.\n             * @function encode\n             * @memberof RPC.ControlPrune\n             * @static\n             * @param {RPC.IControlPrune} m ControlPrune message or plain object to encode\n             * @param {$protobuf.Writer} [w] Writer to encode to\n             * @returns {$protobuf.Writer} Writer\n             */\n            ControlPrune.encode = function encode(m, w) {\n                if (!w)\n                    w = $Writer.create();\n                if (m.topicID != null && Object.hasOwnProperty.call(m, \"topicID\"))\n                    w.uint32(10).string(m.topicID);\n                if (m.peers != null && m.peers.length) {\n                    for (var i = 0; i < m.peers.length; ++i)\n                        $root.RPC.PeerInfo.encode(m.peers[i], w.uint32(18).fork()).ldelim();\n                }\n                if (m.backoff != null && Object.hasOwnProperty.call(m, \"backoff\"))\n                    w.uint32(24).uint64(m.backoff);\n                return w;\n            };\n\n            /**\n             * Decodes a ControlPrune message from the specified reader or buffer.\n             * @function decode\n             * @memberof RPC.ControlPrune\n             * @static\n             * @param {$protobuf.Reader|Uint8Array} r Reader or buffer to decode from\n             * @param {number} [l] Message length if known beforehand\n             * @returns {RPC.ControlPrune} ControlPrune\n             * @throws {Error} If the payload is not a reader or valid buffer\n             * @throws {$protobuf.util.ProtocolError} If required fields are missing\n             */\n            ControlPrune.decode = function decode(r, l) {\n                if (!(r instanceof $Reader))\n                    r = $Reader.create(r);\n                var c = l === undefined ? r.len : r.pos + l, m = new $root.RPC.ControlPrune();\n                while (r.pos < c) {\n                    var t = r.uint32();\n                    switch (t >>> 3) {\n                    case 1:\n                        m.topicID = r.string();\n                        break;\n                    case 2:\n                        if (!(m.peers && m.peers.length))\n                            m.peers = [];\n                        m.peers.push($root.RPC.PeerInfo.decode(r, r.uint32()));\n                        break;\n                    case 3:\n                        m.backoff = r.uint64();\n                        break;\n                    default:\n                        r.skipType(t & 7);\n                        break;\n                    }\n                }\n                return m;\n            };\n\n            /**\n             * Creates a ControlPrune message from a plain object. Also converts values to their respective internal types.\n             * @function fromObject\n             * @memberof RPC.ControlPrune\n             * @static\n             * @param {Object.<string,*>} d Plain object\n             * @returns {RPC.ControlPrune} ControlPrune\n             */\n            ControlPrune.fromObject = function fromObject(d) {\n                if (d instanceof $root.RPC.ControlPrune)\n                    return d;\n                var m = new $root.RPC.ControlPrune();\n                if (d.topicID != null) {\n                    m.topicID = String(d.topicID);\n                }\n                if (d.peers) {\n                    if (!Array.isArray(d.peers))\n                        throw TypeError(\".RPC.ControlPrune.peers: array expected\");\n                    m.peers = [];\n                    for (var i = 0; i < d.peers.length; ++i) {\n                        if (typeof d.peers[i] !== \"object\")\n                            throw TypeError(\".RPC.ControlPrune.peers: object expected\");\n                        m.peers[i] = $root.RPC.PeerInfo.fromObject(d.peers[i]);\n                    }\n                }\n                if (d.backoff != null) {\n                    if ($util.Long)\n                        (m.backoff = $util.Long.fromValue(d.backoff)).unsigned = true;\n                    else if (typeof d.backoff === \"string\")\n                        m.backoff = parseInt(d.backoff, 10);\n                    else if (typeof d.backoff === \"number\")\n                        m.backoff = d.backoff;\n                    else if (typeof d.backoff === \"object\")\n                        m.backoff = new $util.LongBits(d.backoff.low >>> 0, d.backoff.high >>> 0).toNumber(true);\n                }\n                return m;\n            };\n\n            /**\n             * Creates a plain object from a ControlPrune message. Also converts values to other types if specified.\n             * @function toObject\n             * @memberof RPC.ControlPrune\n             * @static\n             * @param {RPC.ControlPrune} m ControlPrune\n             * @param {$protobuf.IConversionOptions} [o] Conversion options\n             * @returns {Object.<string,*>} Plain object\n             */\n            ControlPrune.toObject = function toObject(m, o) {\n                if (!o)\n                    o = {};\n                var d = {};\n                if (o.arrays || o.defaults) {\n                    d.peers = [];\n                }\n                if (m.topicID != null && m.hasOwnProperty(\"topicID\")) {\n                    d.topicID = m.topicID;\n                    if (o.oneofs)\n                        d._topicID = \"topicID\";\n                }\n                if (m.peers && m.peers.length) {\n                    d.peers = [];\n                    for (var j = 0; j < m.peers.length; ++j) {\n                        d.peers[j] = $root.RPC.PeerInfo.toObject(m.peers[j], o);\n                    }\n                }\n                if (m.backoff != null && m.hasOwnProperty(\"backoff\")) {\n                    if (typeof m.backoff === \"number\")\n                        d.backoff = o.longs === String ? String(m.backoff) : m.backoff;\n                    else\n                        d.backoff = o.longs === String ? $util.Long.prototype.toString.call(m.backoff) : o.longs === Number ? new $util.LongBits(m.backoff.low >>> 0, m.backoff.high >>> 0).toNumber(true) : m.backoff;\n                    if (o.oneofs)\n                        d._backoff = \"backoff\";\n                }\n                return d;\n            };\n\n            /**\n             * Converts this ControlPrune to JSON.\n             * @function toJSON\n             * @memberof RPC.ControlPrune\n             * @instance\n             * @returns {Object.<string,*>} JSON object\n             */\n            ControlPrune.prototype.toJSON = function toJSON() {\n                return this.constructor.toObject(this, $protobuf.util.toJSONOptions);\n            };\n\n            return ControlPrune;\n        })();\n\n        RPC.PeerInfo = (function() {\n\n            /**\n             * Properties of a PeerInfo.\n             * @memberof RPC\n             * @interface IPeerInfo\n             * @property {Uint8Array|null} [peerID] PeerInfo peerID\n             * @property {Uint8Array|null} [signedPeerRecord] PeerInfo signedPeerRecord\n             */\n\n            /**\n             * Constructs a new PeerInfo.\n             * @memberof RPC\n             * @classdesc Represents a PeerInfo.\n             * @implements IPeerInfo\n             * @constructor\n             * @param {RPC.IPeerInfo=} [p] Properties to set\n             */\n            function PeerInfo(p) {\n                if (p)\n                    for (var ks = Object.keys(p), i = 0; i < ks.length; ++i)\n                        if (p[ks[i]] != null)\n                            this[ks[i]] = p[ks[i]];\n            }\n\n            /**\n             * PeerInfo peerID.\n             * @member {Uint8Array|null|undefined} peerID\n             * @memberof RPC.PeerInfo\n             * @instance\n             */\n            PeerInfo.prototype.peerID = null;\n\n            /**\n             * PeerInfo signedPeerRecord.\n             * @member {Uint8Array|null|undefined} signedPeerRecord\n             * @memberof RPC.PeerInfo\n             * @instance\n             */\n            PeerInfo.prototype.signedPeerRecord = null;\n\n            // OneOf field names bound to virtual getters and setters\n            var $oneOfFields;\n\n            /**\n             * PeerInfo _peerID.\n             * @member {\"peerID\"|undefined} _peerID\n             * @memberof RPC.PeerInfo\n             * @instance\n             */\n            Object.defineProperty(PeerInfo.prototype, \"_peerID\", {\n                get: $util.oneOfGetter($oneOfFields = [\"peerID\"]),\n                set: $util.oneOfSetter($oneOfFields)\n            });\n\n            /**\n             * PeerInfo _signedPeerRecord.\n             * @member {\"signedPeerRecord\"|undefined} _signedPeerRecord\n             * @memberof RPC.PeerInfo\n             * @instance\n             */\n            Object.defineProperty(PeerInfo.prototype, \"_signedPeerRecord\", {\n                get: $util.oneOfGetter($oneOfFields = [\"signedPeerRecord\"]),\n                set: $util.oneOfSetter($oneOfFields)\n            });\n\n            /**\n             * Encodes the specified PeerInfo message. Does not implicitly {@link RPC.PeerInfo.verify|verify} messages.\n             * @function encode\n             * @memberof RPC.PeerInfo\n             * @static\n             * @param {RPC.IPeerInfo} m PeerInfo message or plain object to encode\n             * @param {$protobuf.Writer} [w] Writer to encode to\n             * @returns {$protobuf.Writer} Writer\n             */\n            PeerInfo.encode = function encode(m, w) {\n                if (!w)\n                    w = $Writer.create();\n                if (m.peerID != null && Object.hasOwnProperty.call(m, \"peerID\"))\n                    w.uint32(10).bytes(m.peerID);\n                if (m.signedPeerRecord != null && Object.hasOwnProperty.call(m, \"signedPeerRecord\"))\n                    w.uint32(18).bytes(m.signedPeerRecord);\n                return w;\n            };\n\n            /**\n             * Decodes a PeerInfo message from the specified reader or buffer.\n             * @function decode\n             * @memberof RPC.PeerInfo\n             * @static\n             * @param {$protobuf.Reader|Uint8Array} r Reader or buffer to decode from\n             * @param {number} [l] Message length if known beforehand\n             * @returns {RPC.PeerInfo} PeerInfo\n             * @throws {Error} If the payload is not a reader or valid buffer\n             * @throws {$protobuf.util.ProtocolError} If required fields are missing\n             */\n            PeerInfo.decode = function decode(r, l) {\n                if (!(r instanceof $Reader))\n                    r = $Reader.create(r);\n                var c = l === undefined ? r.len : r.pos + l, m = new $root.RPC.PeerInfo();\n                while (r.pos < c) {\n                    var t = r.uint32();\n                    switch (t >>> 3) {\n                    case 1:\n                        m.peerID = r.bytes();\n                        break;\n                    case 2:\n                        m.signedPeerRecord = r.bytes();\n                        break;\n                    default:\n                        r.skipType(t & 7);\n                        break;\n                    }\n                }\n                return m;\n            };\n\n            /**\n             * Creates a PeerInfo message from a plain object. Also converts values to their respective internal types.\n             * @function fromObject\n             * @memberof RPC.PeerInfo\n             * @static\n             * @param {Object.<string,*>} d Plain object\n             * @returns {RPC.PeerInfo} PeerInfo\n             */\n            PeerInfo.fromObject = function fromObject(d) {\n                if (d instanceof $root.RPC.PeerInfo)\n                    return d;\n                var m = new $root.RPC.PeerInfo();\n                if (d.peerID != null) {\n                    if (typeof d.peerID === \"string\")\n                        $util.base64.decode(d.peerID, m.peerID = $util.newBuffer($util.base64.length(d.peerID)), 0);\n                    else if (d.peerID.length)\n                        m.peerID = d.peerID;\n                }\n                if (d.signedPeerRecord != null) {\n                    if (typeof d.signedPeerRecord === \"string\")\n                        $util.base64.decode(d.signedPeerRecord, m.signedPeerRecord = $util.newBuffer($util.base64.length(d.signedPeerRecord)), 0);\n                    else if (d.signedPeerRecord.length)\n                        m.signedPeerRecord = d.signedPeerRecord;\n                }\n                return m;\n            };\n\n            /**\n             * Creates a plain object from a PeerInfo message. Also converts values to other types if specified.\n             * @function toObject\n             * @memberof RPC.PeerInfo\n             * @static\n             * @param {RPC.PeerInfo} m PeerInfo\n             * @param {$protobuf.IConversionOptions} [o] Conversion options\n             * @returns {Object.<string,*>} Plain object\n             */\n            PeerInfo.toObject = function toObject(m, o) {\n                if (!o)\n                    o = {};\n                var d = {};\n                if (m.peerID != null && m.hasOwnProperty(\"peerID\")) {\n                    d.peerID = o.bytes === String ? $util.base64.encode(m.peerID, 0, m.peerID.length) : o.bytes === Array ? Array.prototype.slice.call(m.peerID) : m.peerID;\n                    if (o.oneofs)\n                        d._peerID = \"peerID\";\n                }\n                if (m.signedPeerRecord != null && m.hasOwnProperty(\"signedPeerRecord\")) {\n                    d.signedPeerRecord = o.bytes === String ? $util.base64.encode(m.signedPeerRecord, 0, m.signedPeerRecord.length) : o.bytes === Array ? Array.prototype.slice.call(m.signedPeerRecord) : m.signedPeerRecord;\n                    if (o.oneofs)\n                        d._signedPeerRecord = \"signedPeerRecord\";\n                }\n                return d;\n            };\n\n            /**\n             * Converts this PeerInfo to JSON.\n             * @function toJSON\n             * @memberof RPC.PeerInfo\n             * @instance\n             * @returns {Object.<string,*>} JSON object\n             */\n            PeerInfo.prototype.toJSON = function toJSON() {\n                return this.constructor.toObject(this, $protobuf.util.toJSONOptions);\n            };\n\n            return PeerInfo;\n        })();\n\n        return RPC;\n    })();\n\n    return $root;\n});\n", "'use strict';\n\n/**\n * Custom implementation of a double ended queue.\n */\nfunction Denque(array, options) {\n  var options = options || {};\n  this._capacity = options.capacity;\n\n  this._head = 0;\n  this._tail = 0;\n\n  if (Array.isArray(array)) {\n    this._fromArray(array);\n  } else {\n    this._capacityMask = 0x3;\n    this._list = new Array(4);\n  }\n}\n\n/**\n * --------------\n *  PUBLIC API\n * -------------\n */\n\n/**\n * Returns the item at the specified index from the list.\n * 0 is the first element, 1 is the second, and so on...\n * Elements at negative values are that many from the end: -1 is one before the end\n * (the last element), -2 is two before the end (one before last), etc.\n * @param index\n * @returns {*}\n */\nDenque.prototype.peekAt = function peekAt(index) {\n  var i = index;\n  // expect a number or return undefined\n  if ((i !== (i | 0))) {\n    return void 0;\n  }\n  var len = this.size();\n  if (i >= len || i < -len) return undefined;\n  if (i < 0) i += len;\n  i = (this._head + i) & this._capacityMask;\n  return this._list[i];\n};\n\n/**\n * Alias for peekAt()\n * @param i\n * @returns {*}\n */\nDenque.prototype.get = function get(i) {\n  return this.peekAt(i);\n};\n\n/**\n * Returns the first item in the list without removing it.\n * @returns {*}\n */\nDenque.prototype.peek = function peek() {\n  if (this._head === this._tail) return undefined;\n  return this._list[this._head];\n};\n\n/**\n * Alias for peek()\n * @returns {*}\n */\nDenque.prototype.peekFront = function peekFront() {\n  return this.peek();\n};\n\n/**\n * Returns the item that is at the back of the queue without removing it.\n * Uses peekAt(-1)\n */\nDenque.prototype.peekBack = function peekBack() {\n  return this.peekAt(-1);\n};\n\n/**\n * Returns the current length of the queue\n * @return {Number}\n */\nObject.defineProperty(Denque.prototype, 'length', {\n  get: function length() {\n    return this.size();\n  }\n});\n\n/**\n * Return the number of items on the list, or 0 if empty.\n * @returns {number}\n */\nDenque.prototype.size = function size() {\n  if (this._head === this._tail) return 0;\n  if (this._head < this._tail) return this._tail - this._head;\n  else return this._capacityMask + 1 - (this._head - this._tail);\n};\n\n/**\n * Add an item at the beginning of the list.\n * @param item\n */\nDenque.prototype.unshift = function unshift(item) {\n  if (arguments.length === 0) return this.size();\n  var len = this._list.length;\n  this._head = (this._head - 1 + len) & this._capacityMask;\n  this._list[this._head] = item;\n  if (this._tail === this._head) this._growArray();\n  if (this._capacity && this.size() > this._capacity) this.pop();\n  if (this._head < this._tail) return this._tail - this._head;\n  else return this._capacityMask + 1 - (this._head - this._tail);\n};\n\n/**\n * Remove and return the first item on the list,\n * Returns undefined if the list is empty.\n * @returns {*}\n */\nDenque.prototype.shift = function shift() {\n  var head = this._head;\n  if (head === this._tail) return undefined;\n  var item = this._list[head];\n  this._list[head] = undefined;\n  this._head = (head + 1) & this._capacityMask;\n  if (head < 2 && this._tail > 10000 && this._tail <= this._list.length >>> 2) this._shrinkArray();\n  return item;\n};\n\n/**\n * Add an item to the bottom of the list.\n * @param item\n */\nDenque.prototype.push = function push(item) {\n  if (arguments.length === 0) return this.size();\n  var tail = this._tail;\n  this._list[tail] = item;\n  this._tail = (tail + 1) & this._capacityMask;\n  if (this._tail === this._head) {\n    this._growArray();\n  }\n  if (this._capacity && this.size() > this._capacity) {\n    this.shift();\n  }\n  if (this._head < this._tail) return this._tail - this._head;\n  else return this._capacityMask + 1 - (this._head - this._tail);\n};\n\n/**\n * Remove and return the last item on the list.\n * Returns undefined if the list is empty.\n * @returns {*}\n */\nDenque.prototype.pop = function pop() {\n  var tail = this._tail;\n  if (tail === this._head) return undefined;\n  var len = this._list.length;\n  this._tail = (tail - 1 + len) & this._capacityMask;\n  var item = this._list[this._tail];\n  this._list[this._tail] = undefined;\n  if (this._head < 2 && tail > 10000 && tail <= len >>> 2) this._shrinkArray();\n  return item;\n};\n\n/**\n * Remove and return the item at the specified index from the list.\n * Returns undefined if the list is empty.\n * @param index\n * @returns {*}\n */\nDenque.prototype.removeOne = function removeOne(index) {\n  var i = index;\n  // expect a number or return undefined\n  if ((i !== (i | 0))) {\n    return void 0;\n  }\n  if (this._head === this._tail) return void 0;\n  var size = this.size();\n  var len = this._list.length;\n  if (i >= size || i < -size) return void 0;\n  if (i < 0) i += size;\n  i = (this._head + i) & this._capacityMask;\n  var item = this._list[i];\n  var k;\n  if (index < size / 2) {\n    for (k = index; k > 0; k--) {\n      this._list[i] = this._list[i = (i - 1 + len) & this._capacityMask];\n    }\n    this._list[i] = void 0;\n    this._head = (this._head + 1 + len) & this._capacityMask;\n  } else {\n    for (k = size - 1 - index; k > 0; k--) {\n      this._list[i] = this._list[i = (i + 1 + len) & this._capacityMask];\n    }\n    this._list[i] = void 0;\n    this._tail = (this._tail - 1 + len) & this._capacityMask;\n  }\n  return item;\n};\n\n/**\n * Remove number of items from the specified index from the list.\n * Returns array of removed items.\n * Returns undefined if the list is empty.\n * @param index\n * @param count\n * @returns {array}\n */\nDenque.prototype.remove = function remove(index, count) {\n  var i = index;\n  var removed;\n  var del_count = count;\n  // expect a number or return undefined\n  if ((i !== (i | 0))) {\n    return void 0;\n  }\n  if (this._head === this._tail) return void 0;\n  var size = this.size();\n  var len = this._list.length;\n  if (i >= size || i < -size || count < 1) return void 0;\n  if (i < 0) i += size;\n  if (count === 1 || !count) {\n    removed = new Array(1);\n    removed[0] = this.removeOne(i);\n    return removed;\n  }\n  if (i === 0 && i + count >= size) {\n    removed = this.toArray();\n    this.clear();\n    return removed;\n  }\n  if (i + count > size) count = size - i;\n  var k;\n  removed = new Array(count);\n  for (k = 0; k < count; k++) {\n    removed[k] = this._list[(this._head + i + k) & this._capacityMask];\n  }\n  i = (this._head + i) & this._capacityMask;\n  if (index + count === size) {\n    this._tail = (this._tail - count + len) & this._capacityMask;\n    for (k = count; k > 0; k--) {\n      this._list[i = (i + 1 + len) & this._capacityMask] = void 0;\n    }\n    return removed;\n  }\n  if (index === 0) {\n    this._head = (this._head + count + len) & this._capacityMask;\n    for (k = count - 1; k > 0; k--) {\n      this._list[i = (i + 1 + len) & this._capacityMask] = void 0;\n    }\n    return removed;\n  }\n  if (i < size / 2) {\n    this._head = (this._head + index + count + len) & this._capacityMask;\n    for (k = index; k > 0; k--) {\n      this.unshift(this._list[i = (i - 1 + len) & this._capacityMask]);\n    }\n    i = (this._head - 1 + len) & this._capacityMask;\n    while (del_count > 0) {\n      this._list[i = (i - 1 + len) & this._capacityMask] = void 0;\n      del_count--;\n    }\n    if (index < 0) this._tail = i;\n  } else {\n    this._tail = i;\n    i = (i + count + len) & this._capacityMask;\n    for (k = size - (count + index); k > 0; k--) {\n      this.push(this._list[i++]);\n    }\n    i = this._tail;\n    while (del_count > 0) {\n      this._list[i = (i + 1 + len) & this._capacityMask] = void 0;\n      del_count--;\n    }\n  }\n  if (this._head < 2 && this._tail > 10000 && this._tail <= len >>> 2) this._shrinkArray();\n  return removed;\n};\n\n/**\n * Native splice implementation.\n * Remove number of items from the specified index from the list and/or add new elements.\n * Returns array of removed items or empty array if count == 0.\n * Returns undefined if the list is empty.\n *\n * @param index\n * @param count\n * @param {...*} [elements]\n * @returns {array}\n */\nDenque.prototype.splice = function splice(index, count) {\n  var i = index;\n  // expect a number or return undefined\n  if ((i !== (i | 0))) {\n    return void 0;\n  }\n  var size = this.size();\n  if (i < 0) i += size;\n  if (i > size) return void 0;\n  if (arguments.length > 2) {\n    var k;\n    var temp;\n    var removed;\n    var arg_len = arguments.length;\n    var len = this._list.length;\n    var arguments_index = 2;\n    if (!size || i < size / 2) {\n      temp = new Array(i);\n      for (k = 0; k < i; k++) {\n        temp[k] = this._list[(this._head + k) & this._capacityMask];\n      }\n      if (count === 0) {\n        removed = [];\n        if (i > 0) {\n          this._head = (this._head + i + len) & this._capacityMask;\n        }\n      } else {\n        removed = this.remove(i, count);\n        this._head = (this._head + i + len) & this._capacityMask;\n      }\n      while (arg_len > arguments_index) {\n        this.unshift(arguments[--arg_len]);\n      }\n      for (k = i; k > 0; k--) {\n        this.unshift(temp[k - 1]);\n      }\n    } else {\n      temp = new Array(size - (i + count));\n      var leng = temp.length;\n      for (k = 0; k < leng; k++) {\n        temp[k] = this._list[(this._head + i + count + k) & this._capacityMask];\n      }\n      if (count === 0) {\n        removed = [];\n        if (i != size) {\n          this._tail = (this._head + i + len) & this._capacityMask;\n        }\n      } else {\n        removed = this.remove(i, count);\n        this._tail = (this._tail - leng + len) & this._capacityMask;\n      }\n      while (arguments_index < arg_len) {\n        this.push(arguments[arguments_index++]);\n      }\n      for (k = 0; k < leng; k++) {\n        this.push(temp[k]);\n      }\n    }\n    return removed;\n  } else {\n    return this.remove(i, count);\n  }\n};\n\n/**\n * Soft clear - does not reset capacity.\n */\nDenque.prototype.clear = function clear() {\n  this._list = new Array(this._list.length);\n  this._head = 0;\n  this._tail = 0;\n};\n\n/**\n * Returns true or false whether the list is empty.\n * @returns {boolean}\n */\nDenque.prototype.isEmpty = function isEmpty() {\n  return this._head === this._tail;\n};\n\n/**\n * Returns an array of all queue items.\n * @returns {Array}\n */\nDenque.prototype.toArray = function toArray() {\n  return this._copyArray(false);\n};\n\n/**\n * -------------\n *   INTERNALS\n * -------------\n */\n\n/**\n * Fills the queue with items from an array\n * For use in the constructor\n * @param array\n * @private\n */\nDenque.prototype._fromArray = function _fromArray(array) {\n  var length = array.length;\n  var capacity = this._nextPowerOf2(length);\n\n  this._list = new Array(capacity);\n  this._capacityMask = capacity - 1;\n  this._tail = length;\n\n  for (var i = 0; i < length; i++) this._list[i] = array[i];\n};\n\n/**\n *\n * @param fullCopy\n * @param size Initialize the array with a specific size. Will default to the current list size\n * @returns {Array}\n * @private\n */\nDenque.prototype._copyArray = function _copyArray(fullCopy, size) {\n  var src = this._list;\n  var capacity = src.length;\n  var length = this.length;\n  size = size | length;\n\n  // No prealloc requested and the buffer is contiguous\n  if (size == length && this._head < this._tail) {\n    // Simply do a fast slice copy\n    return this._list.slice(this._head, this._tail);\n  }\n\n  var dest = new Array(size);\n\n  var k = 0;\n  var i;\n  if (fullCopy || this._head > this._tail) {\n    for (i = this._head; i < capacity; i++) dest[k++] = src[i];\n    for (i = 0; i < this._tail; i++) dest[k++] = src[i];\n  } else {\n    for (i = this._head; i < this._tail; i++) dest[k++] = src[i];\n  }\n\n  return dest;\n}\n\n/**\n * Grows the internal list array.\n * @private\n */\nDenque.prototype._growArray = function _growArray() {\n  if (this._head != 0) {\n    // double array size and copy existing data, head to end, then beginning to tail.\n    var newList = this._copyArray(true, this._list.length << 1);\n\n    this._tail = this._list.length;\n    this._head = 0;\n\n    this._list = newList;\n  } else {\n    this._tail = this._list.length;\n    this._list.length <<= 1;\n  }\n\n  this._capacityMask = (this._capacityMask << 1) | 1;\n};\n\n/**\n * Shrinks the internal list array.\n * @private\n */\nDenque.prototype._shrinkArray = function _shrinkArray() {\n  this._list.length >>>= 1;\n  this._capacityMask >>>= 1;\n};\n\n/**\n * Find the next power of 2, at least 4\n * @private\n * @param {number} num \n * @returns {number}\n */\nDenque.prototype._nextPowerOf2 = function _nextPowerOf2(num) {\n  var log2 = Math.log(num) / Math.log(2);\n  var nextPow2 = 1 << (log2 + 1);\n\n  return Math.max(nextPow2, 4);\n}\n\nmodule.exports = Denque;\n", "export const second = 1000\nexport const minute = 60 * second\n\n// Protocol identifiers\n\nexport const FloodsubID = '/floodsub/1.0.0'\n\n/**\n * The protocol ID for version 1.0.0 of the Gossipsub protocol\n * It is advertised along with GossipsubIDv11 for backwards compatability\n */\nexport const GossipsubIDv10 = '/meshsub/1.0.0'\n\n/**\n * The protocol ID for version 1.1.0 of the Gossipsub protocol\n * See the spec for details about how v1.1.0 compares to v1.0.0:\n * https://github.com/libp2p/specs/blob/master/pubsub/gossipsub/gossipsub-v1.1.md\n */\nexport const GossipsubIDv11 = '/meshsub/1.1.0'\n\n// Overlay parameters\n\n/**\n * GossipsubD sets the optimal degree for a Gossipsub topic mesh. For example, if GossipsubD == 6,\n * each peer will want to have about six peers in their mesh for each topic they're subscribed to.\n * GossipsubD should be set somewhere between GossipsubDlo and GossipsubDhi.\n */\nexport const GossipsubD = 6\n\n/**\n * GossipsubDlo sets the lower bound on the number of peers we keep in a Gossipsub topic mesh.\n * If we have fewer than GossipsubDlo peers, we will attempt to graft some more into the mesh at\n * the next heartbeat.\n */\nexport const GossipsubDlo = 4\n\n/**\n * GossipsubDhi sets the upper bound on the number of peers we keep in a Gossipsub topic mesh.\n * If we have more than GossipsubDhi peers, we will select some to prune from the mesh at the next heartbeat.\n */\nexport const GossipsubDhi = 12\n\n/**\n * GossipsubDscore affects how peers are selected when pruning a mesh due to over subscription.\n * At least GossipsubDscore of the retained peers will be high-scoring, while the remainder are\n * chosen randomly.\n */\nexport const GossipsubDscore = 4\n\n/**\n * GossipsubDout sets the quota for the number of outbound connections to maintain in a topic mesh.\n * When the mesh is pruned due to over subscription, we make sure that we have outbound connections\n * to at least GossipsubDout of the survivor peers. This prevents sybil attackers from overwhelming\n * our mesh with incoming connections.\n *\n * GossipsubDout must be set below GossipsubDlo, and must not exceed GossipsubD / 2.\n */\nexport const GossipsubDout = 2\n\n// Gossip parameters\n\n/**\n * GossipsubHistoryLength controls the size of the message cache used for gossip.\n * The message cache will remember messages for GossipsubHistoryLength heartbeats.\n */\nexport const GossipsubHistoryLength = 5\n\n/**\n * GossipsubHistoryGossip controls how many cached message ids we will advertise in\n * IHAVE gossip messages. When asked for our seen message IDs, we will return\n * only those from the most recent GossipsubHistoryGossip heartbeats. The slack between\n * GossipsubHistoryGossip and GossipsubHistoryLength allows us to avoid advertising messages\n * that will be expired by the time they're requested.\n *\n * GossipsubHistoryGossip must be less than or equal to GossipsubHistoryLength to\n * avoid a runtime panic.\n */\nexport const GossipsubHistoryGossip = 3\n\n/**\n * GossipsubDlazy affects how many peers we will emit gossip to at each heartbeat.\n * We will send gossip to at least GossipsubDlazy peers outside our mesh. The actual\n * number may be more, depending on GossipsubGossipFactor and how many peers we're\n * connected to.\n */\nexport const GossipsubDlazy = 6\n\n/**\n * GossipsubGossipFactor affects how many peers we will emit gossip to at each heartbeat.\n * We will send gossip to GossipsubGossipFactor * (total number of non-mesh peers), or\n * GossipsubDlazy, whichever is greater.\n */\nexport const GossipsubGossipFactor = 0.25\n\n/**\n * GossipsubGossipRetransmission controls how many times we will allow a peer to request\n * the same message id through IWANT gossip before we start ignoring them. This is designed\n * to prevent peers from spamming us with requests and wasting our resources.\n */\nexport const GossipsubGossipRetransmission = 3\n\n// Heartbeat interval\n\n/**\n * GossipsubHeartbeatInitialDelay is the short delay before the heartbeat timer begins\n * after the router is initialized.\n */\nexport const GossipsubHeartbeatInitialDelay = 100\n\n/**\n * GossipsubHeartbeatInterval controls the time between heartbeats.\n */\nexport const GossipsubHeartbeatInterval = second\n\n/**\n * GossipsubFanoutTTL controls how long we keep track of the fanout state. If it's been\n * GossipsubFanoutTTL since we've published to a topic that we're not subscribed to,\n * we'll delete the fanout map for that topic.\n */\nexport const GossipsubFanoutTTL = minute\n\n/**\n * GossipsubPrunePeers controls the number of peers to include in prune Peer eXchange.\n * When we prune a peer that's eligible for PX (has a good score, etc), we will try to\n * send them signed peer records for up to GossipsubPrunePeers other peers that we\n * know of.\n */\nexport const GossipsubPrunePeers = 16\n\n/**\n * GossipsubPruneBackoff controls the backoff time for pruned peers. This is how long\n * a peer must wait before attempting to graft into our mesh again after being pruned.\n * When pruning a peer, we send them our value of GossipsubPruneBackoff so they know\n * the minimum time to wait. Peers running older versions may not send a backoff time,\n * so if we receive a prune message without one, we will wait at least GossipsubPruneBackoff\n * before attempting to re-graft.\n */\nexport const GossipsubPruneBackoff = minute\n\n/**\n * Backoff to use when unsuscribing from a topic. Should not resubscribe to this topic before it expired.\n */\nexport const GossipsubUnsubscribeBackoff = 10 * second\n\n/**\n * GossipsubPruneBackoffTicks is the number of heartbeat ticks for attempting to prune expired\n * backoff timers.\n */\nexport const GossipsubPruneBackoffTicks = 15\n\n/**\n * GossipsubConnectors controls the number of active connection attempts for peers obtained through PX.\n */\nexport const GossipsubConnectors = 8\n\n/**\n * GossipsubMaxPendingConnections sets the maximum number of pending connections for peers attempted through px.\n */\nexport const GossipsubMaxPendingConnections = 128\n\n/**\n * GossipsubConnectionTimeout controls the timeout for connection attempts.\n */\nexport const GossipsubConnectionTimeout = 30 * second\n\n/**\n * GossipsubDirectConnectTicks is the number of heartbeat ticks for attempting to reconnect direct peers\n * that are not currently connected.\n */\nexport const GossipsubDirectConnectTicks = 300\n\n/**\n * GossipsubDirectConnectInitialDelay is the initial delay before opening connections to direct peers\n */\nexport const GossipsubDirectConnectInitialDelay = second\n\n/**\n * GossipsubOpportunisticGraftTicks is the number of heartbeat ticks for attempting to improve the mesh\n * with opportunistic grafting. Every GossipsubOpportunisticGraftTicks we will attempt to select some\n * high-scoring mesh peers to replace lower-scoring ones, if the median score of our mesh peers falls\n * below a threshold\n */\nexport const GossipsubOpportunisticGraftTicks = 60\n\n/**\n * GossipsubOpportunisticGraftPeers is the number of peers to opportunistically graft.\n */\nexport const GossipsubOpportunisticGraftPeers = 2\n\n/**\n * If a GRAFT comes before GossipsubGraftFloodThreshold has elapsed since the last PRUNE,\n * then there is an extra score penalty applied to the peer through P7.\n */\nexport const GossipsubGraftFloodThreshold = 10 * second\n\n/**\n * GossipsubMaxIHaveLength is the maximum number of messages to include in an IHAVE message.\n * Also controls the maximum number of IHAVE ids we will accept and request with IWANT from a\n * peer within a heartbeat, to protect from IHAVE floods. You should adjust this value from the\n * default if your system is pushing more than 5000 messages in GossipsubHistoryGossip heartbeats;\n * with the defaults this is 1666 messages/s.\n */\nexport const GossipsubMaxIHaveLength = 5000\n\n/**\n * GossipsubMaxIHaveMessages is the maximum number of IHAVE messages to accept from a peer within a heartbeat.\n */\nexport const GossipsubMaxIHaveMessages = 10\n\n/**\n * Time to wait for a message requested through IWANT following an IHAVE advertisement.\n * If the message is not received within this window, a broken promise is declared and\n * the router may apply bahavioural penalties.\n */\nexport const GossipsubIWantFollowupTime = 3 * second\n\n/**\n * Time in milliseconds to keep message ids in the seen cache\n */\nexport const GossipsubSeenTTL = 2 * minute\n\nexport const TimeCacheDuration = 120 * 1000\n\nexport const ERR_TOPIC_VALIDATOR_REJECT = 'ERR_TOPIC_VALIDATOR_REJECT'\nexport const ERR_TOPIC_VALIDATOR_IGNORE = 'ERR_TOPIC_VALIDATOR_IGNORE'\n\n/**\n * If peer score is better than this, we accept messages from this peer\n * within ACCEPT_FROM_WHITELIST_DURATION_MS from the last time computing score.\n **/\nexport const ACCEPT_FROM_WHITELIST_THRESHOLD_SCORE = 0\n\n/**\n * If peer score >= ACCEPT_FROM_WHITELIST_THRESHOLD_SCORE, accept up to this\n * number of messages from that peer.\n */\nexport const ACCEPT_FROM_WHITELIST_MAX_MESSAGES = 128\n\n/**\n * If peer score >= ACCEPT_FROM_WHITELIST_THRESHOLD_SCORE, accept messages from\n * this peer up to this time duration.\n */\nexport const ACCEPT_FROM_WHITELIST_DURATION_MS = 1000\n\n/**\n * The default MeshMessageDeliveriesWindow to be used in metrics.\n */\nexport const DEFAULT_METRIC_MESH_MESSAGE_DELIVERIES_WINDOWS = 1000\n\n/** Wait for 1 more heartbeats before clearing a backoff */\nexport const BACKOFF_SLACK = 1\n", "import protobuf from 'protobufjs/minimal.js'\nimport type { IRPC, RPC } from './rpc.js'\n\nexport interface DecodeRPCLimits {\n  maxSubscriptions: number\n  maxMessages: number\n  maxIhaveMessageIDs: number\n  maxIwantMessageIDs: number\n  maxControlMessages: number\n  maxPeerInfos: number\n}\n\nexport const defaultDecodeRpcLimits: DecodeRPCLimits = {\n  maxSubscriptions: Infinity,\n  maxMessages: Infinity,\n  maxIhaveMessageIDs: Infinity,\n  maxIwantMessageIDs: Infinity,\n  maxControlMessages: Infinity,\n  maxPeerInfos: Infinity\n}\n\n/**\n * Copied code from src/message/rpc.cjs but with decode limits to prevent OOM attacks\n */\nexport function decodeRpc (bytes: Uint8Array, opts: DecodeRPCLimits): IRPC {\n  // Mutate to use the option as stateful counter. Must limit the total count of messageIDs across all IWANT, IHAVE\n  // else one count put 100 messageIDs into each 100 IWANT and \"get around\" the limit\n  opts = { ...opts }\n\n  const r = protobuf.Reader.create(bytes)\n  const l = bytes.length\n\n  const c = l === undefined ? r.len : r.pos + l\n  const m: IRPC = {}\n  while (r.pos < c) {\n    const t = r.uint32()\n    switch (t >>> 3) {\n      case 1:\n        if (!((m.subscriptions != null) && (m.subscriptions.length > 0))) m.subscriptions = []\n        if (m.subscriptions.length < opts.maxSubscriptions) m.subscriptions.push(decodeSubOpts(r, r.uint32()))\n        else r.skipType(t & 7)\n        break\n      case 2:\n        if (!((m.messages != null) && (m.messages.length > 0))) m.messages = []\n        if (m.messages.length < opts.maxMessages) m.messages.push(decodeMessage(r, r.uint32()))\n        else r.skipType(t & 7)\n        break\n      case 3:\n        m.control = decodeControlMessage(r, r.uint32(), opts)\n        break\n      default:\n        r.skipType(t & 7)\n        break\n    }\n  }\n  return m\n}\n\nfunction decodeSubOpts (r: protobuf.Reader, l: number): RPC.ISubOpts {\n  const c = l === undefined ? r.len : r.pos + l\n  const m: RPC.ISubOpts = {}\n  while (r.pos < c) {\n    const t = r.uint32()\n    switch (t >>> 3) {\n      case 1:\n        m.subscribe = r.bool()\n        break\n      case 2:\n        m.topic = r.string()\n        break\n      default:\n        r.skipType(t & 7)\n        break\n    }\n  }\n  return m\n}\n\nfunction decodeMessage (r: protobuf.Reader, l: number): RPC.IMessage {\n  const c = l === undefined ? r.len : r.pos + l\n  // eslint-disable-next-line @typescript-eslint/consistent-type-assertions\n  const m = {} as RPC.IMessage\n  while (r.pos < c) {\n    const t = r.uint32()\n    switch (t >>> 3) {\n      case 1:\n        m.from = r.bytes()\n        break\n      case 2:\n        m.data = r.bytes()\n        break\n      case 3:\n        m.seqno = r.bytes()\n        break\n      case 4:\n        m.topic = r.string()\n        break\n      case 5:\n        m.signature = r.bytes()\n        break\n      case 6:\n        m.key = r.bytes()\n        break\n      default:\n        r.skipType(t & 7)\n        break\n    }\n  }\n  // eslint-disable-next-line @typescript-eslint/strict-boolean-expressions\n  if (!m.topic) throw Error(\"missing required 'topic'\")\n  return m\n}\n\nfunction decodeControlMessage (r: protobuf.Reader, l: number, opts: DecodeRPCLimits): RPC.IControlMessage {\n  const c = l === undefined ? r.len : r.pos + l\n  // eslint-disable-next-line @typescript-eslint/consistent-type-assertions\n  const m = {} as RPC.IControlMessage\n  while (r.pos < c) {\n    const t = r.uint32()\n    switch (t >>> 3) {\n      case 1:\n        if (!((m.ihave != null) && (m.ihave.length > 0))) m.ihave = []\n        if (m.ihave.length < opts.maxControlMessages) m.ihave.push(decodeControlIHave(r, r.uint32(), opts))\n        else r.skipType(t & 7)\n        break\n      case 2:\n        if (!((m.iwant != null) && (m.iwant.length > 0))) m.iwant = []\n        if (m.iwant.length < opts.maxControlMessages) m.iwant.push(decodeControlIWant(r, r.uint32(), opts))\n        else r.skipType(t & 7)\n        break\n      case 3:\n        if (!((m.graft != null) && (m.graft.length > 0))) m.graft = []\n        if (m.graft.length < opts.maxControlMessages) m.graft.push(decodeControlGraft(r, r.uint32()))\n        else r.skipType(t & 7)\n        break\n      case 4:\n        if (!((m.prune != null) && (m.prune.length > 0))) m.prune = []\n        if (m.prune.length < opts.maxControlMessages) m.prune.push(decodeControlPrune(r, r.uint32(), opts))\n        else r.skipType(t & 7)\n        break\n      default:\n        r.skipType(t & 7)\n        break\n    }\n  }\n  return m\n}\n\nfunction decodeControlIHave (r: protobuf.Reader, l: number, opts: DecodeRPCLimits): RPC.IControlIHave {\n  const c = l === undefined ? r.len : r.pos + l\n  // eslint-disable-next-line @typescript-eslint/consistent-type-assertions\n  const m = {} as RPC.IControlIHave\n  while (r.pos < c) {\n    const t = r.uint32()\n    switch (t >>> 3) {\n      case 1:\n        m.topicID = r.string()\n        break\n      case 2:\n        if (!((m.messageIDs != null) && (m.messageIDs.length > 0))) m.messageIDs = []\n        if (opts.maxIhaveMessageIDs-- > 0) m.messageIDs.push(r.bytes())\n        else r.skipType(t & 7)\n        break\n      default:\n        r.skipType(t & 7)\n        break\n    }\n  }\n  return m\n}\n\nfunction decodeControlIWant (r: protobuf.Reader, l: number, opts: DecodeRPCLimits): RPC.IControlIWant {\n  const c = l === undefined ? r.len : r.pos + l\n  // eslint-disable-next-line @typescript-eslint/consistent-type-assertions\n  const m = {} as RPC.IControlIWant\n  while (r.pos < c) {\n    const t = r.uint32()\n    switch (t >>> 3) {\n      case 1:\n        if (!((m.messageIDs != null) && (m.messageIDs.length > 0))) m.messageIDs = []\n        if (opts.maxIwantMessageIDs-- > 0) m.messageIDs.push(r.bytes())\n        else r.skipType(t & 7)\n        break\n      default:\n        r.skipType(t & 7)\n        break\n    }\n  }\n  return m\n}\n\nfunction decodeControlGraft (r: protobuf.Reader, l: number): RPC.IControlGraft {\n  const c = l === undefined ? r.len : r.pos + l\n  // eslint-disable-next-line @typescript-eslint/consistent-type-assertions\n  const m = {} as RPC.IControlGraft\n  while (r.pos < c) {\n    const t = r.uint32()\n    switch (t >>> 3) {\n      case 1:\n        m.topicID = r.string()\n        break\n      default:\n        r.skipType(t & 7)\n        break\n    }\n  }\n  return m\n}\n\nfunction decodeControlPrune (r: protobuf.Reader, l: number, opts: DecodeRPCLimits): RPC.IControlPrune {\n  const c = l === undefined ? r.len : r.pos + l\n  // eslint-disable-next-line @typescript-eslint/consistent-type-assertions\n  const m = {} as RPC.IControlPrune\n  while (r.pos < c) {\n    const t = r.uint32()\n    switch (t >>> 3) {\n      case 1:\n        m.topicID = r.string()\n        break\n      case 2:\n        if (!((m.peers != null) && (m.peers.length > 0))) m.peers = []\n        if (opts.maxPeerInfos-- > 0) m.peers.push(decodePeerInfo(r, r.uint32()))\n        else r.skipType(t & 7)\n        break\n      case 3:\n        m.backoff = r.uint64() as unknown as number\n        break\n      default:\n        r.skipType(t & 7)\n        break\n    }\n  }\n  return m\n}\n\nfunction decodePeerInfo (r: protobuf.Reader, l: number): RPC.IPeerInfo {\n  const c = l === undefined ? r.len : r.pos + l\n  // eslint-disable-next-line @typescript-eslint/consistent-type-assertions\n  const m = {} as RPC.IPeerInfo\n  while (r.pos < c) {\n    const t = r.uint32()\n    switch (t >>> 3) {\n      case 1:\n        m.peerID = r.bytes()\n        break\n      case 2:\n        m.signedPeerRecord = r.bytes()\n        break\n      default:\n        r.skipType(t & 7)\n        break\n    }\n  }\n  return m\n}\n", "import cjs from \"./rpc.cjs\"\n\nexport const {RPC} = cjs\n", "import type { RPC } from './message/rpc.js'\nimport type { MessageId, MsgIdStr, PeerIdStr, TopicStr, MsgIdToStrFn } from './types.js'\n\nexport type CacheEntry = MessageId & {\n  topic: TopicStr\n}\n\nexport type MessageCacheRecord = Pick<MessageCacheEntry, 'message' | 'originatingPeers'>\n\ninterface MessageCacheEntry {\n  message: RPC.IMessage\n  /**\n   * Tracks if the message has been validated by the app layer and thus forwarded\n   */\n  validated: boolean\n  /**\n   * Tracks peers that sent this message before it has been validated by the app layer\n   */\n  originatingPeers: Set<PeerIdStr>\n  /**\n   * For every message and peer the number of times this peer asked for the message\n   */\n  iwantCounts: Map<PeerIdStr, number>\n}\n\nexport class MessageCache {\n  msgs = new Map<MsgIdStr, MessageCacheEntry>()\n\n  msgIdToStrFn: MsgIdToStrFn\n\n  history: CacheEntry[][] = []\n\n  /** Track with accounting of messages in the mcache that are not yet validated */\n  notValidatedCount = 0\n\n  /**\n   * Holds history of messages in timebounded history arrays\n   */\n  constructor (\n    /**\n     * The number of indices in the cache history used for gossiping. That means that a message\n     * won't get gossiped anymore when shift got called `gossip` many times after inserting the\n     * message in the cache.\n     */\n    private readonly gossip: number,\n    historyCapacity: number,\n    msgIdToStrFn: MsgIdToStrFn\n  ) {\n    this.msgIdToStrFn = msgIdToStrFn\n    for (let i = 0; i < historyCapacity; i++) {\n      this.history[i] = []\n    }\n  }\n\n  get size (): number {\n    return this.msgs.size\n  }\n\n  /**\n   * Adds a message to the current window and the cache\n   * Returns true if the message is not known and is inserted in the cache\n   */\n  put (messageId: MessageId, msg: RPC.IMessage, validated = false): boolean {\n    const { msgIdStr } = messageId\n    // Don't add duplicate entries to the cache.\n    if (this.msgs.has(msgIdStr)) {\n      return false\n    }\n\n    this.msgs.set(msgIdStr, {\n      message: msg,\n      validated,\n      originatingPeers: new Set(),\n      iwantCounts: new Map()\n    })\n\n    this.history[0].push({ ...messageId, topic: msg.topic })\n\n    if (!validated) {\n      this.notValidatedCount++\n    }\n\n    return true\n  }\n\n  observeDuplicate (msgId: MsgIdStr, fromPeerIdStr: PeerIdStr): void {\n    const entry = this.msgs.get(msgId)\n\n    if (\n      (entry != null) &&\n      // if the message is already validated, we don't need to store extra peers sending us\n      // duplicates as the message has already been forwarded\n      !entry.validated\n    ) {\n      entry.originatingPeers.add(fromPeerIdStr)\n    }\n  }\n\n  /**\n   * Retrieves a message from the cache by its ID, if it is still present\n   */\n  get (msgId: Uint8Array): RPC.IMessage | undefined {\n    return this.msgs.get(this.msgIdToStrFn(msgId))?.message\n  }\n\n  /**\n   * Increases the iwant count for the given message by one and returns the message together\n   * with the iwant if the message exists.\n   */\n  getWithIWantCount (msgIdStr: string, p: string): { msg: RPC.IMessage, count: number } | null {\n    const msg = this.msgs.get(msgIdStr)\n    if (msg == null) {\n      return null\n    }\n\n    const count = (msg.iwantCounts.get(p) ?? 0) + 1\n    msg.iwantCounts.set(p, count)\n\n    return { msg: msg.message, count }\n  }\n\n  /**\n   * Retrieves a list of message IDs for a set of topics\n   */\n  getGossipIDs (topics: Set<string>): Map<string, Uint8Array[]> {\n    const msgIdsByTopic = new Map<string, Uint8Array[]>()\n    for (let i = 0; i < this.gossip; i++) {\n      this.history[i].forEach((entry) => {\n        const msg = this.msgs.get(entry.msgIdStr)\n        if ((msg?.validated ?? false) && topics.has(entry.topic)) {\n          let msgIds = msgIdsByTopic.get(entry.topic)\n          if (msgIds == null) {\n            msgIds = []\n            msgIdsByTopic.set(entry.topic, msgIds)\n          }\n          msgIds.push(entry.msgId)\n        }\n      })\n    }\n\n    return msgIdsByTopic\n  }\n\n  /**\n   * Gets a message with msgId and tags it as validated.\n   * This function also returns the known peers that have sent us this message. This is used to\n   * prevent us sending redundant messages to peers who have already propagated it.\n   */\n  validate (msgId: MsgIdStr): MessageCacheRecord | null {\n    const entry = this.msgs.get(msgId)\n    if (entry == null) {\n      return null\n    }\n\n    if (!entry.validated) {\n      this.notValidatedCount--\n    }\n\n    const { message, originatingPeers } = entry\n    entry.validated = true\n    // Clear the known peers list (after a message is validated, it is forwarded and we no\n    // longer need to store the originating peers).\n    entry.originatingPeers = new Set()\n    return { message, originatingPeers }\n  }\n\n  /**\n   * Shifts the current window, discarding messages older than this.history.length of the cache\n   */\n  shift (): void {\n    const lastCacheEntries = this.history[this.history.length - 1]\n    lastCacheEntries.forEach((cacheEntry) => {\n      const entry = this.msgs.get(cacheEntry.msgIdStr)\n      if (entry != null) {\n        this.msgs.delete(cacheEntry.msgIdStr)\n        if (!entry.validated) {\n          this.notValidatedCount--\n        }\n      }\n    })\n\n    this.history.pop()\n    this.history.unshift([])\n  }\n\n  remove (msgId: MsgIdStr): MessageCacheRecord | null {\n    const entry = this.msgs.get(msgId)\n    if (entry == null) {\n      return null\n    }\n\n    // Keep the message on the history vector, it will be dropped on a shift()\n    this.msgs.delete(msgId)\n    return entry\n  }\n}\n", "import { type Message, TopicValidatorResult, type PrivateKey, type PeerId } from '@libp2p/interface'\nimport type { RPC } from './message/rpc.js'\nimport type { Multiaddr } from '@multiformats/multiaddr'\n\nexport type MsgIdStr = string\nexport type PeerIdStr = string\nexport type TopicStr = string\nexport type IPStr = string\n\nexport interface AddrInfo {\n  id: PeerId\n  addrs: Multiaddr[]\n}\n\n/**\n * Compute a local non-spec'ed msg-id for faster de-duplication of seen messages.\n * Used exclusively for a local seen_cache\n */\nexport interface FastMsgIdFn { (msg: RPC.IMessage): string | number }\n\n/**\n * By default, gossipsub only provide a browser friendly function to convert Uint8Array message id to string.\n * Application could use this option to provide a more efficient function.\n */\nexport interface MsgIdToStrFn { (msgId: Uint8Array): string }\n\n/**\n * Compute spec'ed msg-id. Used for IHAVE / IWANT messages\n */\nexport interface MsgIdFn {\n  (msg: Message): Promise<Uint8Array> | Uint8Array\n}\n\nexport interface DataTransform {\n  /**\n   * Takes the data published by peers on a topic and transforms the data.\n   * Should be the reverse of outboundTransform(). Example:\n   * - `inboundTransform()`: decompress snappy payload\n   * - `outboundTransform()`: compress snappy payload\n   */\n  inboundTransform(topic: TopicStr, data: Uint8Array): Uint8Array\n\n  /**\n   * Takes the data to be published (a topic and associated data) transforms the data. The\n   * transformed data will then be used to create a `RawGossipsubMessage` to be sent to peers.\n   */\n  outboundTransform(topic: TopicStr, data: Uint8Array): Uint8Array\n}\n\nexport enum SignaturePolicy {\n  /**\n   * On the producing side:\n   * - Build messages with the signature, key (from may be enough for certain inlineable public key types), from and seqno fields.\n   *\n   * On the consuming side:\n   * - Enforce the fields to be present, reject otherwise.\n   * - Propagate only if the fields are valid and signature can be verified, reject otherwise.\n   */\n  StrictSign = 'StrictSign',\n  /**\n   * On the producing side:\n   * - Build messages without the signature, key, from and seqno fields.\n   * - The corresponding protobuf key-value pairs are absent from the marshalled message, not just empty.\n   *\n   * On the consuming side:\n   * - Enforce the fields to be absent, reject otherwise.\n   * - Propagate only if the fields are absent, reject otherwise.\n   * - A message_id function will not be able to use the above fields, and should instead rely on the data field. A commonplace strategy is to calculate a hash.\n   */\n  StrictNoSign = 'StrictNoSign'\n}\n\nexport interface PublishOpts {\n  allowPublishToZeroPeers?: boolean\n  ignoreDuplicatePublishError?: boolean\n  /** serialize message once and send to all peers without control messages */\n  batchPublish?: boolean\n}\n\nexport enum PublishConfigType {\n  Signing,\n  Anonymous\n}\n\nexport type PublishConfig =\n  | {\n    type: PublishConfigType.Signing\n    author: PeerId\n    key: Uint8Array\n    privateKey: PrivateKey\n  }\n  | { type: PublishConfigType.Anonymous }\n\nexport type RejectReasonObj =\n  | { reason: RejectReason.Error, error: ValidateError }\n  | { reason: Exclude<RejectReason, RejectReason.Error> }\n\nexport enum RejectReason {\n  /**\n   * The message failed the configured validation during decoding.\n   * SelfOrigin is considered a ValidationError\n   */\n  Error = 'error',\n  /**\n   * Custom validator fn reported status IGNORE.\n   */\n  Ignore = 'ignore',\n  /**\n   * Custom validator fn reported status REJECT.\n   */\n  Reject = 'reject',\n  /**\n   * The peer that sent the message OR the source from field is blacklisted.\n   * Causes messages to be ignored, not penalized, neither do score record creation.\n   */\n  Blacklisted = 'blacklisted'\n}\n\nexport enum ValidateError {\n  /// The message has an invalid signature,\n  InvalidSignature = 'invalid_signature',\n  /// The sequence number was the incorrect size\n  InvalidSeqno = 'invalid_seqno',\n  /// The PeerId was invalid\n  InvalidPeerId = 'invalid_peerid',\n  /// Signature existed when validation has been sent to\n  /// [`crate::behaviour::MessageAuthenticity::Anonymous`].\n  SignaturePresent = 'signature_present',\n  /// Sequence number existed when validation has been sent to\n  /// [`crate::behaviour::MessageAuthenticity::Anonymous`].\n  SeqnoPresent = 'seqno_present',\n  /// Message source existed when validation has been sent to\n  /// [`crate::behaviour::MessageAuthenticity::Anonymous`].\n  FromPresent = 'from_present',\n  /// The data transformation failed.\n  TransformFailed = 'transform_failed'\n}\n\nexport enum MessageStatus {\n  duplicate = 'duplicate',\n  invalid = 'invalid',\n  valid = 'valid'\n}\n\n/**\n * Store both Uint8Array and string message id so that we don't have to convert data between the two.\n * See https://github.com/ChainSafe/js-libp2p-gossipsub/pull/274\n */\nexport interface MessageId {\n  msgId: Uint8Array\n  msgIdStr: MsgIdStr\n}\n\n/**\n * Typesafe conversion of MessageAcceptance -> RejectReason. TS ensures all values covered\n */\nexport function rejectReasonFromAcceptance (\n  acceptance: Exclude<TopicValidatorResult, TopicValidatorResult.Accept>\n): RejectReason.Ignore | RejectReason.Reject {\n  switch (acceptance) {\n    case TopicValidatorResult.Ignore:\n      return RejectReason.Ignore\n    case TopicValidatorResult.Reject:\n      return RejectReason.Reject\n    default:\n      throw new Error('Unreachable')\n  }\n}\n", "import { TopicValidatorResult } from '@libp2p/interface'\nimport {\n  MessageStatus,\n  type PeerIdStr,\n  RejectReason,\n  type RejectReasonObj,\n  type TopicStr,\n  type ValidateError\n} from './types.js'\nimport type { IRPC } from './message/rpc.js'\nimport type { PeerScoreThresholds } from './score/peer-score-thresholds.js'\n\n/** Topic label as provided in `topicStrToLabel` */\nexport type TopicLabel = string\nexport type TopicStrToLabel = Map<TopicStr, TopicLabel>\n\nexport enum MessageSource {\n  forward = 'forward',\n  publish = 'publish'\n}\n\ntype NoLabels = Record<string, never>\ntype LabelsGeneric = Record<string, string | number>\ntype LabelKeys<Labels extends LabelsGeneric> = Extract<keyof Labels, string>\ninterface CollectFn<Labels extends LabelsGeneric> { (metric: Gauge<Labels>): void }\n\nexport interface Gauge<Labels extends LabelsGeneric = NoLabels> {\n  inc: NoLabels extends Labels ? (value?: number) => void : (labels: Labels, value?: number) => void\n  set: NoLabels extends Labels ? (value: number) => void : (labels: Labels, value: number) => void\n\n  addCollect(collectFn: CollectFn<Labels>): void\n}\n\nexport interface Histogram<Labels extends LabelsGeneric = NoLabels> {\n  startTimer(): () => void\n\n  observe: NoLabels extends Labels ? (value: number) => void : (labels: Labels, value: number) => void\n\n  reset(): void\n}\n\nexport interface AvgMinMax<Labels extends LabelsGeneric = NoLabels> {\n  set: NoLabels extends Labels ? (values: number[]) => void : (labels: Labels, values: number[]) => void\n}\n\nexport type GaugeConfig<Labels extends LabelsGeneric> = {\n  name: string\n  help: string\n} & (NoLabels extends Labels ? { labelNames?: never } : { labelNames: [LabelKeys<Labels>, ...Array<LabelKeys<Labels>>] })\n\nexport type HistogramConfig<Labels extends LabelsGeneric> = GaugeConfig<Labels> & {\n  buckets?: number[]\n}\n\nexport type AvgMinMaxConfig<Labels extends LabelsGeneric> = GaugeConfig<Labels>\n\nexport interface MetricsRegister {\n  gauge<Labels extends LabelsGeneric = NoLabels>(config: GaugeConfig<Labels>): Gauge<Labels>\n  histogram<Labels extends LabelsGeneric = NoLabels>(config: HistogramConfig<Labels>): Histogram<Labels>\n  avgMinMax<Labels extends LabelsGeneric = NoLabels>(config: AvgMinMaxConfig<Labels>): AvgMinMax<Labels>\n}\n\nexport enum InclusionReason {\n  /** Peer was a fanaout peer. */\n  Fanout = 'fanout',\n  /** Included from random selection. */\n  Random = 'random',\n  /** Peer subscribed. */\n  Subscribed = 'subscribed',\n  /** On heartbeat, peer was included to fill the outbound quota. */\n  Outbound = 'outbound',\n  /** On heartbeat, not enough peers in mesh */\n  NotEnough = 'not_enough',\n  /** On heartbeat opportunistic grafting due to low mesh score */\n  Opportunistic = 'opportunistic'\n}\n\n/// Reasons why a peer was removed from the mesh.\nexport enum ChurnReason {\n  /// Peer disconnected.\n  Dc = 'disconnected',\n  /// Peer had a bad score.\n  BadScore = 'bad_score',\n  /// Peer sent a PRUNE.\n  Prune = 'prune',\n  /// Too many peers.\n  Excess = 'excess'\n}\n\n/// Kinds of reasons a peer's score has been penalized\nexport enum ScorePenalty {\n  /// A peer grafted before waiting the back-off time.\n  GraftBackoff = 'graft_backoff',\n  /// A Peer did not respond to an IWANT request in time.\n  BrokenPromise = 'broken_promise',\n  /// A Peer did not send enough messages as expected.\n  MessageDeficit = 'message_deficit',\n  /// Too many peers under one IP address.\n  IPColocation = 'IP_colocation'\n}\n\nexport enum IHaveIgnoreReason {\n  LowScore = 'low_score',\n  MaxIhave = 'max_ihave',\n  MaxIasked = 'max_iasked'\n}\n\nexport enum ScoreThreshold {\n  graylist = 'graylist',\n  publish = 'publish',\n  gossip = 'gossip',\n  mesh = 'mesh'\n}\n\nexport type PeersByScoreThreshold = Record<ScoreThreshold, number>\n\nexport interface ToSendGroupCount {\n  direct: number\n  floodsub: number\n  mesh: number\n  fanout: number\n}\n\nexport interface ToAddGroupCount {\n  fanout: number\n  random: number\n}\n\nexport type PromiseDeliveredStats =\n  | { expired: false, requestedCount: number, maxDeliverMs: number }\n  | { expired: true, maxDeliverMs: number }\n\nexport interface TopicScoreWeights<T> { p1w: T, p2w: T, p3w: T, p3bw: T, p4w: T }\nexport interface ScoreWeights<T> {\n  byTopic: Map<TopicLabel, TopicScoreWeights<T>>\n  p5w: T\n  p6w: T\n  p7w: T\n  score: T\n}\n\nexport type Metrics = ReturnType<typeof getMetrics>\n\n/**\n * A collection of metrics used throughout the Gossipsub behaviour.\n * NOTE: except for special reasons, do not add more than 1 label for frequent metrics,\n * there's a performance penalty as of June 2023.\n */\n// eslint-disable-next-line @typescript-eslint/explicit-module-boundary-types, @typescript-eslint/explicit-function-return-type\nexport function getMetrics (\n  register: MetricsRegister,\n  topicStrToLabel: TopicStrToLabel,\n  opts: { gossipPromiseExpireSec: number, behaviourPenaltyThreshold: number, maxMeshMessageDeliveriesWindowSec: number }\n) {\n  // Using function style instead of class to prevent having to re-declare all MetricsPrometheus types.\n\n  return {\n    /* Metrics for static config */\n    protocolsEnabled: register.gauge<{ protocol: string }>({\n      name: 'gossipsub_protocol',\n      help: 'Status of enabled protocols',\n      labelNames: ['protocol']\n    }),\n\n    /* Metrics per known topic */\n    /**\n     * Status of our subscription to this topic. This metric allows analyzing other topic metrics\n     * filtered by our current subscription status.\n     * = rust-libp2p `topic_subscription_status` */\n    topicSubscriptionStatus: register.gauge<{ topicStr: TopicStr }>({\n      name: 'gossipsub_topic_subscription_status',\n      help: 'Status of our subscription to this topic',\n      labelNames: ['topicStr']\n    }),\n    /** Number of peers subscribed to each topic. This allows us to analyze a topic's behaviour\n     * regardless of our subscription status. */\n    topicPeersCount: register.gauge<{ topicStr: TopicStr }>({\n      name: 'gossipsub_topic_peer_count',\n      help: 'Number of peers subscribed to each topic',\n      labelNames: ['topicStr']\n    }),\n\n    /* Metrics regarding mesh state */\n    /**\n     * Number of peers in our mesh. This metric should be updated with the count of peers for a\n     * topic in the mesh regardless of inclusion and churn events.\n     * = rust-libp2p `mesh_peer_counts` */\n    meshPeerCounts: register.gauge<{ topicStr: TopicStr }>({\n      name: 'gossipsub_mesh_peer_count',\n      help: 'Number of peers in our mesh',\n      labelNames: ['topicStr']\n    }),\n    /**\n     * Number of times we include peers in a topic mesh for different reasons.\n     * = rust-libp2p `mesh_peer_inclusion_events` */\n    meshPeerInclusionEventsFanout: register.gauge<{ topic: TopicLabel }>({\n      name: 'gossipsub_mesh_peer_inclusion_events_fanout_total',\n      help: 'Number of times we include peers in a topic mesh for fanout reasons',\n      labelNames: ['topic']\n    }),\n    meshPeerInclusionEventsRandom: register.gauge<{ topic: TopicLabel }>({\n      name: 'gossipsub_mesh_peer_inclusion_events_random_total',\n      help: 'Number of times we include peers in a topic mesh for random reasons',\n      labelNames: ['topic']\n    }),\n    meshPeerInclusionEventsSubscribed: register.gauge<{ topic: TopicLabel }>({\n      name: 'gossipsub_mesh_peer_inclusion_events_subscribed_total',\n      help: 'Number of times we include peers in a topic mesh for subscribed reasons',\n      labelNames: ['topic']\n    }),\n    meshPeerInclusionEventsOutbound: register.gauge<{ topic: TopicLabel }>({\n      name: 'gossipsub_mesh_peer_inclusion_events_outbound_total',\n      help: 'Number of times we include peers in a topic mesh for outbound reasons',\n      labelNames: ['topic']\n    }),\n    meshPeerInclusionEventsNotEnough: register.gauge<{ topic: TopicLabel }>({\n      name: 'gossipsub_mesh_peer_inclusion_events_not_enough_total',\n      help: 'Number of times we include peers in a topic mesh for not_enough reasons',\n      labelNames: ['topic']\n    }),\n    meshPeerInclusionEventsOpportunistic: register.gauge<{ topic: TopicLabel }>({\n      name: 'gossipsub_mesh_peer_inclusion_events_opportunistic_total',\n      help: 'Number of times we include peers in a topic mesh for opportunistic reasons',\n      labelNames: ['topic']\n    }),\n    meshPeerInclusionEventsUnknown: register.gauge<{ topic: TopicLabel }>({\n      name: 'gossipsub_mesh_peer_inclusion_events_unknown_total',\n      help: 'Number of times we include peers in a topic mesh for unknown reasons',\n      labelNames: ['topic']\n    }),\n    /**\n     * Number of times we remove peers in a topic mesh for different reasons.\n     * = rust-libp2p `mesh_peer_churn_events` */\n    meshPeerChurnEventsDisconnected: register.gauge<{ topic: TopicLabel }>({\n      name: 'gossipsub_peer_churn_events_disconnected_total',\n      help: 'Number of times we remove peers in a topic mesh for disconnected reasons',\n      labelNames: ['topic']\n    }),\n    meshPeerChurnEventsBadScore: register.gauge<{ topic: TopicLabel }>({\n      name: 'gossipsub_peer_churn_events_bad_score_total',\n      help: 'Number of times we remove peers in a topic mesh for bad_score reasons',\n      labelNames: ['topic']\n    }),\n    meshPeerChurnEventsPrune: register.gauge<{ topic: TopicLabel }>({\n      name: 'gossipsub_peer_churn_events_prune_total',\n      help: 'Number of times we remove peers in a topic mesh for prune reasons',\n      labelNames: ['topic']\n    }),\n    meshPeerChurnEventsExcess: register.gauge<{ topic: TopicLabel }>({\n      name: 'gossipsub_peer_churn_events_excess_total',\n      help: 'Number of times we remove peers in a topic mesh for excess reasons',\n      labelNames: ['topic']\n    }),\n    meshPeerChurnEventsUnknown: register.gauge<{ topic: TopicLabel }>({\n      name: 'gossipsub_peer_churn_events_unknown_total',\n      help: 'Number of times we remove peers in a topic mesh for unknown reasons',\n      labelNames: ['topic']\n    }),\n\n    /* General Metrics */\n    /**\n     * Gossipsub supports floodsub, gossipsub v1.0 and gossipsub v1.1. Peers are classified based\n     * on which protocol they support. This metric keeps track of the number of peers that are\n     * connected of each type. */\n    peersPerProtocol: register.gauge<{ protocol: string }>({\n      name: 'gossipsub_peers_per_protocol_count',\n      help: 'Peers connected for each topic',\n      labelNames: ['protocol']\n    }),\n    /** The time it takes to complete one iteration of the heartbeat. */\n    heartbeatDuration: register.histogram({\n      name: 'gossipsub_heartbeat_duration_seconds',\n      help: 'The time it takes to complete one iteration of the heartbeat',\n      // Should take <10ms, over 1s it's a huge issue that needs debugging, since a heartbeat will be cancelled\n      buckets: [0.01, 0.1, 1]\n    }),\n    /** Heartbeat run took longer than heartbeat interval so next is skipped */\n    heartbeatSkipped: register.gauge({\n      name: 'gossipsub_heartbeat_skipped',\n      help: 'Heartbeat run took longer than heartbeat interval so next is skipped'\n    }),\n\n    /**\n     * Message validation results for each topic.\n     * Invalid == Reject?\n     * = rust-libp2p `invalid_messages`, `accepted_messages`, `ignored_messages`, `rejected_messages` */\n    acceptedMessagesTotal: register.gauge<{ topic: TopicLabel }>({\n      name: 'gossipsub_accepted_messages_total',\n      help: 'Total accepted messages for each topic',\n      labelNames: ['topic']\n    }),\n    ignoredMessagesTotal: register.gauge<{ topic: TopicLabel }>({\n      name: 'gossipsub_ignored_messages_total',\n      help: 'Total ignored messages for each topic',\n      labelNames: ['topic']\n    }),\n    rejectedMessagesTotal: register.gauge<{ topic: TopicLabel }>({\n      name: 'gossipsub_rejected_messages_total',\n      help: 'Total rejected messages for each topic',\n      labelNames: ['topic']\n    }),\n    unknownValidationResultsTotal: register.gauge<{ topic: TopicLabel }>({\n      name: 'gossipsub_unknown_validation_results_total',\n      help: 'Total unknown validation results for each topic',\n      labelNames: ['topic']\n    }),\n    /**\n     * When the user validates a message, it tries to re propagate it to its mesh peers. If the\n     * message expires from the memcache before it can be validated, we count this a cache miss\n     * and it is an indicator that the memcache size should be increased.\n     * = rust-libp2p `mcache_misses` */\n    asyncValidationMcacheHit: register.gauge<{ hit: 'hit' | 'miss' }>({\n      name: 'gossipsub_async_validation_mcache_hit_total',\n      help: 'Async validation result reported by the user layer',\n      labelNames: ['hit']\n    }),\n\n    asyncValidationDelayFromFirstSeenSec: register.histogram({\n      name: 'gossipsub_async_validation_delay_from_first_seen',\n      help: 'Async validation report delay from first seen in second',\n      buckets: [0.01, 0.03, 0.1, 0.3, 1, 3, 10]\n    }),\n\n    asyncValidationUnknownFirstSeen: register.gauge({\n      name: 'gossipsub_async_validation_unknown_first_seen_count_total',\n      help: 'Async validation report unknown first seen value for message'\n    }),\n\n    // peer stream\n    peerReadStreamError: register.gauge({\n      name: 'gossipsub_peer_read_stream_err_count_total',\n      help: 'Peer read stream error'\n    }),\n\n    // RPC outgoing. Track byte length + data structure sizes\n    rpcRecvBytes: register.gauge({ name: 'gossipsub_rpc_recv_bytes_total', help: 'RPC recv' }),\n    rpcRecvCount: register.gauge({ name: 'gossipsub_rpc_recv_count_total', help: 'RPC recv' }),\n    rpcRecvSubscription: register.gauge({ name: 'gossipsub_rpc_recv_subscription_total', help: 'RPC recv' }),\n    rpcRecvMessage: register.gauge({ name: 'gossipsub_rpc_recv_message_total', help: 'RPC recv' }),\n    rpcRecvControl: register.gauge({ name: 'gossipsub_rpc_recv_control_total', help: 'RPC recv' }),\n    rpcRecvIHave: register.gauge({ name: 'gossipsub_rpc_recv_ihave_total', help: 'RPC recv' }),\n    rpcRecvIWant: register.gauge({ name: 'gossipsub_rpc_recv_iwant_total', help: 'RPC recv' }),\n    rpcRecvGraft: register.gauge({ name: 'gossipsub_rpc_recv_graft_total', help: 'RPC recv' }),\n    rpcRecvPrune: register.gauge({ name: 'gossipsub_rpc_recv_prune_total', help: 'RPC recv' }),\n    rpcDataError: register.gauge({ name: 'gossipsub_rpc_data_err_count_total', help: 'RPC data error' }),\n    rpcRecvError: register.gauge({ name: 'gossipsub_rpc_recv_err_count_total', help: 'RPC recv error' }),\n\n    /** Total count of RPC dropped because acceptFrom() == false */\n    rpcRecvNotAccepted: register.gauge({\n      name: 'gossipsub_rpc_rcv_not_accepted_total',\n      help: 'Total count of RPC dropped because acceptFrom() == false'\n    }),\n\n    // RPC incoming. Track byte length + data structure sizes\n    rpcSentBytes: register.gauge({ name: 'gossipsub_rpc_sent_bytes_total', help: 'RPC sent' }),\n    rpcSentCount: register.gauge({ name: 'gossipsub_rpc_sent_count_total', help: 'RPC sent' }),\n    rpcSentSubscription: register.gauge({ name: 'gossipsub_rpc_sent_subscription_total', help: 'RPC sent' }),\n    rpcSentMessage: register.gauge({ name: 'gossipsub_rpc_sent_message_total', help: 'RPC sent' }),\n    rpcSentControl: register.gauge({ name: 'gossipsub_rpc_sent_control_total', help: 'RPC sent' }),\n    rpcSentIHave: register.gauge({ name: 'gossipsub_rpc_sent_ihave_total', help: 'RPC sent' }),\n    rpcSentIWant: register.gauge({ name: 'gossipsub_rpc_sent_iwant_total', help: 'RPC sent' }),\n    rpcSentGraft: register.gauge({ name: 'gossipsub_rpc_sent_graft_total', help: 'RPC sent' }),\n    rpcSentPrune: register.gauge({ name: 'gossipsub_rpc_sent_prune_total', help: 'RPC sent' }),\n\n    // publish message. Track peers sent to and bytes\n    /** Total count of msg published by topic */\n    msgPublishCount: register.gauge<{ topic: TopicLabel }>({\n      name: 'gossipsub_msg_publish_count_total',\n      help: 'Total count of msg published by topic',\n      labelNames: ['topic']\n    }),\n    /** Total count of peers that we publish a msg to */\n    msgPublishPeersByTopic: register.gauge<{ topic: TopicLabel }>({\n      name: 'gossipsub_msg_publish_peers_total',\n      help: 'Total count of peers that we publish a msg to',\n      labelNames: ['topic']\n    }),\n    /** Total count of peers (by group) that we publish a msg to */\n    directPeersPublishedTotal: register.gauge<{ topic: TopicLabel }>({\n      name: 'gossipsub_direct_peers_published_total',\n      help: 'Total direct peers that we publish a msg to',\n      labelNames: ['topic']\n    }),\n    floodsubPeersPublishedTotal: register.gauge<{ topic: TopicLabel }>({\n      name: 'gossipsub_floodsub_peers_published_total',\n      help: 'Total floodsub peers that we publish a msg to',\n      labelNames: ['topic']\n    }),\n    meshPeersPublishedTotal: register.gauge<{ topic: TopicLabel }>({\n      name: 'gossipsub_mesh_peers_published_total',\n      help: 'Total mesh peers that we publish a msg to',\n      labelNames: ['topic']\n    }),\n    fanoutPeersPublishedTotal: register.gauge<{ topic: TopicLabel }>({\n      name: 'gossipsub_fanout_peers_published_total',\n      help: 'Total fanout peers that we publish a msg to',\n      labelNames: ['topic']\n    }),\n    /** Total count of msg publish data.length bytes */\n    msgPublishBytes: register.gauge<{ topic: TopicLabel }>({\n      name: 'gossipsub_msg_publish_bytes_total',\n      help: 'Total count of msg publish data.length bytes',\n      labelNames: ['topic']\n    }),\n    /** Total time in seconds to publish a message */\n    msgPublishTime: register.histogram<{ topic: TopicLabel }>({\n      name: 'gossipsub_msg_publish_seconds',\n      help: 'Total time in seconds to publish a message',\n      buckets: [0.001, 0.002, 0.005, 0.01, 0.1, 0.5, 1],\n      labelNames: ['topic']\n    }),\n\n    /** Total count of msg forwarded by topic */\n    msgForwardCount: register.gauge<{ topic: TopicLabel }>({\n      name: 'gossipsub_msg_forward_count_total',\n      help: 'Total count of msg forwarded by topic',\n      labelNames: ['topic']\n    }),\n    /** Total count of peers that we forward a msg to */\n    msgForwardPeers: register.gauge<{ topic: TopicLabel }>({\n      name: 'gossipsub_msg_forward_peers_total',\n      help: 'Total count of peers that we forward a msg to',\n      labelNames: ['topic']\n    }),\n\n    /** Total count of recv msgs before any validation */\n    msgReceivedPreValidation: register.gauge<{ topic: TopicLabel }>({\n      name: 'gossipsub_msg_received_prevalidation_total',\n      help: 'Total count of recv msgs before any validation',\n      labelNames: ['topic']\n    }),\n    /** Total count of recv msgs error */\n    msgReceivedError: register.gauge<{ topic: TopicLabel }>({\n      name: 'gossipsub_msg_received_error_total',\n      help: 'Total count of recv msgs error',\n      labelNames: ['topic']\n    }),\n    /** Tracks distribution of recv msgs by duplicate, invalid, valid */\n    prevalidationInvalidTotal: register.gauge<{ topic: TopicLabel }>({\n      name: 'gossipsub_pre_validation_invalid_total',\n      help: 'Total count of invalid messages received',\n      labelNames: ['topic']\n    }),\n    prevalidationValidTotal: register.gauge<{ topic: TopicLabel }>({\n      name: 'gossipsub_pre_validation_valid_total',\n      help: 'Total count of valid messages received',\n      labelNames: ['topic']\n    }),\n    prevalidationDuplicateTotal: register.gauge<{ topic: TopicLabel }>({\n      name: 'gossipsub_pre_validation_duplicate_total',\n      help: 'Total count of duplicate messages received',\n      labelNames: ['topic']\n    }),\n    prevalidationUnknownTotal: register.gauge<{ topic: TopicLabel }>({\n      name: 'gossipsub_pre_validation_unknown_status_total',\n      help: 'Total count of unknown_status messages received',\n      labelNames: ['topic']\n    }),\n    /** Tracks specific reason of invalid */\n    msgReceivedInvalid: register.gauge<{ error: RejectReason | ValidateError }>({\n      name: 'gossipsub_msg_received_invalid_total',\n      help: 'Tracks specific reason of invalid',\n      labelNames: ['error']\n    }),\n    msgReceivedInvalidByTopic: register.gauge<{ topic: TopicLabel }>({\n      name: 'gossipsub_msg_received_invalid_by_topic_total',\n      help: 'Tracks specific invalid message by topic',\n      labelNames: ['topic']\n    }),\n    /** Track duplicate message delivery time */\n    duplicateMsgDeliveryDelay: register.histogram<{ topic: TopicLabel }>({\n      name: 'gossisub_duplicate_msg_delivery_delay_seconds',\n      help: 'Time since the 1st duplicated message validated',\n      labelNames: ['topic'],\n      buckets: [\n        0.25 * opts.maxMeshMessageDeliveriesWindowSec,\n        0.5 * opts.maxMeshMessageDeliveriesWindowSec,\n        Number(opts.maxMeshMessageDeliveriesWindowSec),\n        2 * opts.maxMeshMessageDeliveriesWindowSec,\n        4 * opts.maxMeshMessageDeliveriesWindowSec\n      ]\n    }),\n    /** Total count of late msg delivery total by topic */\n    duplicateMsgLateDelivery: register.gauge<{ topic: TopicLabel }>({\n      name: 'gossisub_duplicate_msg_late_delivery_total',\n      help: 'Total count of late duplicate message delivery by topic, which triggers P3 penalty',\n      labelNames: ['topic']\n    }),\n\n    duplicateMsgIgnored: register.gauge<{ topic: TopicLabel }>({\n      name: 'gossisub_ignored_published_duplicate_msgs_total',\n      help: 'Total count of published duplicate message ignored by topic',\n      labelNames: ['topic']\n    }),\n\n    /* Metrics related to scoring */\n    /** Total times score() is called */\n    scoreFnCalls: register.gauge({\n      name: 'gossipsub_score_fn_calls_total',\n      help: 'Total times score() is called'\n    }),\n    /** Total times score() call actually computed computeScore(), no cache */\n    scoreFnRuns: register.gauge({\n      name: 'gossipsub_score_fn_runs_total',\n      help: 'Total times score() call actually computed computeScore(), no cache'\n    }),\n    scoreCachedDelta: register.histogram({\n      name: 'gossipsub_score_cache_delta',\n      help: 'Delta of score between cached values that expired',\n      buckets: [10, 100, 1000]\n    }),\n    /** Current count of peers by score threshold */\n    peersByScoreThreshold: register.gauge<{ threshold: ScoreThreshold }>({\n      name: 'gossipsub_peers_by_score_threshold_count',\n      help: 'Current count of peers by score threshold',\n      labelNames: ['threshold']\n    }),\n    score: register.avgMinMax({\n      name: 'gossipsub_score',\n      help: 'Avg min max of gossip scores'\n    }),\n    /**\n     * Separate score weights\n     * Need to use 2-label metrics in this case to debug the score weights\n     **/\n    scoreWeights: register.avgMinMax<{ topic?: TopicLabel, p: string }>({\n      name: 'gossipsub_score_weights',\n      help: 'Separate score weights',\n      labelNames: ['topic', 'p']\n    }),\n    /** Histogram of the scores for each mesh topic. */\n    // TODO: Not implemented\n    scorePerMesh: register.avgMinMax<{ topic: TopicLabel }>({\n      name: 'gossipsub_score_per_mesh',\n      help: 'Histogram of the scores for each mesh topic',\n      labelNames: ['topic']\n    }),\n    /** A counter of the kind of penalties being applied to peers. */\n    // TODO: Not fully implemented\n    scoringPenalties: register.gauge<{ penalty: ScorePenalty }>({\n      name: 'gossipsub_scoring_penalties_total',\n      help: 'A counter of the kind of penalties being applied to peers',\n      labelNames: ['penalty']\n    }),\n    behaviourPenalty: register.histogram({\n      name: 'gossipsub_peer_stat_behaviour_penalty',\n      help: 'Current peer stat behaviour_penalty at each scrape',\n      buckets: [\n        0.25 * opts.behaviourPenaltyThreshold,\n        0.5 * opts.behaviourPenaltyThreshold,\n        Number(opts.behaviourPenaltyThreshold),\n        2 * opts.behaviourPenaltyThreshold,\n        4 * opts.behaviourPenaltyThreshold\n      ]\n    }),\n\n    // TODO:\n    // - iasked per peer (on heartbeat)\n    // - when promise is resolved, track messages from promises\n\n    /** Total received IHAVE messages that we ignore for some reason */\n    ihaveRcvIgnored: register.gauge<{ reason: IHaveIgnoreReason }>({\n      name: 'gossipsub_ihave_rcv_ignored_total',\n      help: 'Total received IHAVE messages that we ignore for some reason',\n      labelNames: ['reason']\n    }),\n    /** Total received IHAVE messages by topic */\n    ihaveRcvMsgids: register.gauge<{ topic: TopicLabel }>({\n      name: 'gossipsub_ihave_rcv_msgids_total',\n      help: 'Total received IHAVE messages by topic',\n      labelNames: ['topic']\n    }),\n    /**\n     * Total messages per topic we don't have. Not actual requests.\n     * The number of times we have decided that an IWANT control message is required for this\n     * topic. A very high metric might indicate an underperforming network.\n     * = rust-libp2p `topic_iwant_msgs` */\n    ihaveRcvNotSeenMsgids: register.gauge<{ topic: TopicLabel }>({\n      name: 'gossipsub_ihave_rcv_not_seen_msgids_total',\n      help: 'Total messages per topic we do not have, not actual requests',\n      labelNames: ['topic']\n    }),\n\n    /** Total received IWANT messages by topic */\n    iwantRcvMsgids: register.gauge<{ topic: TopicLabel }>({\n      name: 'gossipsub_iwant_rcv_msgids_total',\n      help: 'Total received IWANT messages by topic',\n      labelNames: ['topic']\n    }),\n    /** Total requested messageIDs that we don't have */\n    iwantRcvDonthaveMsgids: register.gauge({\n      name: 'gossipsub_iwant_rcv_dont_have_msgids_total',\n      help: 'Total requested messageIDs that we do not have'\n    }),\n    iwantPromiseStarted: register.gauge({\n      name: 'gossipsub_iwant_promise_sent_total',\n      help: 'Total count of started IWANT promises'\n    }),\n    /** Total count of resolved IWANT promises */\n    iwantPromiseResolved: register.gauge({\n      name: 'gossipsub_iwant_promise_resolved_total',\n      help: 'Total count of resolved IWANT promises'\n    }),\n    /** Total count of resolved IWANT promises from duplicate messages */\n    iwantPromiseResolvedFromDuplicate: register.gauge({\n      name: 'gossipsub_iwant_promise_resolved_from_duplicate_total',\n      help: 'Total count of resolved IWANT promises from duplicate messages'\n    }),\n    /** Total count of peers we have asked IWANT promises that are resolved */\n    iwantPromiseResolvedPeers: register.gauge({\n      name: 'gossipsub_iwant_promise_resolved_peers',\n      help: 'Total count of peers we have asked IWANT promises that are resolved'\n    }),\n    iwantPromiseBroken: register.gauge({\n      name: 'gossipsub_iwant_promise_broken',\n      help: 'Total count of broken IWANT promises'\n    }),\n    iwantMessagePruned: register.gauge({\n      name: 'gossipsub_iwant_message_pruned',\n      help: 'Total count of pruned IWANT messages'\n    }),\n    /** Histogram of delivery time of resolved IWANT promises */\n    iwantPromiseDeliveryTime: register.histogram({\n      name: 'gossipsub_iwant_promise_delivery_seconds',\n      help: 'Histogram of delivery time of resolved IWANT promises',\n      buckets: [\n        0.5 * opts.gossipPromiseExpireSec,\n        Number(opts.gossipPromiseExpireSec),\n        2 * opts.gossipPromiseExpireSec,\n        4 * opts.gossipPromiseExpireSec\n      ]\n    }),\n    iwantPromiseUntracked: register.gauge({\n      name: 'gossip_iwant_promise_untracked',\n      help: 'Total count of untracked IWANT promise'\n    }),\n    /** Backoff time */\n    connectedPeersBackoffSec: register.histogram({\n      name: 'gossipsub_connected_peers_backoff_seconds',\n      help: 'Backoff time in seconds',\n      // Using 1 seconds as minimum as that's close to the heartbeat duration, no need for more resolution.\n      // As per spec, backoff times are 10 seconds for UnsubscribeBackoff and 60 seconds for PruneBackoff.\n      // Higher values of 60 seconds should not occur, but we add 120 seconds just in case\n      // https://github.com/libp2p/specs/blob/master/pubsub/gossipsub/gossipsub-v1.1.md#overview-of-new-parameters\n      buckets: [1, 2, 4, 10, 20, 60, 120]\n    }),\n\n    /* Data structure sizes */\n    /** Unbounded cache sizes */\n    cacheSize: register.gauge<{ cache: string }>({\n      name: 'gossipsub_cache_size',\n      help: 'Unbounded cache sizes',\n      labelNames: ['cache']\n    }),\n    /** Current mcache msg count */\n    mcacheSize: register.gauge({\n      name: 'gossipsub_mcache_size',\n      help: 'Current mcache msg count'\n    }),\n    mcacheNotValidatedCount: register.gauge({\n      name: 'gossipsub_mcache_not_validated_count',\n      help: 'Current mcache msg count not validated'\n    }),\n\n    fastMsgIdCacheCollision: register.gauge({\n      name: 'gossipsub_fastmsgid_cache_collision_total',\n      help: 'Total count of key collisions on fastmsgid cache put'\n    }),\n\n    newConnectionCount: register.gauge<{ status: string }>({\n      name: 'gossipsub_new_connection_total',\n      help: 'Total new connection by status',\n      labelNames: ['status']\n    }),\n\n    topicStrToLabel,\n\n    toTopic (topicStr: TopicStr): TopicLabel {\n      return this.topicStrToLabel.get(topicStr) ?? topicStr\n    },\n\n    /** We joined a topic */\n    onJoin (topicStr: TopicStr): void {\n      this.topicSubscriptionStatus.set({ topicStr }, 1)\n      this.meshPeerCounts.set({ topicStr }, 0) // Reset count\n    },\n\n    /** We left a topic */\n    onLeave (topicStr: TopicStr): void {\n      this.topicSubscriptionStatus.set({ topicStr }, 0)\n      this.meshPeerCounts.set({ topicStr }, 0) // Reset count\n    },\n\n    /** Register the inclusion of peers in our mesh due to some reason. */\n    onAddToMesh (topicStr: TopicStr, reason: InclusionReason, count: number): void {\n      const topic = this.toTopic(topicStr)\n      switch (reason) {\n        case InclusionReason.Fanout:\n          this.meshPeerInclusionEventsFanout.inc({ topic }, count)\n          break\n        case InclusionReason.Random:\n          this.meshPeerInclusionEventsRandom.inc({ topic }, count)\n          break\n        case InclusionReason.Subscribed:\n          this.meshPeerInclusionEventsSubscribed.inc({ topic }, count)\n          break\n        case InclusionReason.Outbound:\n          this.meshPeerInclusionEventsOutbound.inc({ topic }, count)\n          break\n        case InclusionReason.NotEnough:\n          this.meshPeerInclusionEventsNotEnough.inc({ topic }, count)\n          break\n        case InclusionReason.Opportunistic:\n          this.meshPeerInclusionEventsOpportunistic.inc({ topic }, count)\n          break\n        default:\n          this.meshPeerInclusionEventsUnknown.inc({ topic }, count)\n          break\n      }\n    },\n\n    /** Register the removal of peers in our mesh due to some reason */\n    // - remove_peer_from_mesh()\n    // - heartbeat() Churn::BadScore\n    // - heartbeat() Churn::Excess\n    // - on_disconnect() Churn::Ds\n    onRemoveFromMesh (topicStr: TopicStr, reason: ChurnReason, count: number): void {\n      const topic = this.toTopic(topicStr)\n      switch (reason) {\n        case ChurnReason.Dc:\n          this.meshPeerChurnEventsDisconnected.inc({ topic }, count)\n          break\n        case ChurnReason.BadScore:\n          this.meshPeerChurnEventsBadScore.inc({ topic }, count)\n          break\n        case ChurnReason.Prune:\n          this.meshPeerChurnEventsPrune.inc({ topic }, count)\n          break\n        case ChurnReason.Excess:\n          this.meshPeerChurnEventsExcess.inc({ topic }, count)\n          break\n        default:\n          this.meshPeerChurnEventsUnknown.inc({ topic }, count)\n          break\n      }\n    },\n\n    /**\n     * Update validation result to metrics\n     *\n     * @param messageRecord - null means the message's mcache record was not known at the time of acceptance report\n     */\n    onReportValidation (\n      messageRecord: { message: { topic: TopicStr } } | null,\n      acceptance: TopicValidatorResult,\n      firstSeenTimestampMs: number | null\n    ): void {\n      this.asyncValidationMcacheHit.inc({ hit: messageRecord != null ? 'hit' : 'miss' })\n\n      if (messageRecord != null) {\n        const topic = this.toTopic(messageRecord.message.topic)\n        switch (acceptance) {\n          case TopicValidatorResult.Accept:\n            this.acceptedMessagesTotal.inc({ topic })\n            break\n          case TopicValidatorResult.Ignore:\n            this.ignoredMessagesTotal.inc({ topic })\n            break\n          case TopicValidatorResult.Reject:\n            this.rejectedMessagesTotal.inc({ topic })\n            break\n          default:\n            this.unknownValidationResultsTotal.inc({ topic })\n            break\n        }\n      }\n\n      if (firstSeenTimestampMs != null) {\n        this.asyncValidationDelayFromFirstSeenSec.observe((Date.now() - firstSeenTimestampMs) / 1000)\n      } else {\n        this.asyncValidationUnknownFirstSeen.inc()\n      }\n    },\n\n    /**\n     * - in handle_graft() Penalty::GraftBackoff\n     * - in apply_iwant_penalties() Penalty::BrokenPromise\n     * - in metric_score() P3 Penalty::MessageDeficit\n     * - in metric_score() P6 Penalty::IPColocation\n     */\n    onScorePenalty (penalty: ScorePenalty): void {\n      // Can this be labeled by topic too?\n      this.scoringPenalties.inc({ penalty }, 1)\n    },\n\n    onIhaveRcv (topicStr: TopicStr, ihave: number, idonthave: number): void {\n      const topic = this.toTopic(topicStr)\n      this.ihaveRcvMsgids.inc({ topic }, ihave)\n      this.ihaveRcvNotSeenMsgids.inc({ topic }, idonthave)\n    },\n\n    onIwantRcv (iwantByTopic: Map<TopicStr, number>, iwantDonthave: number): void {\n      for (const [topicStr, iwant] of iwantByTopic) {\n        const topic = this.toTopic(topicStr)\n        this.iwantRcvMsgids.inc({ topic }, iwant)\n      }\n\n      this.iwantRcvDonthaveMsgids.inc(iwantDonthave)\n    },\n\n    onForwardMsg (topicStr: TopicStr, tosendCount: number): void {\n      const topic = this.toTopic(topicStr)\n      this.msgForwardCount.inc({ topic }, 1)\n      this.msgForwardPeers.inc({ topic }, tosendCount)\n    },\n\n    onPublishMsg (\n      topicStr: TopicStr,\n      tosendGroupCount: ToSendGroupCount,\n      tosendCount: number,\n      dataLen: number,\n      ms: number\n    ): void {\n      const topic = this.toTopic(topicStr)\n      this.msgPublishCount.inc({ topic }, 1)\n      this.msgPublishBytes.inc({ topic }, tosendCount * dataLen)\n      this.msgPublishPeersByTopic.inc({ topic }, tosendCount)\n      this.directPeersPublishedTotal.inc({ topic }, tosendGroupCount.direct)\n      this.floodsubPeersPublishedTotal.inc({ topic }, tosendGroupCount.floodsub)\n      this.meshPeersPublishedTotal.inc({ topic }, tosendGroupCount.mesh)\n      this.fanoutPeersPublishedTotal.inc({ topic }, tosendGroupCount.fanout)\n      this.msgPublishTime.observe({ topic }, ms / 1000)\n    },\n\n    onMsgRecvPreValidation (topicStr: TopicStr): void {\n      const topic = this.toTopic(topicStr)\n      this.msgReceivedPreValidation.inc({ topic }, 1)\n    },\n\n    onMsgRecvError (topicStr: TopicStr): void {\n      const topic = this.toTopic(topicStr)\n      this.msgReceivedError.inc({ topic }, 1)\n    },\n\n    onPrevalidationResult (topicStr: TopicStr, status: MessageStatus): void {\n      const topic = this.toTopic(topicStr)\n      switch (status) {\n        case MessageStatus.duplicate:\n          this.prevalidationDuplicateTotal.inc({ topic })\n          break\n        case MessageStatus.invalid:\n          this.prevalidationInvalidTotal.inc({ topic })\n          break\n        case MessageStatus.valid:\n          this.prevalidationValidTotal.inc({ topic })\n          break\n        default:\n          this.prevalidationUnknownTotal.inc({ topic })\n          break\n      }\n    },\n\n    onMsgRecvInvalid (topicStr: TopicStr, reason: RejectReasonObj): void {\n      const topic = this.toTopic(topicStr)\n\n      const error = reason.reason === RejectReason.Error ? reason.error : reason.reason\n      this.msgReceivedInvalid.inc({ error }, 1)\n      this.msgReceivedInvalidByTopic.inc({ topic }, 1)\n    },\n\n    onDuplicateMsgDelivery (topicStr: TopicStr, deliveryDelayMs: number, isLateDelivery: boolean): void {\n      const topic = this.toTopic(topicStr)\n      this.duplicateMsgDeliveryDelay.observe({ topic }, deliveryDelayMs / 1000)\n      if (isLateDelivery) {\n        this.duplicateMsgLateDelivery.inc({ topic }, 1)\n      }\n    },\n\n    onPublishDuplicateMsg (topicStr: TopicStr): void {\n      const topic = this.toTopic(topicStr)\n      this.duplicateMsgIgnored.inc({ topic }, 1)\n    },\n\n    onPeerReadStreamError (): void {\n      this.peerReadStreamError.inc(1)\n    },\n\n    onRpcRecvError (): void {\n      this.rpcRecvError.inc(1)\n    },\n\n    onRpcDataError (): void {\n      this.rpcDataError.inc(1)\n    },\n\n    onRpcRecv (rpc: IRPC, rpcBytes: number): void {\n      this.rpcRecvBytes.inc(rpcBytes)\n      this.rpcRecvCount.inc(1)\n      if (rpc.subscriptions != null) this.rpcRecvSubscription.inc(rpc.subscriptions.length)\n      if (rpc.messages != null) this.rpcRecvMessage.inc(rpc.messages.length)\n      if (rpc.control != null) {\n        this.rpcRecvControl.inc(1)\n        if (rpc.control.ihave != null) this.rpcRecvIHave.inc(rpc.control.ihave.length)\n        if (rpc.control.iwant != null) this.rpcRecvIWant.inc(rpc.control.iwant.length)\n        if (rpc.control.graft != null) this.rpcRecvGraft.inc(rpc.control.graft.length)\n        if (rpc.control.prune != null) this.rpcRecvPrune.inc(rpc.control.prune.length)\n      }\n    },\n\n    onRpcSent (rpc: IRPC, rpcBytes: number): void {\n      this.rpcSentBytes.inc(rpcBytes)\n      this.rpcSentCount.inc(1)\n      if (rpc.subscriptions != null) this.rpcSentSubscription.inc(rpc.subscriptions.length)\n      if (rpc.messages != null) this.rpcSentMessage.inc(rpc.messages.length)\n      if (rpc.control != null) {\n        const ihave = rpc.control.ihave?.length ?? 0\n        const iwant = rpc.control.iwant?.length ?? 0\n        const graft = rpc.control.graft?.length ?? 0\n        const prune = rpc.control.prune?.length ?? 0\n        if (ihave > 0) this.rpcSentIHave.inc(ihave)\n        if (iwant > 0) this.rpcSentIWant.inc(iwant)\n        if (graft > 0) this.rpcSentGraft.inc(graft)\n        if (prune > 0) this.rpcSentPrune.inc(prune)\n        if (ihave > 0 || iwant > 0 || graft > 0 || prune > 0) this.rpcSentControl.inc(1)\n      }\n    },\n\n    registerScores (scores: number[], scoreThresholds: PeerScoreThresholds): void {\n      let graylist = 0\n      let publish = 0\n      let gossip = 0\n      let mesh = 0\n\n      for (const score of scores) {\n        if (score >= scoreThresholds.graylistThreshold) graylist++\n        if (score >= scoreThresholds.publishThreshold) publish++\n        if (score >= scoreThresholds.gossipThreshold) gossip++\n        if (score >= 0) mesh++\n      }\n\n      this.peersByScoreThreshold.set({ threshold: ScoreThreshold.graylist }, graylist)\n      this.peersByScoreThreshold.set({ threshold: ScoreThreshold.publish }, publish)\n      this.peersByScoreThreshold.set({ threshold: ScoreThreshold.gossip }, gossip)\n      this.peersByScoreThreshold.set({ threshold: ScoreThreshold.mesh }, mesh)\n\n      // Register full score too\n      this.score.set(scores)\n    },\n\n    registerScoreWeights (sw: ScoreWeights<number[]>): void {\n      for (const [topic, wsTopic] of sw.byTopic) {\n        this.scoreWeights.set({ topic, p: 'p1' }, wsTopic.p1w)\n        this.scoreWeights.set({ topic, p: 'p2' }, wsTopic.p2w)\n        this.scoreWeights.set({ topic, p: 'p3' }, wsTopic.p3w)\n        this.scoreWeights.set({ topic, p: 'p3b' }, wsTopic.p3bw)\n        this.scoreWeights.set({ topic, p: 'p4' }, wsTopic.p4w)\n      }\n\n      this.scoreWeights.set({ p: 'p5' }, sw.p5w)\n      this.scoreWeights.set({ p: 'p6' }, sw.p6w)\n      this.scoreWeights.set({ p: 'p7' }, sw.p7w)\n    },\n\n    registerScorePerMesh (mesh: Map<TopicStr, Set<PeerIdStr>>, scoreByPeer: Map<PeerIdStr, number>): void {\n      const peersPerTopicLabel = new Map<TopicLabel, Set<PeerIdStr>>()\n\n      mesh.forEach((peers, topicStr) => {\n        // Aggregate by known topicLabel or throw to 'unknown'. This prevent too high cardinality\n        const topicLabel = this.topicStrToLabel.get(topicStr) ?? 'unknown'\n        let peersInMesh = peersPerTopicLabel.get(topicLabel)\n        if (peersInMesh == null) {\n          peersInMesh = new Set()\n          peersPerTopicLabel.set(topicLabel, peersInMesh)\n        }\n        peers.forEach((p) => peersInMesh?.add(p))\n      })\n\n      for (const [topic, peers] of peersPerTopicLabel) {\n        const meshScores: number[] = []\n        peers.forEach((peer) => {\n          meshScores.push(scoreByPeer.get(peer) ?? 0)\n        })\n        this.scorePerMesh.set({ topic }, meshScores)\n      }\n    }\n  }\n}\n", "export const ERR_INVALID_PEER_SCORE_PARAMS = 'ERR_INVALID_PEER_SCORE_PARAMS'\nexport const ERR_INVALID_PEER_SCORE_THRESHOLDS = 'ERR_INVALID_PEER_SCORE_THRESHOLDS'\n", "import { CodeError } from '@libp2p/interface'\nimport { ERR_INVALID_PEER_SCORE_PARAMS } from './constants.js'\n\n// This file defines PeerScoreParams and TopicScoreParams interfaces\n// as well as constructors, default constructors, and validation functions\n// for these interfaces\n\nexport interface PeerScoreParams {\n  /**\n   * Score parameters per topic.\n   */\n  topics: Record<string, TopicScoreParams>\n\n  /**\n   * Aggregate topic score cap; this limits the total contribution of topics towards a positive\n   * score. It must be positive (or 0 for no cap).\n   */\n  topicScoreCap: number\n\n  /**\n   * P5: Application-specific peer scoring\n   */\n  appSpecificScore(p: string): number\n  appSpecificWeight: number\n\n  /**\n   * P6: IP-colocation factor.\n   * The parameter has an associated counter which counts the number of peers with the same IP.\n   * If the number of peers in the same IP exceeds IPColocationFactorThreshold, then the value\n   * is the square of the difference, ie (PeersInSameIP - IPColocationThreshold)^2.\n   * If the number of peers in the same IP is less than the threshold, then the value is 0.\n   * The weight of the parameter MUST be negative, unless you want to disable for testing.\n   * Note: In order to simulate many IPs in a managable manner when testing, you can set the weight to 0\n   * thus disabling the IP colocation penalty.\n   */\n  IPColocationFactorWeight: number\n  IPColocationFactorThreshold: number\n  IPColocationFactorWhitelist: Set<string>\n\n  /**\n   * P7: behavioural pattern penalties.\n   * This parameter has an associated counter which tracks misbehaviour as detected by the\n   * router. The router currently applies penalties for the following behaviors:\n   * - attempting to re-graft before the prune backoff time has elapsed.\n   * - not following up in IWANT requests for messages advertised with IHAVE.\n   *\n   * The value of the parameter is the square of the counter, which decays with  BehaviourPenaltyDecay.\n   * The weight of the parameter MUST be negative (or zero to disable).\n   */\n  behaviourPenaltyWeight: number\n  behaviourPenaltyThreshold: number\n  behaviourPenaltyDecay: number\n\n  /**\n   * the decay interval for parameter counters.\n   */\n  decayInterval: number\n\n  /**\n   * counter value below which it is considered 0.\n   */\n  decayToZero: number\n\n  /**\n   * time to remember counters for a disconnected peer.\n   */\n  retainScore: number\n}\n\nexport interface TopicScoreParams {\n  /**\n   * The weight of the topic.\n   */\n  topicWeight: number\n\n  /**\n   * P1: time in the mesh\n   * This is the time the peer has ben grafted in the mesh.\n   * The value of the parameter is the time/TimeInMeshQuantum, capped by TimeInMeshCap\n   * The weight of the parameter MUST be positive (or zero to disable).\n   */\n  timeInMeshWeight: number\n  timeInMeshQuantum: number\n  timeInMeshCap: number\n\n  /**\n   * P2: first message deliveries\n   * This is the number of message deliveries in the topic.\n   * The value of the parameter is a counter, decaying with FirstMessageDeliveriesDecay, and capped\n   * by FirstMessageDeliveriesCap.\n   * The weight of the parameter MUST be positive (or zero to disable).\n   */\n  firstMessageDeliveriesWeight: number\n  firstMessageDeliveriesDecay: number\n  firstMessageDeliveriesCap: number\n\n  /**\n   * P3: mesh message deliveries\n   * This is the number of message deliveries in the mesh, within the MeshMessageDeliveriesWindow of\n   * message validation; deliveries during validation also count and are retroactively applied\n   * when validation succeeds.\n   * This window accounts for the minimum time before a hostile mesh peer trying to game the score\n   * could replay back a valid message we just sent them.\n   * It effectively tracks first and near-first deliveries, ie a message seen from a mesh peer\n   * before we have forwarded it to them.\n   * The parameter has an associated counter, decaying with MeshMessageDeliveriesDecay.\n   * If the counter exceeds the threshold, its value is 0.\n   * If the counter is below the MeshMessageDeliveriesThreshold, the value is the square of\n   * the deficit, ie (MessageDeliveriesThreshold - counter)^2\n   * The penalty is only activated after MeshMessageDeliveriesActivation time in the mesh.\n   * The weight of the parameter MUST be negative (or zero to disable).\n   */\n  meshMessageDeliveriesWeight: number\n  meshMessageDeliveriesDecay: number\n  meshMessageDeliveriesCap: number\n  meshMessageDeliveriesThreshold: number\n  meshMessageDeliveriesWindow: number\n  meshMessageDeliveriesActivation: number\n\n  /**\n   * P3b: sticky mesh propagation failures\n   * This is a sticky penalty that applies when a peer gets pruned from the mesh with an active\n   * mesh message delivery penalty.\n   * The weight of the parameter MUST be negative (or zero to disable)\n   */\n  meshFailurePenaltyWeight: number\n  meshFailurePenaltyDecay: number\n\n  /**\n   * P4: invalid messages\n   * This is the number of invalid messages in the topic.\n   * The value of the parameter is the square of the counter, decaying with\n   * InvalidMessageDeliveriesDecay.\n   * The weight of the parameter MUST be negative (or zero to disable).\n   */\n  invalidMessageDeliveriesWeight: number\n  invalidMessageDeliveriesDecay: number\n}\n\nexport const defaultPeerScoreParams: PeerScoreParams = {\n  topics: {},\n  topicScoreCap: 10.0,\n  appSpecificScore: () => 0.0,\n  appSpecificWeight: 10.0,\n  IPColocationFactorWeight: -5.0,\n  IPColocationFactorThreshold: 10.0,\n  IPColocationFactorWhitelist: new Set(),\n  behaviourPenaltyWeight: -10.0,\n  behaviourPenaltyThreshold: 0.0,\n  behaviourPenaltyDecay: 0.2,\n  decayInterval: 1000.0,\n  decayToZero: 0.1,\n  retainScore: 3600 * 1000\n}\n\nexport const defaultTopicScoreParams: TopicScoreParams = {\n  topicWeight: 0.5,\n  timeInMeshWeight: 1,\n  timeInMeshQuantum: 1,\n  timeInMeshCap: 3600,\n\n  firstMessageDeliveriesWeight: 1,\n  firstMessageDeliveriesDecay: 0.5,\n  firstMessageDeliveriesCap: 2000,\n\n  meshMessageDeliveriesWeight: -1,\n  meshMessageDeliveriesDecay: 0.5,\n  meshMessageDeliveriesCap: 100,\n  meshMessageDeliveriesThreshold: 20,\n  meshMessageDeliveriesWindow: 10,\n  meshMessageDeliveriesActivation: 5000,\n\n  meshFailurePenaltyWeight: -1,\n  meshFailurePenaltyDecay: 0.5,\n\n  invalidMessageDeliveriesWeight: -1,\n  invalidMessageDeliveriesDecay: 0.3\n}\n\nexport function createPeerScoreParams (p: Partial<PeerScoreParams> = {}): PeerScoreParams {\n  return {\n    ...defaultPeerScoreParams,\n    ...p,\n    topics: (p.topics != null)\n      ? Object.entries(p.topics).reduce<Record<string, TopicScoreParams>>((topics, [topic, topicScoreParams]) => {\n        topics[topic] = createTopicScoreParams(topicScoreParams)\n        return topics\n      }, {})\n      : {}\n  }\n}\n\nexport function createTopicScoreParams (p: Partial<TopicScoreParams> = {}): TopicScoreParams {\n  return {\n    ...defaultTopicScoreParams,\n    ...p\n  }\n}\n\n// peer score parameter validation\nexport function validatePeerScoreParams (p: PeerScoreParams): void {\n  for (const [topic, params] of Object.entries(p.topics)) {\n    try {\n      validateTopicScoreParams(params)\n    } catch (e) {\n      throw new CodeError(\n        `invalid score parameters for topic ${topic}: ${(e as Error).message}`,\n        ERR_INVALID_PEER_SCORE_PARAMS\n      )\n    }\n  }\n\n  // check that the topic score is 0 or something positive\n  if (p.topicScoreCap < 0) {\n    throw new CodeError('invalid topic score cap; must be positive (or 0 for no cap)', ERR_INVALID_PEER_SCORE_PARAMS)\n  }\n\n  // check that we have an app specific score; the weight can be anything (but expected positive)\n  if (p.appSpecificScore === null || p.appSpecificScore === undefined) {\n    throw new CodeError('missing application specific score function', ERR_INVALID_PEER_SCORE_PARAMS)\n  }\n\n  // check the IP colocation factor\n  if (p.IPColocationFactorWeight > 0) {\n    throw new CodeError(\n      'invalid IPColocationFactorWeight; must be negative (or 0 to disable)',\n      ERR_INVALID_PEER_SCORE_PARAMS\n    )\n  }\n  if (p.IPColocationFactorWeight !== 0 && p.IPColocationFactorThreshold < 1) {\n    throw new CodeError('invalid IPColocationFactorThreshold; must be at least 1', ERR_INVALID_PEER_SCORE_PARAMS)\n  }\n\n  // check the behaviour penalty\n  if (p.behaviourPenaltyWeight > 0) {\n    throw new CodeError(\n      'invalid BehaviourPenaltyWeight; must be negative (or 0 to disable)',\n      ERR_INVALID_PEER_SCORE_PARAMS\n    )\n  }\n  if (p.behaviourPenaltyWeight !== 0 && (p.behaviourPenaltyDecay <= 0 || p.behaviourPenaltyDecay >= 1)) {\n    throw new CodeError('invalid BehaviourPenaltyDecay; must be between 0 and 1', ERR_INVALID_PEER_SCORE_PARAMS)\n  }\n\n  // check the decay parameters\n  if (p.decayInterval < 1000) {\n    throw new CodeError('invalid DecayInterval; must be at least 1s', ERR_INVALID_PEER_SCORE_PARAMS)\n  }\n  if (p.decayToZero <= 0 || p.decayToZero >= 1) {\n    throw new CodeError('invalid DecayToZero; must be between 0 and 1', ERR_INVALID_PEER_SCORE_PARAMS)\n  }\n\n  // no need to check the score retention; a value of 0 means that we don't retain scores\n}\n\n// eslint-disable-next-line complexity\nexport function validateTopicScoreParams (p: TopicScoreParams): void {\n  // make sure we have a sane topic weight\n  if (p.topicWeight < 0) {\n    throw new CodeError('invalid topic weight; must be >= 0', ERR_INVALID_PEER_SCORE_PARAMS)\n  }\n\n  // check P1\n  if (p.timeInMeshQuantum === 0) {\n    throw new CodeError('invalid TimeInMeshQuantum; must be non zero', ERR_INVALID_PEER_SCORE_PARAMS)\n  }\n  if (p.timeInMeshWeight < 0) {\n    throw new CodeError('invalid TimeInMeshWeight; must be positive (or 0 to disable)', ERR_INVALID_PEER_SCORE_PARAMS)\n  }\n  if (p.timeInMeshWeight !== 0 && p.timeInMeshQuantum <= 0) {\n    throw new CodeError('invalid TimeInMeshQuantum; must be positive', ERR_INVALID_PEER_SCORE_PARAMS)\n  }\n  if (p.timeInMeshWeight !== 0 && p.timeInMeshCap <= 0) {\n    throw new CodeError('invalid TimeInMeshCap; must be positive', ERR_INVALID_PEER_SCORE_PARAMS)\n  }\n\n  // check P2\n  if (p.firstMessageDeliveriesWeight < 0) {\n    throw new CodeError(\n      'invallid FirstMessageDeliveriesWeight; must be positive (or 0 to disable)',\n      ERR_INVALID_PEER_SCORE_PARAMS\n    )\n  }\n  if (\n    p.firstMessageDeliveriesWeight !== 0 &&\n    (p.firstMessageDeliveriesDecay <= 0 || p.firstMessageDeliveriesDecay >= 1)\n  ) {\n    throw new CodeError('invalid FirstMessageDeliveriesDecay; must be between 0 and 1', ERR_INVALID_PEER_SCORE_PARAMS)\n  }\n  if (p.firstMessageDeliveriesWeight !== 0 && p.firstMessageDeliveriesCap <= 0) {\n    throw new CodeError('invalid FirstMessageDeliveriesCap; must be positive', ERR_INVALID_PEER_SCORE_PARAMS)\n  }\n\n  // check P3\n  if (p.meshMessageDeliveriesWeight > 0) {\n    throw new CodeError(\n      'invalid MeshMessageDeliveriesWeight; must be negative (or 0 to disable)',\n      ERR_INVALID_PEER_SCORE_PARAMS\n    )\n  }\n  if (p.meshMessageDeliveriesWeight !== 0 && (p.meshMessageDeliveriesDecay <= 0 || p.meshMessageDeliveriesDecay >= 1)) {\n    throw new CodeError('invalid MeshMessageDeliveriesDecay; must be between 0 and 1', ERR_INVALID_PEER_SCORE_PARAMS)\n  }\n  if (p.meshMessageDeliveriesWeight !== 0 && p.meshMessageDeliveriesCap <= 0) {\n    throw new CodeError('invalid MeshMessageDeliveriesCap; must be positive', ERR_INVALID_PEER_SCORE_PARAMS)\n  }\n  if (p.meshMessageDeliveriesWeight !== 0 && p.meshMessageDeliveriesThreshold <= 0) {\n    throw new CodeError('invalid MeshMessageDeliveriesThreshold; must be positive', ERR_INVALID_PEER_SCORE_PARAMS)\n  }\n  if (p.meshMessageDeliveriesWindow < 0) {\n    throw new CodeError('invalid MeshMessageDeliveriesWindow; must be non-negative', ERR_INVALID_PEER_SCORE_PARAMS)\n  }\n  if (p.meshMessageDeliveriesWeight !== 0 && p.meshMessageDeliveriesActivation < 1000) {\n    throw new CodeError('invalid MeshMessageDeliveriesActivation; must be at least 1s', ERR_INVALID_PEER_SCORE_PARAMS)\n  }\n\n  // check P3b\n  if (p.meshFailurePenaltyWeight > 0) {\n    throw new CodeError(\n      'invalid MeshFailurePenaltyWeight; must be negative (or 0 to disable)',\n      ERR_INVALID_PEER_SCORE_PARAMS\n    )\n  }\n  if (p.meshFailurePenaltyWeight !== 0 && (p.meshFailurePenaltyDecay <= 0 || p.meshFailurePenaltyDecay >= 1)) {\n    throw new CodeError('invalid MeshFailurePenaltyDecay; must be between 0 and 1', ERR_INVALID_PEER_SCORE_PARAMS)\n  }\n\n  // check P4\n  if (p.invalidMessageDeliveriesWeight > 0) {\n    throw new CodeError(\n      'invalid InvalidMessageDeliveriesWeight; must be negative (or 0 to disable)',\n      ERR_INVALID_PEER_SCORE_PARAMS\n    )\n  }\n  if (p.invalidMessageDeliveriesDecay <= 0 || p.invalidMessageDeliveriesDecay >= 1) {\n    throw new CodeError('invalid InvalidMessageDeliveriesDecay; must be between 0 and 1', ERR_INVALID_PEER_SCORE_PARAMS)\n  }\n}\n", "import { CodeError } from '@libp2p/interface'\nimport { ERR_INVALID_PEER_SCORE_THRESHOLDS } from './constants.js'\n\n// This file defines PeerScoreThresholds interface\n// as well as a constructor, default constructor, and validation function\n// for this interface\n\nexport interface PeerScoreThresholds {\n  /**\n   * gossipThreshold is the score threshold below which gossip propagation is supressed;\n   * should be negative.\n   */\n  gossipThreshold: number\n\n  /**\n   * publishThreshold is the score threshold below which we shouldn't publish when using flood\n   * publishing (also applies to fanout and floodsub peers); should be negative and <= GossipThreshold.\n   */\n  publishThreshold: number\n\n  /**\n   * graylistThreshold is the score threshold below which message processing is supressed altogether,\n   * implementing an effective graylist according to peer score; should be negative and <= PublisThreshold.\n   */\n  graylistThreshold: number\n\n  /**\n   * acceptPXThreshold is the score threshold below which PX will be ignored; this should be positive\n   * and limited to scores attainable by bootstrappers and other trusted nodes.\n   */\n  acceptPXThreshold: number\n\n  /**\n   * opportunisticGraftThreshold is the median mesh score threshold before triggering opportunistic\n   * grafting; this should have a small positive value.\n   */\n  opportunisticGraftThreshold: number\n}\n\nexport const defaultPeerScoreThresholds: PeerScoreThresholds = {\n  gossipThreshold: -10,\n  publishThreshold: -50,\n  graylistThreshold: -80,\n  acceptPXThreshold: 10,\n  opportunisticGraftThreshold: 20\n}\n\nexport function createPeerScoreThresholds (p: Partial<PeerScoreThresholds> = {}): PeerScoreThresholds {\n  return {\n    ...defaultPeerScoreThresholds,\n    ...p\n  }\n}\n\nexport function validatePeerScoreThresholds (p: PeerScoreThresholds): void {\n  if (p.gossipThreshold > 0) {\n    throw new CodeError('invalid gossip threshold; it must be <= 0', ERR_INVALID_PEER_SCORE_THRESHOLDS)\n  }\n  if (p.publishThreshold > 0 || p.publishThreshold > p.gossipThreshold) {\n    throw new CodeError(\n      'invalid publish threshold; it must be <= 0 and <= gossip threshold',\n      ERR_INVALID_PEER_SCORE_THRESHOLDS\n    )\n  }\n  if (p.graylistThreshold > 0 || p.graylistThreshold > p.publishThreshold) {\n    throw new CodeError(\n      'invalid graylist threshold; it must be <= 0 and <= publish threshold',\n      ERR_INVALID_PEER_SCORE_THRESHOLDS\n    )\n  }\n  if (p.acceptPXThreshold < 0) {\n    throw new CodeError('invalid accept PX threshold; it must be >= 0', ERR_INVALID_PEER_SCORE_THRESHOLDS)\n  }\n  if (p.opportunisticGraftThreshold < 0) {\n    throw new CodeError('invalid opportunistic grafting threshold; it must be >= 0', ERR_INVALID_PEER_SCORE_THRESHOLDS)\n  }\n}\n", "/**\n * Exclude up to `ineed` items from a set if item meets condition `cond`\n */\nexport function removeItemsFromSet<T> (\n  superSet: Set<T>,\n  ineed: number,\n  cond: (peer: T) => boolean = () => true\n): Set<T> {\n  const subset = new Set<T>()\n  if (ineed <= 0) return subset\n\n  for (const id of superSet) {\n    if (subset.size >= ineed) break\n    if (cond(id)) {\n      subset.add(id)\n      superSet.delete(id)\n    }\n  }\n\n  return subset\n}\n\n/**\n * Exclude up to `ineed` items from a set\n */\nexport function removeFirstNItemsFromSet<T> (superSet: Set<T>, ineed: number): Set<T> {\n  return removeItemsFromSet(superSet, ineed, () => true)\n}\n\nexport class MapDef<K, V> extends Map<K, V> {\n  constructor (private readonly getDefault: () => V) {\n    super()\n  }\n\n  getOrDefault (key: K): V {\n    let value = super.get(key)\n    if (value === undefined) {\n      value = this.getDefault()\n      this.set(key, value)\n    }\n    return value\n  }\n}\n", "import type { PeerScoreParams } from './peer-score-params.js'\nimport type { PeerStats } from './peer-stats.js'\n\nexport function computeScore (\n  peer: string,\n  pstats: PeerStats,\n  params: PeerScoreParams,\n  peerIPs: Map<string, Set<string>>\n): number {\n  let score = 0\n\n  // topic stores\n  Object.entries(pstats.topics).forEach(([topic, tstats]) => {\n    // the topic parameters\n    const topicParams = params.topics[topic]\n    if (topicParams === undefined) {\n      // we are not scoring this topic\n      return\n    }\n\n    let topicScore = 0\n\n    // P1: time in Mesh\n    if (tstats.inMesh) {\n      let p1 = tstats.meshTime / topicParams.timeInMeshQuantum\n      if (p1 > topicParams.timeInMeshCap) {\n        p1 = topicParams.timeInMeshCap\n      }\n      topicScore += p1 * topicParams.timeInMeshWeight\n    }\n\n    // P2: first message deliveries\n    let p2 = tstats.firstMessageDeliveries\n    if (p2 > topicParams.firstMessageDeliveriesCap) {\n      p2 = topicParams.firstMessageDeliveriesCap\n    }\n    topicScore += p2 * topicParams.firstMessageDeliveriesWeight\n\n    // P3: mesh message deliveries\n    if (\n      tstats.meshMessageDeliveriesActive &&\n      tstats.meshMessageDeliveries < topicParams.meshMessageDeliveriesThreshold\n    ) {\n      const deficit = topicParams.meshMessageDeliveriesThreshold - tstats.meshMessageDeliveries\n      const p3 = deficit * deficit\n      topicScore += p3 * topicParams.meshMessageDeliveriesWeight\n    }\n\n    // P3b:\n    // NOTE: the weight of P3b is negative (validated in validateTopicScoreParams) so this detracts\n    const p3b = tstats.meshFailurePenalty\n    topicScore += p3b * topicParams.meshFailurePenaltyWeight\n\n    // P4: invalid messages\n    // NOTE: the weight of P4 is negative (validated in validateTopicScoreParams) so this detracts\n    const p4 = tstats.invalidMessageDeliveries * tstats.invalidMessageDeliveries\n    topicScore += p4 * topicParams.invalidMessageDeliveriesWeight\n\n    // update score, mixing with topic weight\n    score += topicScore * topicParams.topicWeight\n  })\n\n  // apply the topic score cap, if any\n  if (params.topicScoreCap > 0 && score > params.topicScoreCap) {\n    score = params.topicScoreCap\n  }\n\n  // P5: application-specific score\n  const p5 = params.appSpecificScore(peer)\n  score += p5 * params.appSpecificWeight\n\n  // P6: IP colocation factor\n  pstats.knownIPs.forEach((ip) => {\n    if (params.IPColocationFactorWhitelist.has(ip)) {\n      return\n    }\n\n    // P6 has a cliff (IPColocationFactorThreshold)\n    // It's only applied if at least that many peers are connected to us from that source IP addr.\n    // It is quadratic, and the weight is negative (validated in validatePeerScoreParams)\n    const peersInIP = peerIPs.get(ip)\n    const numPeersInIP = (peersInIP != null) ? peersInIP.size : 0\n    if (numPeersInIP > params.IPColocationFactorThreshold) {\n      const surplus = numPeersInIP - params.IPColocationFactorThreshold\n      const p6 = surplus * surplus\n      score += p6 * params.IPColocationFactorWeight\n    }\n  })\n\n  // P7: behavioural pattern penalty\n  if (pstats.behaviourPenalty > params.behaviourPenaltyThreshold) {\n    const excess = pstats.behaviourPenalty - params.behaviourPenaltyThreshold\n    const p7 = excess * excess\n    score += p7 * params.behaviourPenaltyWeight\n  }\n\n  return score\n}\n", "import Denque from 'denque'\nimport { TimeCacheDuration } from '../constants.js'\n\nexport enum DeliveryRecordStatus {\n  /**\n   * we don't know (yet) if the message is valid\n   */\n  unknown,\n  /**\n   * we know the message is valid\n   */\n  valid,\n  /**\n   * we know the message is invalid\n   */\n  invalid,\n  /**\n   * we were instructed by the validator to ignore the message\n   */\n  ignored\n}\n\nexport interface DeliveryRecord {\n  status: DeliveryRecordStatus\n  firstSeenTsMs: number\n  validated: number\n  peers: Set<string>\n}\n\ninterface DeliveryQueueEntry {\n  msgId: string\n  expire: number\n}\n\n/**\n * Map of canonical message ID to DeliveryRecord\n *\n * Maintains an internal queue for efficient gc of old messages\n */\nexport class MessageDeliveries {\n  private readonly records: Map<string, DeliveryRecord>\n  public queue: Denque<DeliveryQueueEntry>\n\n  constructor () {\n    this.records = new Map()\n    this.queue = new Denque()\n  }\n\n  getRecord (msgIdStr: string): DeliveryRecord | undefined {\n    return this.records.get(msgIdStr)\n  }\n\n  ensureRecord (msgIdStr: string): DeliveryRecord {\n    let drec = this.records.get(msgIdStr)\n    if (drec != null) {\n      return drec\n    }\n\n    // record doesn't exist yet\n    // create record\n    drec = {\n      status: DeliveryRecordStatus.unknown,\n      firstSeenTsMs: Date.now(),\n      validated: 0,\n      peers: new Set()\n    }\n    this.records.set(msgIdStr, drec)\n\n    // and add msgId to the queue\n    const entry: DeliveryQueueEntry = {\n      msgId: msgIdStr,\n      expire: Date.now() + TimeCacheDuration\n    }\n    this.queue.push(entry)\n\n    return drec\n  }\n\n  gc (): void {\n    const now = Date.now()\n    // queue is sorted by expiry time\n    // remove expired messages, remove from queue until first un-expired message found\n    let head = this.queue.peekFront()\n    while ((head != null) && head.expire < now) {\n      this.records.delete(head.msgId)\n      this.queue.shift()\n      head = this.queue.peekFront()\n    }\n  }\n\n  clear (): void {\n    this.records.clear()\n    this.queue.clear()\n  }\n}\n", "import { type MsgIdStr, type PeerIdStr, RejectReason, type TopicStr, type IPStr } from '../types.js'\nimport { MapDef } from '../utils/set.js'\nimport { computeScore } from './compute-score.js'\nimport { MessageDeliveries, DeliveryRecordStatus } from './message-deliveries.js'\nimport { type PeerScoreParams, validatePeerScoreParams } from './peer-score-params.js'\nimport type { PeerStats, TopicStats } from './peer-stats.js'\nimport type { Metrics, ScorePenalty } from '../metrics.js'\nimport type { ComponentLogger, Logger } from '@libp2p/interface'\n\ninterface PeerScoreOpts {\n  /**\n   * Miliseconds to cache computed score per peer\n   */\n  scoreCacheValidityMs: number\n\n  computeScore?: typeof computeScore\n}\n\ninterface ScoreCacheEntry {\n  /** The cached score */\n  score: number\n  /** Unix timestamp in miliseconds, the time after which the cached score for a peer is no longer valid */\n  cacheUntil: number\n}\n\nexport type PeerScoreStatsDump = Record<PeerIdStr, PeerStats>\n\nexport class PeerScore {\n  /**\n   * Per-peer stats for score calculation\n   */\n  readonly peerStats = new Map<PeerIdStr, PeerStats>()\n  /**\n   * IP colocation tracking; maps IP => set of peers.\n   */\n  readonly peerIPs = new MapDef<PeerIdStr, Set<IPStr>>(() => new Set())\n  /**\n   * Cache score up to decayInterval if topic stats are unchanged.\n   */\n  readonly scoreCache = new Map<PeerIdStr, ScoreCacheEntry>()\n  /**\n   * Recent message delivery timing/participants\n   */\n  readonly deliveryRecords = new MessageDeliveries()\n\n  _backgroundInterval?: ReturnType<typeof setInterval>\n\n  private readonly scoreCacheValidityMs: number\n  private readonly computeScore: typeof computeScore\n  private readonly log: Logger\n\n  constructor (readonly params: PeerScoreParams, private readonly metrics: Metrics | null, componentLogger: ComponentLogger, opts: PeerScoreOpts) {\n    validatePeerScoreParams(params)\n    this.scoreCacheValidityMs = opts.scoreCacheValidityMs\n    this.computeScore = opts.computeScore ?? computeScore\n    this.log = componentLogger.forComponent('libp2p:gossipsub:score')\n  }\n\n  get size (): number {\n    return this.peerStats.size\n  }\n\n  /**\n   * Start PeerScore instance\n   */\n  start (): void {\n    if (this._backgroundInterval != null) {\n      this.log('Peer score already running')\n      return\n    }\n    this._backgroundInterval = setInterval(() => { this.background() }, this.params.decayInterval)\n    this.log('started')\n  }\n\n  /**\n   * Stop PeerScore instance\n   */\n  stop (): void {\n    if (this._backgroundInterval == null) {\n      this.log('Peer score already stopped')\n      return\n    }\n    clearInterval(this._backgroundInterval)\n    delete this._backgroundInterval\n    this.peerIPs.clear()\n    this.peerStats.clear()\n    this.deliveryRecords.clear()\n    this.log('stopped')\n  }\n\n  /**\n   * Periodic maintenance\n   */\n  background (): void {\n    this.refreshScores()\n    this.deliveryRecords.gc()\n  }\n\n  dumpPeerScoreStats (): PeerScoreStatsDump {\n    return Object.fromEntries(Array.from(this.peerStats.entries()).map(([peer, stats]) => [peer, stats]))\n  }\n\n  messageFirstSeenTimestampMs (msgIdStr: MsgIdStr): number | null {\n    const drec = this.deliveryRecords.getRecord(msgIdStr)\n    return (drec != null) ? drec.firstSeenTsMs : null\n  }\n\n  /**\n   * Decays scores, and purges score records for disconnected peers once their expiry has elapsed.\n   */\n  public refreshScores (): void {\n    const now = Date.now()\n    const decayToZero = this.params.decayToZero\n\n    this.peerStats.forEach((pstats, id) => {\n      if (!pstats.connected) {\n        // has the retention period expired?\n        if (now > pstats.expire) {\n          // yes, throw it away (but clean up the IP tracking first)\n          this.removeIPsForPeer(id, pstats.knownIPs)\n          this.peerStats.delete(id)\n          this.scoreCache.delete(id)\n        }\n\n        // we don't decay retained scores, as the peer is not active.\n        // this way the peer cannot reset a negative score by simply disconnecting and reconnecting,\n        // unless the retention period has elapsed.\n        // similarly, a well behaved peer does not lose its score by getting disconnected.\n        return\n      }\n\n      Object.entries(pstats.topics).forEach(([topic, tstats]) => {\n        const tparams = this.params.topics[topic]\n        if (tparams === undefined) {\n          // we are not scoring this topic\n          // should be unreachable, we only add scored topics to pstats\n          return\n        }\n\n        // decay counters\n        tstats.firstMessageDeliveries *= tparams.firstMessageDeliveriesDecay\n        if (tstats.firstMessageDeliveries < decayToZero) {\n          tstats.firstMessageDeliveries = 0\n        }\n\n        tstats.meshMessageDeliveries *= tparams.meshMessageDeliveriesDecay\n        if (tstats.meshMessageDeliveries < decayToZero) {\n          tstats.meshMessageDeliveries = 0\n        }\n\n        tstats.meshFailurePenalty *= tparams.meshFailurePenaltyDecay\n        if (tstats.meshFailurePenalty < decayToZero) {\n          tstats.meshFailurePenalty = 0\n        }\n\n        tstats.invalidMessageDeliveries *= tparams.invalidMessageDeliveriesDecay\n        if (tstats.invalidMessageDeliveries < decayToZero) {\n          tstats.invalidMessageDeliveries = 0\n        }\n\n        // update mesh time and activate mesh message delivery parameter if need be\n        if (tstats.inMesh) {\n          tstats.meshTime = now - tstats.graftTime\n          if (tstats.meshTime > tparams.meshMessageDeliveriesActivation) {\n            tstats.meshMessageDeliveriesActive = true\n          }\n        }\n      })\n\n      // decay P7 counter\n      pstats.behaviourPenalty *= this.params.behaviourPenaltyDecay\n      if (pstats.behaviourPenalty < decayToZero) {\n        pstats.behaviourPenalty = 0\n      }\n    })\n  }\n\n  /**\n   * Return the score for a peer\n   */\n  score (id: PeerIdStr): number {\n    this.metrics?.scoreFnCalls.inc()\n\n    const pstats = this.peerStats.get(id)\n    if (pstats == null) {\n      return 0\n    }\n\n    const now = Date.now()\n    const cacheEntry = this.scoreCache.get(id)\n\n    // Found cached score within validity period\n    if ((cacheEntry != null) && cacheEntry.cacheUntil > now) {\n      return cacheEntry.score\n    }\n\n    this.metrics?.scoreFnRuns.inc()\n\n    const score = this.computeScore(id, pstats, this.params, this.peerIPs)\n    const cacheUntil = now + this.scoreCacheValidityMs\n\n    if (cacheEntry != null) {\n      this.metrics?.scoreCachedDelta.observe(Math.abs(score - cacheEntry.score))\n      cacheEntry.score = score\n      cacheEntry.cacheUntil = cacheUntil\n    } else {\n      this.scoreCache.set(id, { score, cacheUntil })\n    }\n\n    return score\n  }\n\n  /**\n   * Apply a behavioural penalty to a peer\n   */\n  addPenalty (id: PeerIdStr, penalty: number, penaltyLabel: ScorePenalty): void {\n    const pstats = this.peerStats.get(id)\n    if (pstats != null) {\n      pstats.behaviourPenalty += penalty\n      this.metrics?.onScorePenalty(penaltyLabel)\n    }\n  }\n\n  addPeer (id: PeerIdStr): void {\n    // create peer stats (not including topic stats for each topic to be scored)\n    // topic stats will be added as needed\n    const pstats: PeerStats = {\n      connected: true,\n      expire: 0,\n      topics: {},\n      knownIPs: new Set(),\n      behaviourPenalty: 0\n    }\n    this.peerStats.set(id, pstats)\n  }\n\n  /** Adds a new IP to a peer, if the peer is not known the update is ignored */\n  addIP (id: PeerIdStr, ip: string): void {\n    const pstats = this.peerStats.get(id)\n    if (pstats != null) {\n      pstats.knownIPs.add(ip)\n    }\n\n    this.peerIPs.getOrDefault(ip).add(id)\n  }\n\n  /** Remove peer association with IP */\n  removeIP (id: PeerIdStr, ip: string): void {\n    const pstats = this.peerStats.get(id)\n    if (pstats != null) {\n      pstats.knownIPs.delete(ip)\n    }\n\n    const peersWithIP = this.peerIPs.get(ip)\n    if (peersWithIP != null) {\n      peersWithIP.delete(id)\n      if (peersWithIP.size === 0) {\n        this.peerIPs.delete(ip)\n      }\n    }\n  }\n\n  removePeer (id: PeerIdStr): void {\n    const pstats = this.peerStats.get(id)\n    if (pstats == null) {\n      return\n    }\n\n    // decide whether to retain the score; this currently only retains non-positive scores\n    // to dissuade attacks on the score function.\n    if (this.score(id) > 0) {\n      this.removeIPsForPeer(id, pstats.knownIPs)\n      this.peerStats.delete(id)\n      return\n    }\n\n    // furthermore, when we decide to retain the score, the firstMessageDelivery counters are\n    // reset to 0 and mesh delivery penalties applied.\n    Object.entries(pstats.topics).forEach(([topic, tstats]) => {\n      tstats.firstMessageDeliveries = 0\n\n      const threshold = this.params.topics[topic].meshMessageDeliveriesThreshold\n      if (tstats.inMesh && tstats.meshMessageDeliveriesActive && tstats.meshMessageDeliveries < threshold) {\n        const deficit = threshold - tstats.meshMessageDeliveries\n        tstats.meshFailurePenalty += deficit * deficit\n      }\n\n      tstats.inMesh = false\n      tstats.meshMessageDeliveriesActive = false\n    })\n\n    pstats.connected = false\n    pstats.expire = Date.now() + this.params.retainScore\n  }\n\n  /** Handles scoring functionality as a peer GRAFTs to a topic. */\n  graft (id: PeerIdStr, topic: TopicStr): void {\n    const pstats = this.peerStats.get(id)\n    if (pstats != null) {\n      const tstats = this.getPtopicStats(pstats, topic)\n      if (tstats != null) {\n        // if we are scoring the topic, update the mesh status.\n        tstats.inMesh = true\n        tstats.graftTime = Date.now()\n        tstats.meshTime = 0\n        tstats.meshMessageDeliveriesActive = false\n      }\n    }\n  }\n\n  /** Handles scoring functionality as a peer PRUNEs from a topic. */\n  prune (id: PeerIdStr, topic: TopicStr): void {\n    const pstats = this.peerStats.get(id)\n    if (pstats != null) {\n      const tstats = this.getPtopicStats(pstats, topic)\n      if (tstats != null) {\n        // sticky mesh delivery rate failure penalty\n        const threshold = this.params.topics[topic].meshMessageDeliveriesThreshold\n        if (tstats.meshMessageDeliveriesActive && tstats.meshMessageDeliveries < threshold) {\n          const deficit = threshold - tstats.meshMessageDeliveries\n          tstats.meshFailurePenalty += deficit * deficit\n        }\n        tstats.meshMessageDeliveriesActive = false\n        tstats.inMesh = false\n\n        // TODO: Consider clearing score cache on important penalties\n        // this.scoreCache.delete(id)\n      }\n    }\n  }\n\n  validateMessage (msgIdStr: MsgIdStr): void {\n    this.deliveryRecords.ensureRecord(msgIdStr)\n  }\n\n  deliverMessage (from: PeerIdStr, msgIdStr: MsgIdStr, topic: TopicStr): void {\n    this.markFirstMessageDelivery(from, topic)\n\n    const drec = this.deliveryRecords.ensureRecord(msgIdStr)\n    const now = Date.now()\n\n    // defensive check that this is the first delivery trace -- delivery status should be unknown\n    if (drec.status !== DeliveryRecordStatus.unknown) {\n      this.log(\n        'unexpected delivery: message from %s was first seen %s ago and has delivery status %s',\n        from,\n        now - drec.firstSeenTsMs,\n        DeliveryRecordStatus[drec.status]\n      )\n      return\n    }\n\n    // mark the message as valid and reward mesh peers that have already forwarded it to us\n    drec.status = DeliveryRecordStatus.valid\n    drec.validated = now\n    drec.peers.forEach((p) => {\n      // this check is to make sure a peer can't send us a message twice and get a double count\n      // if it is a first delivery.\n      if (p !== from.toString()) {\n        this.markDuplicateMessageDelivery(p, topic)\n      }\n    })\n  }\n\n  /**\n   * Similar to `rejectMessage` except does not require the message id or reason for an invalid message.\n   */\n  rejectInvalidMessage (from: PeerIdStr, topic: TopicStr): void {\n    this.markInvalidMessageDelivery(from, topic)\n  }\n\n  rejectMessage (from: PeerIdStr, msgIdStr: MsgIdStr, topic: TopicStr, reason: RejectReason): void {\n    // eslint-disable-next-line default-case\n    switch (reason) {\n      // these messages are not tracked, but the peer is penalized as they are invalid\n      case RejectReason.Error:\n        this.markInvalidMessageDelivery(from, topic)\n        return\n\n      // we ignore those messages, so do nothing.\n      case RejectReason.Blacklisted:\n        return\n\n      // the rest are handled after record creation\n    }\n\n    const drec = this.deliveryRecords.ensureRecord(msgIdStr)\n\n    // defensive check that this is the first rejection -- delivery status should be unknown\n    if (drec.status !== DeliveryRecordStatus.unknown) {\n      this.log(\n        'unexpected rejection: message from %s was first seen %s ago and has delivery status %d',\n        from,\n        Date.now() - drec.firstSeenTsMs,\n        DeliveryRecordStatus[drec.status]\n      )\n      return\n    }\n\n    if (reason === RejectReason.Ignore) {\n      // we were explicitly instructed by the validator to ignore the message but not penalize the peer\n      drec.status = DeliveryRecordStatus.ignored\n      drec.peers.clear()\n      return\n    }\n\n    // mark the message as invalid and penalize peers that have already forwarded it.\n    drec.status = DeliveryRecordStatus.invalid\n\n    this.markInvalidMessageDelivery(from, topic)\n    drec.peers.forEach((p) => {\n      this.markInvalidMessageDelivery(p, topic)\n    })\n\n    // release the delivery time tracking map to free some memory early\n    drec.peers.clear()\n  }\n\n  duplicateMessage (from: PeerIdStr, msgIdStr: MsgIdStr, topic: TopicStr): void {\n    const drec = this.deliveryRecords.ensureRecord(msgIdStr)\n\n    if (drec.peers.has(from)) {\n      // we have already seen this duplicate\n      return\n    }\n\n    // eslint-disable-next-line default-case\n    switch (drec.status) {\n      case DeliveryRecordStatus.unknown:\n        // the message is being validated; track the peer delivery and wait for\n        // the Deliver/Reject/Ignore notification.\n        drec.peers.add(from)\n        break\n\n      case DeliveryRecordStatus.valid:\n        // mark the peer delivery time to only count a duplicate delivery once.\n        drec.peers.add(from)\n        this.markDuplicateMessageDelivery(from, topic, drec.validated)\n        break\n\n      case DeliveryRecordStatus.invalid:\n        // we no longer track delivery time\n        this.markInvalidMessageDelivery(from, topic)\n        break\n\n      case DeliveryRecordStatus.ignored:\n        // the message was ignored; do nothing (we don't know if it was valid)\n        break\n    }\n  }\n\n  /**\n   * Increments the \"invalid message deliveries\" counter for all scored topics the message is published in.\n   */\n  public markInvalidMessageDelivery (from: PeerIdStr, topic: TopicStr): void {\n    const pstats = this.peerStats.get(from)\n    if (pstats != null) {\n      const tstats = this.getPtopicStats(pstats, topic)\n      if (tstats != null) {\n        tstats.invalidMessageDeliveries += 1\n      }\n    }\n  }\n\n  /**\n   * Increments the \"first message deliveries\" counter for all scored topics the message is published in,\n   * as well as the \"mesh message deliveries\" counter, if the peer is in the mesh for the topic.\n   * Messages already known (with the seenCache) are counted with markDuplicateMessageDelivery()\n   */\n  public markFirstMessageDelivery (from: PeerIdStr, topic: TopicStr): void {\n    const pstats = this.peerStats.get(from)\n    if (pstats != null) {\n      const tstats = this.getPtopicStats(pstats, topic)\n      if (tstats != null) {\n        let cap = this.params.topics[topic].firstMessageDeliveriesCap\n        tstats.firstMessageDeliveries = Math.min(cap, tstats.firstMessageDeliveries + 1)\n\n        if (tstats.inMesh) {\n          cap = this.params.topics[topic].meshMessageDeliveriesCap\n          tstats.meshMessageDeliveries = Math.min(cap, tstats.meshMessageDeliveries + 1)\n        }\n      }\n    }\n  }\n\n  /**\n   * Increments the \"mesh message deliveries\" counter for messages we've seen before,\n   * as long the message was received within the P3 window.\n   */\n  public markDuplicateMessageDelivery (from: PeerIdStr, topic: TopicStr, validatedTime?: number): void {\n    const pstats = this.peerStats.get(from)\n    if (pstats != null) {\n      const now = validatedTime !== undefined ? Date.now() : 0\n\n      const tstats = this.getPtopicStats(pstats, topic)\n      // eslint-disable-next-line @typescript-eslint/prefer-optional-chain\n      if (tstats != null && tstats.inMesh) {\n        const tparams = this.params.topics[topic]\n\n        // check against the mesh delivery window -- if the validated time is passed as 0, then\n        // the message was received before we finished validation and thus falls within the mesh\n        // delivery window.\n        if (validatedTime !== undefined) {\n          const deliveryDelayMs = now - validatedTime\n          const isLateDelivery = deliveryDelayMs > tparams.meshMessageDeliveriesWindow\n          this.metrics?.onDuplicateMsgDelivery(topic, deliveryDelayMs, isLateDelivery)\n\n          if (isLateDelivery) {\n            return\n          }\n        }\n\n        const cap = tparams.meshMessageDeliveriesCap\n        tstats.meshMessageDeliveries = Math.min(cap, tstats.meshMessageDeliveries + 1)\n      }\n    }\n  }\n\n  /**\n   * Removes an IP list from the tracking list for a peer.\n   */\n  private removeIPsForPeer (id: PeerIdStr, ipsToRemove: Set<IPStr>): void {\n    for (const ipToRemove of ipsToRemove) {\n      const peerSet = this.peerIPs.get(ipToRemove)\n      if (peerSet != null) {\n        peerSet.delete(id)\n        if (peerSet.size === 0) {\n          this.peerIPs.delete(ipToRemove)\n        }\n      }\n    }\n  }\n\n  /**\n   * Returns topic stats if they exist, otherwise if the supplied parameters score the\n   * topic, inserts the default stats and returns a reference to those. If neither apply, returns None.\n   */\n  private getPtopicStats (pstats: PeerStats, topic: TopicStr): TopicStats | null {\n    let topicStats: TopicStats | undefined = pstats.topics[topic]\n\n    if (topicStats !== undefined) {\n      return topicStats\n    }\n\n    if (this.params.topics[topic] !== undefined) {\n      topicStats = {\n        inMesh: false,\n        graftTime: 0,\n        meshTime: 0,\n        firstMessageDeliveries: 0,\n        meshMessageDeliveries: 0,\n        meshMessageDeliveriesActive: false,\n        meshFailurePenalty: 0,\n        invalidMessageDeliveries: 0\n      }\n      pstats.topics[topic] = topicStats\n\n      return topicStats\n    }\n\n    return null\n  }\n}\n", "import type { PeerScoreParams } from './peer-score-params.js'\nimport type { PeerStats } from './peer-stats.js'\n\ntype TopicLabel = string\ntype TopicStr = string\ntype TopicStrToLabel = Map<TopicStr, TopicLabel>\n\nexport interface TopicScoreWeights<T> {\n  p1w: T\n  p2w: T\n  p3w: T\n  p3bw: T\n  p4w: T\n}\nexport interface ScoreWeights<T> {\n  byTopic: Map<TopicLabel, TopicScoreWeights<T>>\n  p5w: T\n  p6w: T\n  p7w: T\n  score: T\n}\n\nexport function computeScoreWeights (\n  peer: string,\n  pstats: PeerStats,\n  params: PeerScoreParams,\n  peerIPs: Map<string, Set<string>>,\n  topicStrToLabel: TopicStrToLabel\n): ScoreWeights<number> {\n  let score = 0\n\n  const byTopic = new Map<TopicLabel, TopicScoreWeights<number>>()\n\n  // topic stores\n  Object.entries(pstats.topics).forEach(([topic, tstats]) => {\n    // the topic parameters\n    // Aggregate by known topicLabel or throw to 'unknown'. This prevent too high cardinality\n    const topicLabel = topicStrToLabel.get(topic) ?? 'unknown'\n    const topicParams = params.topics[topic]\n    if (topicParams === undefined) {\n      // we are not scoring this topic\n      return\n    }\n\n    let topicScores = byTopic.get(topicLabel)\n    if (topicScores == null) {\n      topicScores = {\n        p1w: 0,\n        p2w: 0,\n        p3w: 0,\n        p3bw: 0,\n        p4w: 0\n      }\n      byTopic.set(topicLabel, topicScores)\n    }\n\n    let p1w = 0\n    let p2w = 0\n    let p3w = 0\n    let p3bw = 0\n    let p4w = 0\n\n    // P1: time in Mesh\n    if (tstats.inMesh) {\n      const p1 = Math.max(tstats.meshTime / topicParams.timeInMeshQuantum, topicParams.timeInMeshCap)\n      p1w += p1 * topicParams.timeInMeshWeight\n    }\n\n    // P2: first message deliveries\n    let p2 = tstats.firstMessageDeliveries\n    if (p2 > topicParams.firstMessageDeliveriesCap) {\n      p2 = topicParams.firstMessageDeliveriesCap\n    }\n    p2w += p2 * topicParams.firstMessageDeliveriesWeight\n\n    // P3: mesh message deliveries\n    if (\n      tstats.meshMessageDeliveriesActive &&\n      tstats.meshMessageDeliveries < topicParams.meshMessageDeliveriesThreshold\n    ) {\n      const deficit = topicParams.meshMessageDeliveriesThreshold - tstats.meshMessageDeliveries\n      const p3 = deficit * deficit\n      p3w += p3 * topicParams.meshMessageDeliveriesWeight\n    }\n\n    // P3b:\n    // NOTE: the weight of P3b is negative (validated in validateTopicScoreParams) so this detracts\n    const p3b = tstats.meshFailurePenalty\n    p3bw += p3b * topicParams.meshFailurePenaltyWeight\n\n    // P4: invalid messages\n    // NOTE: the weight of P4 is negative (validated in validateTopicScoreParams) so this detracts\n    const p4 = tstats.invalidMessageDeliveries * tstats.invalidMessageDeliveries\n    p4w += p4 * topicParams.invalidMessageDeliveriesWeight\n\n    // update score, mixing with topic weight\n    score += (p1w + p2w + p3w + p3bw + p4w) * topicParams.topicWeight\n\n    topicScores.p1w += p1w\n    topicScores.p2w += p2w\n    topicScores.p3w += p3w\n    topicScores.p3bw += p3bw\n    topicScores.p4w += p4w\n  })\n\n  // apply the topic score cap, if any\n  if (params.topicScoreCap > 0 && score > params.topicScoreCap) {\n    score = params.topicScoreCap\n\n    // Proportionally apply cap to all individual contributions\n    const capF = params.topicScoreCap / score\n    for (const ws of byTopic.values()) {\n      ws.p1w *= capF\n      ws.p2w *= capF\n      ws.p3w *= capF\n      ws.p3bw *= capF\n      ws.p4w *= capF\n    }\n  }\n\n  let p5w = 0\n  let p6w = 0\n  let p7w = 0\n\n  // P5: application-specific score\n  const p5 = params.appSpecificScore(peer)\n  p5w += p5 * params.appSpecificWeight\n\n  // P6: IP colocation factor\n  pstats.knownIPs.forEach((ip) => {\n    if (params.IPColocationFactorWhitelist.has(ip)) {\n      return\n    }\n\n    // P6 has a cliff (IPColocationFactorThreshold)\n    // It's only applied if at least that many peers are connected to us from that source IP addr.\n    // It is quadratic, and the weight is negative (validated in validatePeerScoreParams)\n    const peersInIP = peerIPs.get(ip)\n    const numPeersInIP = (peersInIP != null) ? peersInIP.size : 0\n    if (numPeersInIP > params.IPColocationFactorThreshold) {\n      const surplus = numPeersInIP - params.IPColocationFactorThreshold\n      const p6 = surplus * surplus\n      p6w += p6 * params.IPColocationFactorWeight\n    }\n  })\n\n  // P7: behavioural pattern penalty\n  const p7 = pstats.behaviourPenalty * pstats.behaviourPenalty\n  p7w += p7 * params.behaviourPenaltyWeight\n\n  score += p5w + p6w + p7w\n\n  return {\n    byTopic,\n    p5w,\n    p6w,\n    p7w,\n    score\n  }\n}\n\nexport function computeAllPeersScoreWeights (\n  peerIdStrs: Iterable<string>,\n  peerStats: Map<string, PeerStats>,\n  params: PeerScoreParams,\n  peerIPs: Map<string, Set<string>>,\n  topicStrToLabel: TopicStrToLabel\n): ScoreWeights<number[]> {\n  const sw: ScoreWeights<number[]> = {\n    byTopic: new Map(),\n    p5w: [],\n    p6w: [],\n    p7w: [],\n    score: []\n  }\n\n  for (const peerIdStr of peerIdStrs) {\n    const pstats = peerStats.get(peerIdStr)\n    if (pstats != null) {\n      const swPeer = computeScoreWeights(peerIdStr, pstats, params, peerIPs, topicStrToLabel)\n\n      for (const [topic, swPeerTopic] of swPeer.byTopic) {\n        let swTopic = sw.byTopic.get(topic)\n        if (swTopic == null) {\n          swTopic = {\n            p1w: [],\n            p2w: [],\n            p3w: [],\n            p3bw: [],\n            p4w: []\n          }\n          sw.byTopic.set(topic, swTopic)\n        }\n\n        swTopic.p1w.push(swPeerTopic.p1w)\n        swTopic.p2w.push(swPeerTopic.p2w)\n        swTopic.p3w.push(swPeerTopic.p3w)\n        swTopic.p3bw.push(swPeerTopic.p3bw)\n        swTopic.p4w.push(swPeerTopic.p4w)\n      }\n\n      sw.p5w.push(swPeer.p5w)\n      sw.p6w.push(swPeer.p6w)\n      sw.p7w.push(swPeer.p7w)\n      sw.score.push(swPeer.score)\n    } else {\n      sw.p5w.push(0)\n      sw.p6w.push(0)\n      sw.p7w.push(0)\n      sw.score.push(0)\n    }\n  }\n\n  return sw\n}\n", "import { encode, decode } from 'it-length-prefixed'\nimport { pipe } from 'it-pipe'\nimport { pushable, type Pushable } from 'it-pushable'\nimport type { Stream } from '@libp2p/interface'\nimport type { Uint8ArrayList } from 'uint8arraylist'\n\ninterface OutboundStreamOpts {\n  /** Max size in bytes for pushable buffer. If full, will throw on .push */\n  maxBufferSize?: number\n}\n\ninterface InboundStreamOpts {\n  /** Max size in bytes for reading messages from the stream */\n  maxDataLength?: number\n}\n\nexport class OutboundStream {\n  private readonly pushable: Pushable<Uint8Array | Uint8ArrayList>\n  private readonly closeController: AbortController\n  private readonly maxBufferSize: number\n\n  constructor (private readonly rawStream: Stream, errCallback: (e: Error) => void, opts: OutboundStreamOpts) {\n    this.pushable = pushable()\n    this.closeController = new AbortController()\n    this.maxBufferSize = opts.maxBufferSize ?? Infinity\n\n    this.closeController.signal.addEventListener('abort', () => {\n      rawStream.close()\n        .catch(err => {\n          rawStream.abort(err)\n        })\n    })\n\n    pipe(\n      this.pushable,\n      this.rawStream\n    ).catch(errCallback)\n  }\n\n  get protocol (): string {\n    // TODO remove this non-nullish assertion after https://github.com/libp2p/js-libp2p-interfaces/pull/265 is incorporated\n    // eslint-disable-next-line @typescript-eslint/no-non-null-assertion\n    return this.rawStream.protocol!\n  }\n\n  push (data: Uint8Array): void {\n    if (this.pushable.readableLength > this.maxBufferSize) {\n      throw Error(`OutboundStream buffer full, size > ${this.maxBufferSize}`)\n    }\n\n    this.pushable.push(encode.single(data))\n  }\n\n  /**\n   * Same to push() but this is prefixed data so no need to encode length prefixed again\n   */\n  pushPrefixed (data: Uint8ArrayList): void {\n    if (this.pushable.readableLength > this.maxBufferSize) {\n      throw Error(`OutboundStream buffer full, size > ${this.maxBufferSize}`)\n    }\n    this.pushable.push(data)\n  }\n\n  async close (): Promise<void> {\n    this.closeController.abort()\n    // similar to pushable.end() but clear the internal buffer\n    await this.pushable.return()\n  }\n}\n\nexport class InboundStream {\n  public readonly source: AsyncIterable<Uint8ArrayList>\n\n  private readonly rawStream: Stream\n  private readonly closeController: AbortController\n\n  constructor (rawStream: Stream, opts: InboundStreamOpts = {}) {\n    this.rawStream = rawStream\n    this.closeController = new AbortController()\n\n    this.closeController.signal.addEventListener('abort', () => {\n      rawStream.close()\n        .catch(err => {\n          rawStream.abort(err)\n        })\n    })\n\n    this.source = pipe(\n      this.rawStream,\n      (source) => decode(source, opts)\n    )\n  }\n\n  async close (): Promise<void> {\n    this.closeController.abort()\n  }\n}\n", "import { type MsgIdStr, type MsgIdToStrFn, type PeerIdStr, RejectReason } from './types.js'\nimport type { Metrics } from './metrics.js'\n\n/**\n * IWantTracer is an internal tracer that tracks IWANT requests in order to penalize\n * peers who don't follow up on IWANT requests after an IHAVE advertisement.\n * The tracking of promises is probabilistic to avoid using too much memory.\n *\n * Note: Do not confuse these 'promises' with JS Promise objects.\n * These 'promises' are merely expectations of a peer's behavior.\n */\nexport class IWantTracer {\n  /**\n   * Promises to deliver a message\n   * Map per message id, per peer, promise expiration time\n   */\n  private readonly promises = new Map<MsgIdStr, Map<PeerIdStr, number>>()\n  /**\n   * First request time by msgId. Used for metrics to track expire times.\n   * Necessary to know if peers are actually breaking promises or simply sending them a bit later\n   */\n  private readonly requestMsByMsg = new Map<MsgIdStr, number>()\n  private readonly requestMsByMsgExpire: number\n\n  constructor (\n    private readonly gossipsubIWantFollowupMs: number,\n    private readonly msgIdToStrFn: MsgIdToStrFn,\n    private readonly metrics: Metrics | null\n  ) {\n    this.requestMsByMsgExpire = 10 * gossipsubIWantFollowupMs\n  }\n\n  get size (): number {\n    return this.promises.size\n  }\n\n  get requestMsByMsgSize (): number {\n    return this.requestMsByMsg.size\n  }\n\n  /**\n   * Track a promise to deliver a message from a list of msgIds we are requesting\n   */\n  addPromise (from: PeerIdStr, msgIds: Uint8Array[]): void {\n    // pick msgId randomly from the list\n    const ix = Math.floor(Math.random() * msgIds.length)\n    const msgId = msgIds[ix]\n    const msgIdStr = this.msgIdToStrFn(msgId)\n\n    let expireByPeer = this.promises.get(msgIdStr)\n    if (expireByPeer == null) {\n      expireByPeer = new Map()\n      this.promises.set(msgIdStr, expireByPeer)\n    }\n\n    const now = Date.now()\n\n    // If a promise for this message id and peer already exists we don't update the expiry\n    if (!expireByPeer.has(from)) {\n      expireByPeer.set(from, now + this.gossipsubIWantFollowupMs)\n\n      if (this.metrics != null) {\n        this.metrics.iwantPromiseStarted.inc(1)\n        if (!this.requestMsByMsg.has(msgIdStr)) {\n          this.requestMsByMsg.set(msgIdStr, now)\n        }\n      }\n    }\n  }\n\n  /**\n   * Returns the number of broken promises for each peer who didn't follow up on an IWANT request.\n   *\n   * This should be called not too often relative to the expire times, since it iterates over the whole data.\n   */\n  getBrokenPromises (): Map<PeerIdStr, number> {\n    const now = Date.now()\n    const result = new Map<PeerIdStr, number>()\n\n    let brokenPromises = 0\n\n    this.promises.forEach((expireByPeer, msgId) => {\n      expireByPeer.forEach((expire, p) => {\n        // the promise has been broken\n        if (expire < now) {\n          // add 1 to result\n          result.set(p, (result.get(p) ?? 0) + 1)\n          // delete from tracked promises\n          expireByPeer.delete(p)\n          // for metrics\n          brokenPromises++\n        }\n      })\n      // clean up empty promises for a msgId\n      if (expireByPeer.size === 0) {\n        this.promises.delete(msgId)\n      }\n    })\n\n    this.metrics?.iwantPromiseBroken.inc(brokenPromises)\n\n    return result\n  }\n\n  /**\n   * Someone delivered a message, stop tracking promises for it\n   */\n  deliverMessage (msgIdStr: MsgIdStr, isDuplicate = false): void {\n    this.trackMessage(msgIdStr)\n\n    const expireByPeer = this.promises.get(msgIdStr)\n\n    // Expired promise, check requestMsByMsg\n    if (expireByPeer != null) {\n      this.promises.delete(msgIdStr)\n\n      if (this.metrics != null) {\n        this.metrics.iwantPromiseResolved.inc(1)\n        if (isDuplicate) this.metrics.iwantPromiseResolvedFromDuplicate.inc(1)\n        this.metrics.iwantPromiseResolvedPeers.inc(expireByPeer.size)\n      }\n    }\n  }\n\n  /**\n   * A message got rejected, so we can stop tracking promises and let the score penalty apply from invalid message delivery,\n   * unless its an obviously invalid message.\n   */\n  rejectMessage (msgIdStr: MsgIdStr, reason: RejectReason): void {\n    this.trackMessage(msgIdStr)\n\n    // A message got rejected, so we can stop tracking promises and let the score penalty apply.\n    // With the expection of obvious invalid messages\n    switch (reason) {\n      case RejectReason.Error:\n        return\n      default:\n        break\n    }\n\n    this.promises.delete(msgIdStr)\n  }\n\n  clear (): void {\n    this.promises.clear()\n  }\n\n  prune (): void {\n    const maxMs = Date.now() - this.requestMsByMsgExpire\n    let count = 0\n\n    for (const [k, v] of this.requestMsByMsg.entries()) {\n      if (v < maxMs) {\n        // messages that stay too long in the requestMsByMsg map, delete\n        this.requestMsByMsg.delete(k)\n        count++\n      } else {\n        // recent messages, keep them\n        // sort by insertion order\n        break\n      }\n    }\n\n    this.metrics?.iwantMessagePruned.inc(count)\n  }\n\n  private trackMessage (msgIdStr: MsgIdStr): void {\n    if (this.metrics != null) {\n      const requestMs = this.requestMsByMsg.get(msgIdStr)\n      if (requestMs !== undefined) {\n        this.metrics.iwantPromiseDeliveryTime.observe((Date.now() - requestMs) / 1000)\n        this.requestMsByMsg.delete(msgIdStr)\n      }\n    }\n  }\n}\n", "import { randomBytes } from '@libp2p/crypto'\nimport { marshalPublicKey, unmarshalPublicKey } from '@libp2p/crypto/keys'\nimport { StrictSign, StrictNoSign, type Message, type PublicKey, type PeerId } from '@libp2p/interface'\nimport { peerIdFromBytes } from '@libp2p/peer-id'\nimport { concat as uint8ArrayConcat } from 'uint8arrays/concat'\nimport { equals as uint8ArrayEquals } from 'uint8arrays/equals'\nimport { fromString as uint8ArrayFromString } from 'uint8arrays/from-string'\nimport { toString as uint8ArrayToString } from 'uint8arrays/to-string'\nimport { RPC } from '../message/rpc.js'\nimport { type PublishConfig, PublishConfigType, type TopicStr, ValidateError } from '../types.js'\n\nexport const SignPrefix = uint8ArrayFromString('libp2p-pubsub:')\n\nexport interface RawMessageAndMessage {\n  raw: RPC.IMessage\n  msg: Message\n}\n\nexport async function buildRawMessage (\n  publishConfig: PublishConfig,\n  topic: TopicStr,\n  originalData: Uint8Array,\n  transformedData: Uint8Array\n): Promise<RawMessageAndMessage> {\n  switch (publishConfig.type) {\n    case PublishConfigType.Signing: {\n      const rpcMsg: RPC.IMessage = {\n        from: publishConfig.author.toBytes(),\n        data: transformedData,\n        seqno: randomBytes(8),\n        topic,\n        signature: undefined, // Exclude signature field for signing\n        key: undefined // Exclude key field for signing\n      }\n\n      // Get the message in bytes, and prepend with the pubsub prefix\n      // the signature is over the bytes \"libp2p-pubsub:<protobuf-message>\"\n      const bytes = uint8ArrayConcat([SignPrefix, RPC.Message.encode(rpcMsg).finish()])\n\n      rpcMsg.signature = await publishConfig.privateKey.sign(bytes)\n      rpcMsg.key = publishConfig.key\n\n      const msg: Message = {\n        type: 'signed',\n        from: publishConfig.author,\n        data: originalData,\n        sequenceNumber: BigInt(`0x${uint8ArrayToString(rpcMsg.seqno as Uint8Array, 'base16')}`),\n        topic,\n        signature: rpcMsg.signature,\n        key: rpcMsg.key\n      }\n      return {\n        raw: rpcMsg,\n        msg\n      }\n    }\n\n    case PublishConfigType.Anonymous: {\n      return {\n        raw: {\n          from: undefined,\n          data: transformedData,\n          seqno: undefined,\n          topic,\n          signature: undefined,\n          key: undefined\n        },\n        msg: {\n          type: 'unsigned',\n          data: originalData,\n          topic\n        }\n      }\n    }\n\n    default:\n      throw new Error('Unreachable')\n  }\n}\n\nexport type ValidationResult = { valid: true, message: Message } | { valid: false, error: ValidateError }\n\nexport async function validateToRawMessage (\n  signaturePolicy: typeof StrictNoSign | typeof StrictSign,\n  msg: RPC.IMessage\n): Promise<ValidationResult> {\n  // If strict-sign, verify all\n  // If anonymous (no-sign), ensure no preven\n\n  switch (signaturePolicy) {\n    case StrictNoSign:\n      if (msg.signature != null) return { valid: false, error: ValidateError.SignaturePresent }\n      if (msg.seqno != null) return { valid: false, error: ValidateError.SeqnoPresent }\n      if (msg.key != null) return { valid: false, error: ValidateError.FromPresent }\n\n      return { valid: true, message: { type: 'unsigned', topic: msg.topic, data: msg.data ?? new Uint8Array(0) } }\n\n    case StrictSign: {\n      // Verify seqno\n      if (msg.seqno == null) return { valid: false, error: ValidateError.InvalidSeqno }\n      if (msg.seqno.length !== 8) {\n        return { valid: false, error: ValidateError.InvalidSeqno }\n      }\n\n      if (msg.signature == null) return { valid: false, error: ValidateError.InvalidSignature }\n      if (msg.from == null) return { valid: false, error: ValidateError.InvalidPeerId }\n\n      let fromPeerId: PeerId\n      try {\n        // TODO: Fix PeerId types\n        fromPeerId = peerIdFromBytes(msg.from)\n      } catch (e) {\n        return { valid: false, error: ValidateError.InvalidPeerId }\n      }\n\n      // - check from defined\n      // - transform source to PeerId\n      // - parse signature\n      // - get .key, else from source\n      // - check key == source if present\n      // - verify sig\n\n      let publicKey: PublicKey\n      if (msg.key != null) {\n        publicKey = unmarshalPublicKey(msg.key)\n        // TODO: Should `fromPeerId.pubKey` be optional?\n        if (fromPeerId.publicKey !== undefined && !uint8ArrayEquals(publicKey.bytes, fromPeerId.publicKey)) {\n          return { valid: false, error: ValidateError.InvalidPeerId }\n        }\n      } else {\n        if (fromPeerId.publicKey == null) {\n          return { valid: false, error: ValidateError.InvalidPeerId }\n        }\n        publicKey = unmarshalPublicKey(fromPeerId.publicKey)\n      }\n\n      const rpcMsgPreSign: RPC.IMessage = {\n        from: msg.from,\n        data: msg.data,\n        seqno: msg.seqno,\n        topic: msg.topic,\n        signature: undefined, // Exclude signature field for signing\n        key: undefined // Exclude key field for signing\n      }\n\n      // Get the message in bytes, and prepend with the pubsub prefix\n      // the signature is over the bytes \"libp2p-pubsub:<protobuf-message>\"\n      const bytes = uint8ArrayConcat([SignPrefix, RPC.Message.encode(rpcMsgPreSign).finish()])\n\n      if (!(await publicKey.verify(bytes, msg.signature))) {\n        return { valid: false, error: ValidateError.InvalidSignature }\n      }\n\n      return {\n        valid: true,\n        message: {\n          type: 'signed',\n          from: fromPeerId,\n          data: msg.data ?? new Uint8Array(0),\n          sequenceNumber: BigInt(`0x${uint8ArrayToString(msg.seqno, 'base16')}`),\n          topic: msg.topic,\n          signature: msg.signature,\n          key: msg.key ?? marshalPublicKey(publicKey)\n        }\n      }\n    }\n\n    default:\n      throw new Error('Unreachable')\n  }\n}\n", "/**\n * Pseudo-randomly shuffles an array\n *\n * Mutates the input array\n */\nexport function shuffle<T> (arr: T[]): T[] {\n  if (arr.length <= 1) {\n    return arr\n  }\n  const randInt = (): number => {\n    return Math.floor(Math.random() * Math.floor(arr.length))\n  }\n\n  for (let i = 0; i < arr.length; i++) {\n    const j = randInt()\n    const tmp = arr[i]\n    arr[i] = arr[j]\n    arr[j] = tmp\n  }\n  return arr\n}\n", "import { toString } from 'uint8arrays/to-string'\n\n/**\n * Browser friendly function to convert Uint8Array message id to base64 string.\n */\nexport function messageIdToString (msgId: Uint8Array): string {\n  return toString(msgId, 'base64')\n}\n", "import { unmarshalPrivateKey } from '@libp2p/crypto/keys'\nimport { StrictSign, StrictNoSign } from '@libp2p/interface'\nimport { type PublishConfig, PublishConfigType } from '../types.js'\nimport type { PeerId } from '@libp2p/interface'\n\n/**\n * Prepare a PublishConfig object from a PeerId.\n */\nexport async function getPublishConfigFromPeerId (\n  signaturePolicy: typeof StrictSign | typeof StrictNoSign,\n  peerId?: PeerId\n): Promise<PublishConfig> {\n  switch (signaturePolicy) {\n    case StrictSign: {\n      if (peerId == null) {\n        throw Error('Must provide PeerId')\n      }\n\n      if (peerId.privateKey == null) {\n        throw Error('Cannot sign message, no private key present')\n      }\n\n      if (peerId.publicKey == null) {\n        throw Error('Cannot sign message, no public key present')\n      }\n\n      // Transform privateKey once at initialization time instead of once per message\n      const privateKey = await unmarshalPrivateKey(peerId.privateKey)\n\n      return {\n        type: PublishConfigType.Signing,\n        author: peerId,\n        key: peerId.publicKey,\n        privateKey\n      }\n    }\n\n    case StrictNoSign:\n      return {\n        type: PublishConfigType.Anonymous\n      }\n\n    default:\n      throw new Error(`Unknown signature policy \"${signaturePolicy}\"`)\n  }\n}\n", "import { randomBytes } from '@libp2p/crypto'\nimport { CodeError } from '@libp2p/interface'\nimport { peerIdFromBytes, peerIdFromKeys } from '@libp2p/peer-id'\nimport { sha256 } from 'multiformats/hashes/sha2'\nimport { fromString as uint8ArrayFromString } from 'uint8arrays/from-string'\nimport { toString as uint8ArrayToString } from 'uint8arrays/to-string'\nimport { codes } from './errors.js'\nimport type { Message, PubSubRPCMessage } from '@libp2p/interface'\n\n/**\n * Generate a random sequence number\n */\nexport function randomSeqno (): bigint {\n  return BigInt(`0x${uint8ArrayToString(randomBytes(8), 'base16')}`)\n}\n\n/**\n * Generate a message id, based on the `key` and `seqno`\n */\nexport const msgId = (key: Uint8Array, seqno: bigint): Uint8Array => {\n  const seqnoBytes = uint8ArrayFromString(seqno.toString(16).padStart(16, '0'), 'base16')\n\n  const msgId = new Uint8Array(key.length + seqnoBytes.length)\n  msgId.set(key, 0)\n  msgId.set(seqnoBytes, key.length)\n\n  return msgId\n}\n\n/**\n * Generate a message id, based on message `data`\n */\nexport const noSignMsgId = (data: Uint8Array): Uint8Array | Promise<Uint8Array> => {\n  return sha256.encode(data)\n}\n\n/**\n * Check if any member of the first set is also a member\n * of the second set\n */\nexport const anyMatch = (a: Set<number> | number[], b: Set<number> | number[]): boolean => {\n  let bHas\n  if (Array.isArray(b)) {\n    bHas = (val: number) => b.includes(val)\n  } else {\n    bHas = (val: number) => b.has(val)\n  }\n\n  for (const val of a) {\n    if (bHas(val)) {\n      return true\n    }\n  }\n\n  return false\n}\n\n/**\n * Make everything an array\n */\nexport const ensureArray = function <T> (maybeArray: T | T[]): T[] {\n  if (!Array.isArray(maybeArray)) {\n    return [maybeArray]\n  }\n\n  return maybeArray\n}\n\nconst isSigned = async (message: PubSubRPCMessage): Promise<boolean> => {\n  if ((message.sequenceNumber == null) || (message.from == null) || (message.signature == null)) {\n    return false\n  }\n  // if a public key is present in the `from` field, the message should be signed\n  const fromID = peerIdFromBytes(message.from)\n  if (fromID.publicKey != null) {\n    return true\n  }\n\n  if (message.key != null) {\n    const signingID = await peerIdFromKeys(message.key)\n    return signingID.equals(fromID)\n  }\n\n  return false\n}\n\nexport const toMessage = async (message: PubSubRPCMessage): Promise<Message> => {\n  if (message.from == null) {\n    throw new CodeError('RPC message was missing from', codes.ERR_MISSING_FROM)\n  }\n\n  if (!await isSigned(message)) {\n    return {\n      type: 'unsigned',\n      topic: message.topic ?? '',\n      data: message.data ?? new Uint8Array(0)\n    }\n  }\n\n  const from = peerIdFromBytes(message.from)\n\n  const msg: Message = {\n    type: 'signed',\n    from: peerIdFromBytes(message.from),\n    topic: message.topic ?? '',\n    sequenceNumber: bigIntFromBytes(message.sequenceNumber ?? new Uint8Array(0)),\n    data: message.data ?? new Uint8Array(0),\n    signature: message.signature ?? new Uint8Array(0),\n    key: message.key ?? from.publicKey ?? new Uint8Array(0)\n  }\n\n  if (msg.key.length === 0) {\n    throw new CodeError('Signed RPC message was missing key', codes.ERR_MISSING_KEY)\n  }\n\n  return msg\n}\n\nexport const toRpcMessage = (message: Message): PubSubRPCMessage => {\n  if (message.type === 'signed') {\n    return {\n      from: message.from.multihash.bytes,\n      data: message.data,\n      sequenceNumber: bigIntToBytes(message.sequenceNumber),\n      topic: message.topic,\n      signature: message.signature,\n      key: message.key\n    }\n  }\n\n  return {\n    data: message.data,\n    topic: message.topic\n  }\n}\n\nexport const bigIntToBytes = (num: bigint): Uint8Array => {\n  let str = num.toString(16)\n\n  if (str.length % 2 !== 0) {\n    str = `0${str}`\n  }\n\n  return uint8ArrayFromString(str, 'base16')\n}\n\nexport const bigIntFromBytes = (num: Uint8Array): bigint => {\n  return BigInt(`0x${uint8ArrayToString(num, 'base16')}`)\n}\n", "import { msgId } from '@libp2p/pubsub/utils'\nimport { sha256 } from 'multiformats/hashes/sha2'\nimport type { Message } from '@libp2p/interface'\n\n/**\n * Generate a message id, based on the `key` and `seqno`\n */\nexport function msgIdFnStrictSign (msg: Message): Uint8Array {\n  if (msg.type !== 'signed') {\n    throw new Error('expected signed message type')\n  }\n  // Should never happen\n  if (msg.sequenceNumber == null) throw Error('missing seqno field')\n\n  // TODO: Should use .from here or key?\n  return msgId(msg.from.toBytes(), msg.sequenceNumber)\n}\n\n/**\n * Generate a message id, based on message `data`\n */\nexport async function msgIdFnStrictNoSign (msg: Message): Promise<Uint8Array> {\n  return sha256.encode(msg.data)\n}\n", "import { convertToString } from '@multiformats/multiaddr/convert'\nimport type { Multiaddr } from '@multiformats/multiaddr'\n\n// Protocols https://github.com/multiformats/multiaddr/blob/master/protocols.csv\n// code  size  name\n// 4     32    ip4\n// 41    128   ip6\nenum Protocol {\n  ip4 = 4,\n  ip6 = 41\n}\n\nexport function multiaddrToIPStr (multiaddr: Multiaddr): string | null {\n  for (const tuple of multiaddr.tuples()) {\n    switch (tuple[0]) {\n      case Protocol.ip4:\n      case Protocol.ip6:\n        // eslint-disable-next-line @typescript-eslint/no-non-null-assertion\n        return convertToString(tuple[0], tuple[1]!)\n      default:\n        break\n    }\n  }\n\n  return null\n}\n", "interface SimpleTimeCacheOpts {\n  validityMs: number\n}\n\ninterface CacheValue<T> {\n  value: T\n  validUntilMs: number\n}\n\n/**\n * This is similar to https://github.com/daviddias/time-cache/blob/master/src/index.js\n * for our own need, we don't use lodash throttle to improve performance.\n * This gives 4x - 5x performance gain compared to npm TimeCache\n */\nexport class SimpleTimeCache<T> {\n  private readonly entries = new Map<string | number, CacheValue<T>>()\n  private readonly validityMs: number\n\n  constructor (opts: SimpleTimeCacheOpts) {\n    this.validityMs = opts.validityMs\n\n    // allow negative validityMs so that this does not cache anything, spec test compliance.spec.js\n    // sends duplicate messages and expect peer to receive all. Application likely uses positive validityMs\n  }\n\n  get size (): number {\n    return this.entries.size\n  }\n\n  /** Returns true if there was a key collision and the entry is dropped */\n  put (key: string | number, value: T): boolean {\n    if (this.entries.has(key)) {\n      // Key collisions break insertion order in the entries cache, which break prune logic.\n      // prune relies on each iterated entry to have strictly ascending validUntilMs, else it\n      // won't prune expired entries and SimpleTimeCache will grow unexpectedly.\n      // As of Oct 2022 NodeJS v16, inserting the same key twice with different value does not\n      // change the key position in the iterator stream. A unit test asserts this behaviour.\n      return true\n    }\n\n    this.entries.set(key, { value, validUntilMs: Date.now() + this.validityMs })\n    return false\n  }\n\n  prune (): void {\n    const now = Date.now()\n\n    for (const [k, v] of this.entries.entries()) {\n      if (v.validUntilMs < now) {\n        this.entries.delete(k)\n      } else {\n        // Entries are inserted with strictly ascending validUntilMs.\n        // Stop early to save iterations\n        break\n      }\n    }\n  }\n\n  has (key: string): boolean {\n    return this.entries.has(key)\n  }\n\n  get (key: string | number): T | undefined {\n    const value = this.entries.get(key)\n    return (value != null) && value.validUntilMs >= Date.now() ? value.value : undefined\n  }\n\n  clear (): void {\n    this.entries.clear()\n  }\n}\n", "import { CustomEvent, TypedEventEmitter, StrictSign, StrictNoSign, TopicValidatorResult } from '@libp2p/interface'\nimport { peerIdFromBytes, peerIdFromString } from '@libp2p/peer-id'\nimport { encode } from 'it-length-prefixed'\nimport { pipe } from 'it-pipe'\nimport { pushable } from 'it-pushable'\nimport * as constants from './constants.js'\nimport {\n  ACCEPT_FROM_WHITELIST_DURATION_MS,\n  ACCEPT_FROM_WHITELIST_MAX_MESSAGES,\n  ACCEPT_FROM_WHITELIST_THRESHOLD_SCORE,\n  BACKOFF_SLACK\n} from './constants.js'\nimport { decodeRpc, type DecodeRPCLimits, defaultDecodeRpcLimits } from './message/decodeRpc.js'\nimport { RPC, type IRPC } from './message/rpc.js'\nimport { MessageCache, type MessageCacheRecord } from './message-cache.js'\nimport {\n  ChurnReason,\n  getMetrics,\n  IHaveIgnoreReason,\n  InclusionReason,\n  type Metrics,\n  type MetricsRegister,\n  ScorePenalty,\n  type TopicStrToLabel,\n  type ToSendGroupCount\n} from './metrics.js'\nimport {\n  PeerScore,\n  type PeerScoreParams,\n  type PeerScoreThresholds,\n  createPeerScoreParams,\n  createPeerScoreThresholds,\n  type PeerScoreStatsDump\n} from './score/index.js'\nimport { computeAllPeersScoreWeights } from './score/scoreMetrics.js'\nimport { InboundStream, OutboundStream } from './stream.js'\nimport { IWantTracer } from './tracer.js'\nimport {\n  type MsgIdFn,\n  type PublishConfig,\n  type TopicStr,\n  type MsgIdStr,\n  ValidateError,\n  type PeerIdStr,\n  MessageStatus,\n  RejectReason,\n  type RejectReasonObj,\n  type FastMsgIdFn,\n  type AddrInfo,\n  type DataTransform,\n  rejectReasonFromAcceptance,\n  type MsgIdToStrFn,\n  type MessageId,\n  type PublishOpts\n} from './types.js'\nimport { buildRawMessage, validateToRawMessage } from './utils/buildRawMessage.js'\nimport { shuffle, messageIdToString } from './utils/index.js'\nimport { msgIdFnStrictNoSign, msgIdFnStrictSign } from './utils/msgIdFn.js'\nimport { multiaddrToIPStr } from './utils/multiaddr.js'\nimport { getPublishConfigFromPeerId } from './utils/publishConfig.js'\nimport { removeFirstNItemsFromSet, removeItemsFromSet } from './utils/set.js'\nimport { SimpleTimeCache } from './utils/time-cache.js'\nimport type { GossipsubOptsSpec } from './config.js'\nimport type {\n  Connection, Stream, PeerId, Peer, PeerStore,\n  Message,\n  PublishResult,\n  PubSub,\n  PubSubEvents,\n  PubSubInit,\n  SubscriptionChangeData,\n  TopicValidatorFn,\n  Logger,\n  ComponentLogger,\n  Topology\n} from '@libp2p/interface'\nimport type { ConnectionManager, IncomingStreamData, Registrar } from '@libp2p/interface-internal'\nimport type { Multiaddr } from '@multiformats/multiaddr'\nimport type { Uint8ArrayList } from 'uint8arraylist'\n\ntype ConnectionDirection = 'inbound' | 'outbound'\n\ntype ReceivedMessageResult =\n  | { code: MessageStatus.duplicate, msgIdStr: MsgIdStr }\n  | ({ code: MessageStatus.invalid, msgIdStr?: MsgIdStr } & RejectReasonObj)\n  | { code: MessageStatus.valid, messageId: MessageId, msg: Message }\n\nexport const multicodec: string = constants.GossipsubIDv11\n\nexport interface GossipsubOpts extends GossipsubOptsSpec, PubSubInit {\n  /** if dial should fallback to floodsub */\n  fallbackToFloodsub: boolean\n  /** if self-published messages should be sent to all peers */\n  floodPublish: boolean\n  /** serialize message once and send to all peers without control messages */\n  batchPublish: boolean\n  /** whether PX is enabled; this should be enabled in bootstrappers and other well connected/trusted nodes. */\n  doPX: boolean\n  /** peers with which we will maintain direct connections */\n  directPeers: AddrInfo[]\n  /**\n   * If true will not forward messages to mesh peers until reportMessageValidationResult() is called.\n   * Messages will be cached in mcache for some time after which they are evicted. Calling\n   * reportMessageValidationResult() after the message is dropped from mcache won't forward the message.\n   */\n  asyncValidation: boolean\n  /** Do not throw `InsufficientPeers` error if publishing to zero peers */\n  allowPublishToZeroPeers: boolean\n  /** Do not throw `PublishError.Duplicate` if publishing duplicate messages */\n  ignoreDuplicatePublishError: boolean\n  /** For a single stream, await processing each RPC before processing the next */\n  awaitRpcHandler: boolean\n  /** For a single RPC, await processing each message before processing the next */\n  awaitRpcMessageHandler: boolean\n\n  /** message id function */\n  msgIdFn: MsgIdFn\n  /** fast message id function */\n  fastMsgIdFn: FastMsgIdFn\n  /** Uint8Array message id to string function */\n  msgIdToStrFn: MsgIdToStrFn\n  /** override the default MessageCache */\n  messageCache: MessageCache\n  /** peer score parameters */\n  scoreParams: Partial<PeerScoreParams>\n  /** peer score thresholds */\n  scoreThresholds: Partial<PeerScoreThresholds>\n  /** customize GossipsubIWantFollowupTime in order not to apply IWANT penalties */\n  gossipsubIWantFollowupMs: number\n\n  /** override constants for fine tuning */\n  prunePeers?: number\n  pruneBackoff?: number\n  unsubcribeBackoff?: number\n  graftFloodThreshold?: number\n  opportunisticGraftPeers?: number\n  opportunisticGraftTicks?: number\n  directConnectTicks?: number\n\n  dataTransform?: DataTransform\n  metricsRegister?: MetricsRegister | null\n  metricsTopicStrToLabel?: TopicStrToLabel\n\n  // Debug\n  /** Prefix tag for debug logs */\n  debugName?: string\n\n  /**\n   * Specify the maximum number of inbound gossipsub protocol\n   * streams that are allowed to be open concurrently\n   */\n  maxInboundStreams?: number\n\n  /**\n   * Specify the maximum number of outbound gossipsub protocol\n   * streams that are allowed to be open concurrently\n   */\n  maxOutboundStreams?: number\n\n  /**\n   * Pass true to run on transient connections - data or time-limited\n   * connections that may be closed at any time such as circuit relay\n   * connections.\n   *\n   * @default false\n   */\n  runOnTransientConnection?: boolean\n\n  /**\n   * Specify max buffer size in bytes for OutboundStream.\n   * If full it will throw and reject sending any more data.\n   */\n  maxOutboundBufferSize?: number\n\n  /**\n   * Specify max size to skip decoding messages whose data\n   * section exceeds this size.\n   *\n   */\n  maxInboundDataLength?: number\n\n  /**\n   * If provided, only allow topics in this list\n   */\n  allowedTopics?: string[] | Set<string>\n\n  /**\n   * Limits to bound protobuf decoding\n   */\n  decodeRpcLimits?: DecodeRPCLimits\n}\n\nexport interface GossipsubMessage {\n  propagationSource: PeerId\n  msgId: MsgIdStr\n  msg: Message\n}\n\nexport interface GossipsubEvents extends PubSubEvents {\n  'gossipsub:heartbeat': CustomEvent\n  'gossipsub:message': CustomEvent<GossipsubMessage>\n}\n\nenum GossipStatusCode {\n  started,\n  stopped\n}\n\ntype GossipStatus =\n  | {\n    code: GossipStatusCode.started\n    registrarTopologyIds: string[]\n    heartbeatTimeout: ReturnType<typeof setTimeout>\n    hearbeatStartMs: number\n  }\n  | {\n    code: GossipStatusCode.stopped\n  }\n\ninterface GossipOptions extends GossipsubOpts {\n  scoreParams: PeerScoreParams\n  scoreThresholds: PeerScoreThresholds\n}\n\ninterface AcceptFromWhitelistEntry {\n  /** number of messages accepted since recomputing the peer's score */\n  messagesAccepted: number\n  /** have to recompute score after this time */\n  acceptUntil: number\n}\n\nexport interface GossipSubComponents {\n  peerId: PeerId\n  peerStore: PeerStore\n  registrar: Registrar\n  connectionManager: ConnectionManager\n  logger: ComponentLogger\n}\n\nexport class GossipSub extends TypedEventEmitter<GossipsubEvents> implements PubSub<GossipsubEvents> {\n  /**\n   * The signature policy to follow by default\n   */\n  public readonly globalSignaturePolicy: typeof StrictSign | typeof StrictNoSign\n  public multicodecs: string[] = [constants.GossipsubIDv11, constants.GossipsubIDv10]\n\n  private publishConfig: PublishConfig | undefined\n\n  private readonly dataTransform: DataTransform | undefined\n\n  // State\n\n  public readonly peers = new Set<PeerIdStr>()\n  public readonly streamsInbound = new Map<PeerIdStr, InboundStream>()\n  public readonly streamsOutbound = new Map<PeerIdStr, OutboundStream>()\n\n  /** Ensures outbound streams are created sequentially */\n  private outboundInflightQueue = pushable<{ peerId: PeerId, connection: Connection }>({ objectMode: true })\n\n  /** Direct peers */\n  public readonly direct = new Set<PeerIdStr>()\n\n  /** Floodsub peers */\n  private readonly floodsubPeers = new Set<PeerIdStr>()\n\n  /** Cache of seen messages */\n  private readonly seenCache: SimpleTimeCache<void>\n\n  /**\n   * Map of peer id and AcceptRequestWhileListEntry\n   */\n  private readonly acceptFromWhitelist = new Map<PeerIdStr, AcceptFromWhitelistEntry>()\n\n  /**\n   * Map of topics to which peers are subscribed to\n   */\n  private readonly topics = new Map<TopicStr, Set<PeerIdStr>>()\n\n  /**\n   * List of our subscriptions\n   */\n  private readonly subscriptions = new Set<TopicStr>()\n\n  /**\n   * Map of topic meshes\n   * topic => peer id set\n   */\n  public readonly mesh = new Map<TopicStr, Set<PeerIdStr>>()\n\n  /**\n   * Map of topics to set of peers. These mesh peers are the ones to which we are publishing without a topic membership\n   * topic => peer id set\n   */\n  public readonly fanout = new Map<TopicStr, Set<PeerIdStr>>()\n\n  /**\n   * Map of last publish time for fanout topics\n   * topic => last publish time\n   */\n  private readonly fanoutLastpub = new Map<TopicStr, number>()\n\n  /**\n   * Map of pending messages to gossip\n   * peer id => control messages\n   */\n  public readonly gossip = new Map<PeerIdStr, RPC.IControlIHave[]>()\n\n  /**\n   * Map of control messages\n   * peer id => control message\n   */\n  public readonly control = new Map<PeerIdStr, RPC.IControlMessage>()\n\n  /**\n   * Number of IHAVEs received from peer in the last heartbeat\n   */\n  private readonly peerhave = new Map<PeerIdStr, number>()\n\n  /** Number of messages we have asked from peer in the last heartbeat */\n  private readonly iasked = new Map<PeerIdStr, number>()\n\n  /** Prune backoff map */\n  private readonly backoff = new Map<TopicStr, Map<PeerIdStr, number>>()\n\n  /**\n   * Connection direction cache, marks peers with outbound connections\n   * peer id => direction\n   */\n  private readonly outbound = new Map<PeerIdStr, boolean>()\n  private readonly msgIdFn: MsgIdFn\n\n  /**\n   * A fast message id function used for internal message de-duplication\n   */\n  private readonly fastMsgIdFn: FastMsgIdFn | undefined\n\n  private readonly msgIdToStrFn: MsgIdToStrFn\n\n  /** Maps fast message-id to canonical message-id */\n  private readonly fastMsgIdCache: SimpleTimeCache<MsgIdStr> | undefined\n\n  /**\n   * Short term cache for published message ids. This is used for penalizing peers sending\n   * our own messages back if the messages are anonymous or use a random author.\n   */\n  private readonly publishedMessageIds: SimpleTimeCache<void>\n\n  /**\n   * A message cache that contains the messages for last few heartbeat ticks\n   */\n  private readonly mcache: MessageCache\n\n  /** Peer score tracking */\n  public readonly score: PeerScore\n\n  /**\n   * Custom validator function per topic.\n   * Must return or resolve quickly (< 100ms) to prevent causing penalties for late messages.\n   * If you need to apply validation that may require longer times use `asyncValidation` option and callback the\n   * validation result through `Gossipsub.reportValidationResult`\n   */\n  public readonly topicValidators = new Map<TopicStr, TopicValidatorFn>()\n\n  /**\n   * Make this protected so child class may want to redirect to its own log.\n   */\n  protected readonly log: Logger\n\n  /**\n   * Number of heartbeats since the beginning of time\n   * This allows us to amortize some resource cleanup -- eg: backoff cleanup\n   */\n  private heartbeatTicks = 0\n\n  /**\n   * Tracks IHAVE/IWANT promises broken by peers\n   */\n  readonly gossipTracer: IWantTracer\n\n  private readonly components: GossipSubComponents\n\n  private directPeerInitial: ReturnType<typeof setTimeout> | null = null\n\n  public static multicodec: string = constants.GossipsubIDv11\n\n  // Options\n  readonly opts: Required<GossipOptions>\n  private readonly decodeRpcLimits: DecodeRPCLimits\n\n  private readonly metrics: Metrics | null\n  private status: GossipStatus = { code: GossipStatusCode.stopped }\n  private readonly maxInboundStreams?: number\n  private readonly maxOutboundStreams?: number\n  private readonly runOnTransientConnection?: boolean\n  private readonly allowedTopics: Set<TopicStr> | null\n\n  private heartbeatTimer: {\n    _intervalId: ReturnType<typeof setInterval> | undefined\n    runPeriodically(fn: () => void, period: number): void\n    cancel(): void\n  } | null = null\n\n  constructor (components: GossipSubComponents, options: Partial<GossipsubOpts> = {}) {\n    super()\n\n    const opts = {\n      fallbackToFloodsub: true,\n      floodPublish: true,\n      batchPublish: false,\n      doPX: false,\n      directPeers: [],\n      D: constants.GossipsubD,\n      Dlo: constants.GossipsubDlo,\n      Dhi: constants.GossipsubDhi,\n      Dscore: constants.GossipsubDscore,\n      Dout: constants.GossipsubDout,\n      Dlazy: constants.GossipsubDlazy,\n      heartbeatInterval: constants.GossipsubHeartbeatInterval,\n      fanoutTTL: constants.GossipsubFanoutTTL,\n      mcacheLength: constants.GossipsubHistoryLength,\n      mcacheGossip: constants.GossipsubHistoryGossip,\n      seenTTL: constants.GossipsubSeenTTL,\n      gossipsubIWantFollowupMs: constants.GossipsubIWantFollowupTime,\n      prunePeers: constants.GossipsubPrunePeers,\n      pruneBackoff: constants.GossipsubPruneBackoff,\n      unsubcribeBackoff: constants.GossipsubUnsubscribeBackoff,\n      graftFloodThreshold: constants.GossipsubGraftFloodThreshold,\n      opportunisticGraftPeers: constants.GossipsubOpportunisticGraftPeers,\n      opportunisticGraftTicks: constants.GossipsubOpportunisticGraftTicks,\n      directConnectTicks: constants.GossipsubDirectConnectTicks,\n      ...options,\n      scoreParams: createPeerScoreParams(options.scoreParams),\n      scoreThresholds: createPeerScoreThresholds(options.scoreThresholds)\n    }\n\n    this.components = components\n    this.decodeRpcLimits = opts.decodeRpcLimits ?? defaultDecodeRpcLimits\n\n    this.globalSignaturePolicy = opts.globalSignaturePolicy ?? StrictSign\n\n    // Also wants to get notified of peers connected using floodsub\n    if (opts.fallbackToFloodsub) {\n      this.multicodecs.push(constants.FloodsubID)\n    }\n\n    // From pubsub\n    this.log = components.logger.forComponent(opts.debugName ?? 'libp2p:gossipsub')\n\n    // Gossipsub\n\n    this.opts = opts as Required<GossipOptions>\n    this.direct = new Set(opts.directPeers.map((p) => p.id.toString()))\n    this.seenCache = new SimpleTimeCache<void>({ validityMs: opts.seenTTL })\n    this.publishedMessageIds = new SimpleTimeCache<void>({ validityMs: opts.seenTTL })\n\n    if (options.msgIdFn != null) {\n      // Use custom function\n      this.msgIdFn = options.msgIdFn\n    } else {\n      switch (this.globalSignaturePolicy) {\n        case StrictSign:\n          this.msgIdFn = msgIdFnStrictSign\n          break\n        case StrictNoSign:\n          this.msgIdFn = msgIdFnStrictNoSign\n          break\n        default:\n          throw new Error(`Invalid globalSignaturePolicy: ${this.globalSignaturePolicy}`)\n      }\n    }\n\n    if (options.fastMsgIdFn != null) {\n      this.fastMsgIdFn = options.fastMsgIdFn\n      this.fastMsgIdCache = new SimpleTimeCache<MsgIdStr>({ validityMs: opts.seenTTL })\n    }\n\n    // By default, gossipsub only provide a browser friendly function to convert Uint8Array message id to string.\n    this.msgIdToStrFn = options.msgIdToStrFn ?? messageIdToString\n\n    this.mcache = options.messageCache ?? new MessageCache(opts.mcacheGossip, opts.mcacheLength, this.msgIdToStrFn)\n\n    if (options.dataTransform != null) {\n      this.dataTransform = options.dataTransform\n    }\n\n    if (options.metricsRegister != null) {\n      if (options.metricsTopicStrToLabel == null) {\n        throw Error('Must set metricsTopicStrToLabel with metrics')\n      }\n\n      // in theory, each topic has its own meshMessageDeliveriesWindow param\n      // however in lodestar, we configure it mostly the same so just pick the max of positive ones\n      // (some topics have meshMessageDeliveriesWindow as 0)\n      const maxMeshMessageDeliveriesWindowMs = Math.max(\n        ...Object.values(opts.scoreParams.topics).map((topicParam) => topicParam.meshMessageDeliveriesWindow),\n        constants.DEFAULT_METRIC_MESH_MESSAGE_DELIVERIES_WINDOWS\n      )\n\n      const metrics = getMetrics(options.metricsRegister, options.metricsTopicStrToLabel, {\n        gossipPromiseExpireSec: this.opts.gossipsubIWantFollowupMs / 1000,\n        behaviourPenaltyThreshold: opts.scoreParams.behaviourPenaltyThreshold,\n        maxMeshMessageDeliveriesWindowSec: maxMeshMessageDeliveriesWindowMs / 1000\n      })\n\n      metrics.mcacheSize.addCollect(() => { this.onScrapeMetrics(metrics) })\n      for (const protocol of this.multicodecs) {\n        metrics.protocolsEnabled.set({ protocol }, 1)\n      }\n\n      this.metrics = metrics\n    } else {\n      this.metrics = null\n    }\n\n    this.gossipTracer = new IWantTracer(this.opts.gossipsubIWantFollowupMs, this.msgIdToStrFn, this.metrics)\n\n    /**\n     * libp2p\n     */\n    this.score = new PeerScore(this.opts.scoreParams, this.metrics, this.components.logger, {\n      scoreCacheValidityMs: opts.heartbeatInterval\n    })\n\n    this.maxInboundStreams = options.maxInboundStreams\n    this.maxOutboundStreams = options.maxOutboundStreams\n    this.runOnTransientConnection = options.runOnTransientConnection\n\n    this.allowedTopics = (opts.allowedTopics != null) ? new Set(opts.allowedTopics) : null\n  }\n\n  getPeers (): PeerId[] {\n    return [...this.peers.keys()].map((str) => peerIdFromString(str))\n  }\n\n  isStarted (): boolean {\n    return this.status.code === GossipStatusCode.started\n  }\n\n  // LIFECYCLE METHODS\n\n  /**\n   * Mounts the gossipsub protocol onto the libp2p node and sends our\n   * our subscriptions to every peer connected\n   */\n  async start (): Promise<void> {\n    // From pubsub\n    if (this.isStarted()) {\n      return\n    }\n\n    this.log('starting')\n\n    this.publishConfig = await getPublishConfigFromPeerId(this.globalSignaturePolicy, this.components.peerId)\n\n    // Create the outbound inflight queue\n    // This ensures that outbound stream creation happens sequentially\n    this.outboundInflightQueue = pushable({ objectMode: true })\n    pipe(this.outboundInflightQueue, async (source) => {\n      for await (const { peerId, connection } of source) {\n        await this.createOutboundStream(peerId, connection)\n      }\n    }).catch((e) => { this.log.error('outbound inflight queue error', e) })\n\n    // set direct peer addresses in the address book\n    await Promise.all(\n      this.opts.directPeers.map(async (p) => {\n        await this.components.peerStore.merge(p.id, {\n          multiaddrs: p.addrs\n        })\n      })\n    )\n\n    const registrar = this.components.registrar\n    // Incoming streams\n    // Called after a peer dials us\n    await Promise.all(\n      this.multicodecs.map(async (multicodec) =>\n        registrar.handle(multicodec, this.onIncomingStream.bind(this), {\n          maxInboundStreams: this.maxInboundStreams,\n          maxOutboundStreams: this.maxOutboundStreams,\n          runOnTransientConnection: this.runOnTransientConnection\n        })\n      )\n    )\n\n    // # How does Gossipsub interact with libp2p? Rough guide from Mar 2022\n    //\n    // ## Setup:\n    // Gossipsub requests libp2p to callback, TBD\n    //\n    // `this.libp2p.handle()` registers a handler for `/meshsub/1.1.0` and other Gossipsub protocols\n    // The handler callback is registered in libp2p Upgrader.protocols map.\n    //\n    // Upgrader receives an inbound connection from some transport and (`Upgrader.upgradeInbound`):\n    // - Adds encryption (NOISE in our case)\n    // - Multiplex stream\n    // - Create a muxer and register that for each new stream call Upgrader.protocols handler\n    //\n    // ## Topology\n    // - new instance of Topology (unlinked to libp2p) with handlers\n    // - registar.register(topology)\n\n    // register protocol with topology\n    // Topology callbacks called on connection manager changes\n    const topology: Topology = {\n      onConnect: this.onPeerConnected.bind(this),\n      onDisconnect: this.onPeerDisconnected.bind(this),\n      notifyOnTransient: this.runOnTransientConnection\n    }\n    const registrarTopologyIds = await Promise.all(\n      this.multicodecs.map(async (multicodec) => registrar.register(multicodec, topology))\n    )\n\n    // Schedule to start heartbeat after `GossipsubHeartbeatInitialDelay`\n    const heartbeatTimeout = setTimeout(this.runHeartbeat, constants.GossipsubHeartbeatInitialDelay)\n    // Then, run heartbeat every `heartbeatInterval` offset by `GossipsubHeartbeatInitialDelay`\n\n    this.status = {\n      code: GossipStatusCode.started,\n      registrarTopologyIds,\n      heartbeatTimeout,\n      hearbeatStartMs: Date.now() + constants.GossipsubHeartbeatInitialDelay\n    }\n\n    this.score.start()\n    // connect to direct peers\n    this.directPeerInitial = setTimeout(() => {\n      Promise.resolve()\n        .then(async () => {\n          await Promise.all(Array.from(this.direct).map(async (id) => this.connect(id)))\n        })\n        .catch((err) => {\n          this.log(err)\n        })\n    }, constants.GossipsubDirectConnectInitialDelay)\n\n    this.log('started')\n  }\n\n  /**\n   * Unmounts the gossipsub protocol and shuts down every connection\n   */\n  async stop (): Promise<void> {\n    this.log('stopping')\n    // From pubsub\n\n    if (this.status.code !== GossipStatusCode.started) {\n      return\n    }\n\n    const { registrarTopologyIds } = this.status\n    this.status = { code: GossipStatusCode.stopped }\n\n    // unregister protocol and handlers\n    const registrar = this.components.registrar\n    await Promise.all(this.multicodecs.map(async (multicodec) => registrar.unhandle(multicodec)))\n    registrarTopologyIds.forEach((id) => { registrar.unregister(id) })\n\n    this.outboundInflightQueue.end()\n\n    const closePromises = []\n    for (const outboundStream of this.streamsOutbound.values()) {\n      closePromises.push(outboundStream.close())\n    }\n    this.streamsOutbound.clear()\n\n    for (const inboundStream of this.streamsInbound.values()) {\n      closePromises.push(inboundStream.close())\n    }\n    this.streamsInbound.clear()\n\n    await Promise.all(closePromises)\n\n    this.peers.clear()\n    this.subscriptions.clear()\n\n    // Gossipsub\n\n    if (this.heartbeatTimer != null) {\n      this.heartbeatTimer.cancel()\n      this.heartbeatTimer = null\n    }\n\n    this.score.stop()\n\n    this.mesh.clear()\n    this.fanout.clear()\n    this.fanoutLastpub.clear()\n    this.gossip.clear()\n    this.control.clear()\n    this.peerhave.clear()\n    this.iasked.clear()\n    this.backoff.clear()\n    this.outbound.clear()\n    this.gossipTracer.clear()\n    this.seenCache.clear()\n    if (this.fastMsgIdCache != null) this.fastMsgIdCache.clear()\n    if (this.directPeerInitial != null) clearTimeout(this.directPeerInitial)\n\n    this.log('stopped')\n  }\n\n  /** FOR DEBUG ONLY - Dump peer stats for all peers. Data is cloned, safe to mutate */\n  dumpPeerScoreStats (): PeerScoreStatsDump {\n    return this.score.dumpPeerScoreStats()\n  }\n\n  /**\n   * On an inbound stream opened\n   */\n  private onIncomingStream ({ stream, connection }: IncomingStreamData): void {\n    if (!this.isStarted()) {\n      return\n    }\n\n    const peerId = connection.remotePeer\n    // add peer to router\n    this.addPeer(peerId, connection.direction, connection.remoteAddr)\n    // create inbound stream\n    this.createInboundStream(peerId, stream)\n    // attempt to create outbound stream\n    this.outboundInflightQueue.push({ peerId, connection })\n  }\n\n  /**\n   * Registrar notifies an established connection with pubsub protocol\n   */\n  private onPeerConnected (peerId: PeerId, connection: Connection): void {\n    this.metrics?.newConnectionCount.inc({ status: connection.status })\n    // libp2p may emit a closed connection and never issue peer:disconnect event\n    // see https://github.com/ChainSafe/js-libp2p-gossipsub/issues/398\n    if (!this.isStarted() || connection.status !== 'open') {\n      return\n    }\n\n    this.addPeer(peerId, connection.direction, connection.remoteAddr)\n    this.outboundInflightQueue.push({ peerId, connection })\n  }\n\n  /**\n   * Registrar notifies a closing connection with pubsub protocol\n   */\n  private onPeerDisconnected (peerId: PeerId): void {\n    this.log('connection ended %p', peerId)\n    this.removePeer(peerId)\n  }\n\n  private async createOutboundStream (peerId: PeerId, connection: Connection): Promise<void> {\n    if (!this.isStarted()) {\n      return\n    }\n\n    const id = peerId.toString()\n\n    if (!this.peers.has(id)) {\n      return\n    }\n\n    // TODO make this behavior more robust\n    // This behavior is different than for inbound streams\n    // If an outbound stream already exists, don't create a new stream\n    if (this.streamsOutbound.has(id)) {\n      return\n    }\n\n    try {\n      const stream = new OutboundStream(\n        await connection.newStream(this.multicodecs, {\n          runOnTransientConnection: this.runOnTransientConnection\n        }),\n        (e) => { this.log.error('outbound pipe error', e) },\n        { maxBufferSize: this.opts.maxOutboundBufferSize }\n      )\n\n      this.log('create outbound stream %p', peerId)\n\n      this.streamsOutbound.set(id, stream)\n\n      const protocol = stream.protocol\n      if (protocol === constants.FloodsubID) {\n        this.floodsubPeers.add(id)\n      }\n      this.metrics?.peersPerProtocol.inc({ protocol }, 1)\n\n      // Immediately send own subscriptions via the newly attached stream\n      if (this.subscriptions.size > 0) {\n        this.log('send subscriptions to', id)\n        this.sendSubscriptions(id, Array.from(this.subscriptions), true)\n      }\n    } catch (e) {\n      this.log.error('createOutboundStream error', e)\n    }\n  }\n\n  private createInboundStream (peerId: PeerId, stream: Stream): void {\n    if (!this.isStarted()) {\n      return\n    }\n\n    const id = peerId.toString()\n\n    if (!this.peers.has(id)) {\n      return\n    }\n\n    // TODO make this behavior more robust\n    // This behavior is different than for outbound streams\n    // If a peer initiates a new inbound connection\n    // we assume that one is the new canonical inbound stream\n    const priorInboundStream = this.streamsInbound.get(id)\n    if (priorInboundStream !== undefined) {\n      this.log('replacing existing inbound steam %s', id)\n      priorInboundStream.close().catch((err) => { this.log.error(err) })\n    }\n\n    this.log('create inbound stream %s', id)\n\n    const inboundStream = new InboundStream(stream, { maxDataLength: this.opts.maxInboundDataLength })\n    this.streamsInbound.set(id, inboundStream)\n\n    this.pipePeerReadStream(peerId, inboundStream.source).catch((err) => { this.log(err) })\n  }\n\n  /**\n   * Add a peer to the router\n   */\n  private addPeer (peerId: PeerId, direction: ConnectionDirection, addr: Multiaddr): void {\n    const id = peerId.toString()\n\n    if (!this.peers.has(id)) {\n      this.log('new peer %p', peerId)\n\n      this.peers.add(id)\n\n      // Add to peer scoring\n      this.score.addPeer(id)\n      const currentIP = multiaddrToIPStr(addr)\n      if (currentIP !== null) {\n        this.score.addIP(id, currentIP)\n      } else {\n        this.log('Added peer has no IP in current address %s %s', id, addr.toString())\n      }\n\n      // track the connection direction. Don't allow to unset outbound\n      if (!this.outbound.has(id)) {\n        this.outbound.set(id, direction === 'outbound')\n      }\n    }\n  }\n\n  /**\n   * Removes a peer from the router\n   */\n  private removePeer (peerId: PeerId): void {\n    const id = peerId.toString()\n\n    if (!this.peers.has(id)) {\n      return\n    }\n\n    // delete peer\n    this.log('delete peer %p', peerId)\n    this.peers.delete(id)\n\n    const outboundStream = this.streamsOutbound.get(id)\n    const inboundStream = this.streamsInbound.get(id)\n\n    if (outboundStream != null) {\n      this.metrics?.peersPerProtocol.inc({ protocol: outboundStream.protocol }, -1)\n    }\n\n    // close streams\n    outboundStream?.close().catch((err) => { this.log.error(err) })\n    inboundStream?.close().catch((err) => { this.log.error(err) })\n\n    // remove streams\n    this.streamsOutbound.delete(id)\n    this.streamsInbound.delete(id)\n\n    // remove peer from topics map\n    for (const peers of this.topics.values()) {\n      peers.delete(id)\n    }\n\n    // Remove this peer from the mesh\n    for (const [topicStr, peers] of this.mesh) {\n      if (peers.delete(id)) {\n        this.metrics?.onRemoveFromMesh(topicStr, ChurnReason.Dc, 1)\n      }\n    }\n\n    // Remove this peer from the fanout\n    for (const peers of this.fanout.values()) {\n      peers.delete(id)\n    }\n\n    // Remove from floodsubPeers\n    this.floodsubPeers.delete(id)\n    // Remove from gossip mapping\n    this.gossip.delete(id)\n    // Remove from control mapping\n    this.control.delete(id)\n    // Remove from backoff mapping\n    this.outbound.delete(id)\n\n    // Remove from peer scoring\n    this.score.removePeer(id)\n\n    this.acceptFromWhitelist.delete(id)\n  }\n\n  // API METHODS\n\n  get started (): boolean {\n    return this.status.code === GossipStatusCode.started\n  }\n\n  /**\n   * Get a the peer-ids in a topic mesh\n   */\n  getMeshPeers (topic: TopicStr): PeerIdStr[] {\n    const peersInTopic = this.mesh.get(topic)\n    return (peersInTopic != null) ? Array.from(peersInTopic) : []\n  }\n\n  /**\n   * Get a list of the peer-ids that are subscribed to one topic.\n   */\n  getSubscribers (topic: TopicStr): PeerId[] {\n    const peersInTopic = this.topics.get(topic)\n    return ((peersInTopic != null) ? Array.from(peersInTopic) : []).map((str) => peerIdFromString(str))\n  }\n\n  /**\n   * Get the list of topics which the peer is subscribed to.\n   */\n  getTopics (): TopicStr[] {\n    return Array.from(this.subscriptions)\n  }\n\n  // TODO: Reviewing Pubsub API\n\n  // MESSAGE METHODS\n\n  /**\n   * Responsible for processing each RPC message received by other peers.\n   */\n  private async pipePeerReadStream (peerId: PeerId, stream: AsyncIterable<Uint8ArrayList>): Promise<void> {\n    try {\n      await pipe(stream, async (source) => {\n        for await (const data of source) {\n          try {\n            // TODO: Check max gossip message size, before decodeRpc()\n            const rpcBytes = data.subarray()\n            // Note: This function may throw, it must be wrapped in a try {} catch {} to prevent closing the stream.\n            // TODO: What should we do if the entire RPC is invalid?\n            const rpc = decodeRpc(rpcBytes, this.decodeRpcLimits)\n\n            this.metrics?.onRpcRecv(rpc, rpcBytes.length)\n\n            // Since processRpc may be overridden entirely in unsafe ways,\n            // the simplest/safest option here is to wrap in a function and capture all errors\n            // to prevent a top-level unhandled exception\n            // This processing of rpc messages should happen without awaiting full validation/execution of prior messages\n            if (this.opts.awaitRpcHandler) {\n              try {\n                await this.handleReceivedRpc(peerId, rpc)\n              } catch (err) {\n                this.metrics?.onRpcRecvError()\n                this.log(err)\n              }\n            } else {\n              this.handleReceivedRpc(peerId, rpc).catch((err) => {\n                this.metrics?.onRpcRecvError()\n                this.log(err)\n              })\n            }\n          } catch (e) {\n            this.metrics?.onRpcDataError()\n            this.log(e as Error)\n          }\n        }\n      })\n    } catch (err) {\n      this.metrics?.onPeerReadStreamError()\n      this.handlePeerReadStreamError(err as Error, peerId)\n    }\n  }\n\n  /**\n   * Handle error when read stream pipe throws, less of the functional use but more\n   * to for testing purposes to spy on the error handling\n   * */\n  private handlePeerReadStreamError (err: Error, peerId: PeerId): void {\n    this.log.error(err)\n    this.onPeerDisconnected(peerId)\n  }\n\n  /**\n   * Handles an rpc request from a peer\n   */\n  public async handleReceivedRpc (from: PeerId, rpc: IRPC): Promise<void> {\n    // Check if peer is graylisted in which case we ignore the event\n    if (!this.acceptFrom(from.toString())) {\n      this.log('received message from unacceptable peer %p', from)\n      this.metrics?.rpcRecvNotAccepted.inc()\n      return\n    }\n\n    const subscriptions = (rpc.subscriptions != null) ? rpc.subscriptions.length : 0\n    const messages = (rpc.messages != null) ? rpc.messages.length : 0\n    let ihave = 0\n    let iwant = 0\n    let graft = 0\n    let prune = 0\n    if (rpc.control != null) {\n      if (rpc.control.ihave != null) ihave = rpc.control.ihave.length\n      if (rpc.control.iwant != null) iwant = rpc.control.iwant.length\n      if (rpc.control.graft != null) graft = rpc.control.graft.length\n      if (rpc.control.prune != null) prune = rpc.control.prune.length\n    }\n    this.log(\n      `rpc.from ${from.toString()} subscriptions ${subscriptions} messages ${messages} ihave ${ihave} iwant ${iwant} graft ${graft} prune ${prune}`\n    )\n\n    // Handle received subscriptions\n    if ((rpc.subscriptions != null) && rpc.subscriptions.length > 0) {\n      // update peer subscriptions\n\n      const subscriptions: Array<{ topic: TopicStr, subscribe: boolean }> = []\n\n      rpc.subscriptions.forEach((subOpt) => {\n        const topic = subOpt.topic\n        const subscribe = subOpt.subscribe === true\n\n        if (topic != null) {\n          if ((this.allowedTopics != null) && !this.allowedTopics.has(topic)) {\n            // Not allowed: subscription data-structures are not bounded by topic count\n            // TODO: Should apply behaviour penalties?\n            return\n          }\n\n          this.handleReceivedSubscription(from, topic, subscribe)\n\n          subscriptions.push({ topic, subscribe })\n        }\n      })\n\n      this.safeDispatchEvent<SubscriptionChangeData>('subscription-change', {\n        detail: { peerId: from, subscriptions }\n      })\n    }\n\n    // Handle messages\n    // TODO: (up to limit)\n    if (rpc.messages != null) {\n      for (const message of rpc.messages) {\n        if ((this.allowedTopics != null) && !this.allowedTopics.has(message.topic)) {\n          // Not allowed: message cache data-structures are not bounded by topic count\n          // TODO: Should apply behaviour penalties?\n          continue\n        }\n\n        const handleReceivedMessagePromise = this.handleReceivedMessage(from, message)\n          // Should never throw, but handle just in case\n          .catch((err) => {\n            this.metrics?.onMsgRecvError(message.topic)\n            this.log(err)\n          })\n\n        if (this.opts.awaitRpcMessageHandler) {\n          await handleReceivedMessagePromise\n        }\n      }\n    }\n\n    // Handle control messages\n    if (rpc.control != null) {\n      await this.handleControlMessage(from.toString(), rpc.control)\n    }\n  }\n\n  /**\n   * Handles a subscription change from a peer\n   */\n  private handleReceivedSubscription (from: PeerId, topic: TopicStr, subscribe: boolean): void {\n    this.log('subscription update from %p topic %s', from, topic)\n\n    let topicSet = this.topics.get(topic)\n    if (topicSet == null) {\n      topicSet = new Set()\n      this.topics.set(topic, topicSet)\n    }\n\n    if (subscribe) {\n      // subscribe peer to new topic\n      topicSet.add(from.toString())\n    } else {\n      // unsubscribe from existing topic\n      topicSet.delete(from.toString())\n    }\n\n    // TODO: rust-libp2p has A LOT more logic here\n  }\n\n  /**\n   * Handles a newly received message from an RPC.\n   * May forward to all peers in the mesh.\n   */\n  private async handleReceivedMessage (from: PeerId, rpcMsg: RPC.IMessage): Promise<void> {\n    this.metrics?.onMsgRecvPreValidation(rpcMsg.topic)\n\n    const validationResult = await this.validateReceivedMessage(from, rpcMsg)\n\n    this.metrics?.onPrevalidationResult(rpcMsg.topic, validationResult.code)\n\n    const validationCode = validationResult.code\n    switch (validationCode) {\n      case MessageStatus.duplicate:\n        // Report the duplicate\n        this.score.duplicateMessage(from.toString(), validationResult.msgIdStr, rpcMsg.topic)\n        // due to the collision of fastMsgIdFn, 2 different messages may end up the same fastMsgId\n        // so we need to also mark the duplicate message as delivered or the promise is not resolved\n        // and peer gets penalized. See https://github.com/ChainSafe/js-libp2p-gossipsub/pull/385\n        this.gossipTracer.deliverMessage(validationResult.msgIdStr, true)\n        this.mcache.observeDuplicate(validationResult.msgIdStr, from.toString())\n        return\n\n      case MessageStatus.invalid:\n        // invalid messages received\n        // metrics.register_invalid_message(&raw_message.topic)\n        // Tell peer_score about reject\n        // Reject the original source, and any duplicates we've seen from other peers.\n        if (validationResult.msgIdStr != null) {\n          const msgIdStr = validationResult.msgIdStr\n          this.score.rejectMessage(from.toString(), msgIdStr, rpcMsg.topic, validationResult.reason)\n          this.gossipTracer.rejectMessage(msgIdStr, validationResult.reason)\n        } else {\n          this.score.rejectInvalidMessage(from.toString(), rpcMsg.topic)\n        }\n\n        this.metrics?.onMsgRecvInvalid(rpcMsg.topic, validationResult)\n        return\n\n      case MessageStatus.valid:\n        // Tells score that message arrived (but is maybe not fully validated yet).\n        // Consider the message as delivered for gossip promises.\n        this.score.validateMessage(validationResult.messageId.msgIdStr)\n        this.gossipTracer.deliverMessage(validationResult.messageId.msgIdStr)\n\n        // Add the message to our memcache\n        // if no validation is required, mark the message as validated\n        this.mcache.put(validationResult.messageId, rpcMsg, !this.opts.asyncValidation)\n\n        // Dispatch the message to the user if we are subscribed to the topic\n        if (this.subscriptions.has(rpcMsg.topic)) {\n          const isFromSelf = this.components.peerId.equals(from)\n\n          if (!isFromSelf || this.opts.emitSelf) {\n            super.dispatchEvent(\n              new CustomEvent<GossipsubMessage>('gossipsub:message', {\n                detail: {\n                  propagationSource: from,\n                  msgId: validationResult.messageId.msgIdStr,\n                  msg: validationResult.msg\n                }\n              })\n            )\n            // TODO: Add option to switch between emit per topic or all messages in one\n            super.dispatchEvent(new CustomEvent<Message>('message', { detail: validationResult.msg }))\n          }\n        }\n\n        // Forward the message to mesh peers, if no validation is required\n        // If asyncValidation is ON, expect the app layer to call reportMessageValidationResult(), then forward\n        if (!this.opts.asyncValidation) {\n          // TODO: in rust-libp2p\n          // .forward_msg(&msg_id, raw_message, Some(propagation_source))\n          this.forwardMessage(validationResult.messageId.msgIdStr, rpcMsg, from.toString())\n        }\n        break\n      default:\n        throw new Error(`Invalid validation result: ${validationCode}`)\n    }\n  }\n\n  /**\n   * Handles a newly received message from an RPC.\n   * May forward to all peers in the mesh.\n   */\n  private async validateReceivedMessage (\n    propagationSource: PeerId,\n    rpcMsg: RPC.IMessage\n  ): Promise<ReceivedMessageResult> {\n    // Fast message ID stuff\n    const fastMsgIdStr = this.fastMsgIdFn?.(rpcMsg)\n    const msgIdCached = fastMsgIdStr !== undefined ? this.fastMsgIdCache?.get(fastMsgIdStr) : undefined\n\n    if (msgIdCached != null) {\n      // This message has been seen previously. Ignore it\n      return { code: MessageStatus.duplicate, msgIdStr: msgIdCached }\n    }\n\n    // Perform basic validation on message and convert to RawGossipsubMessage for fastMsgIdFn()\n    const validationResult = await validateToRawMessage(this.globalSignaturePolicy, rpcMsg)\n\n    if (!validationResult.valid) {\n      return { code: MessageStatus.invalid, reason: RejectReason.Error, error: validationResult.error }\n    }\n\n    const msg = validationResult.message\n\n    // Try and perform the data transform to the message. If it fails, consider it invalid.\n    try {\n      if (this.dataTransform != null) {\n        msg.data = this.dataTransform.inboundTransform(rpcMsg.topic, msg.data)\n      }\n    } catch (e) {\n      this.log('Invalid message, transform failed', e)\n      return { code: MessageStatus.invalid, reason: RejectReason.Error, error: ValidateError.TransformFailed }\n    }\n\n    // TODO: Check if message is from a blacklisted source or propagation origin\n    // - Reject any message from a blacklisted peer\n    // - Also reject any message that originated from a blacklisted peer\n    // - reject messages claiming to be from ourselves but not locally published\n\n    // Calculate the message id on the transformed data.\n    const msgId = await this.msgIdFn(msg)\n    const msgIdStr = this.msgIdToStrFn(msgId)\n    const messageId = { msgId, msgIdStr }\n\n    // Add the message to the duplicate caches\n    if (fastMsgIdStr !== undefined && (this.fastMsgIdCache != null)) {\n      const collision = this.fastMsgIdCache.put(fastMsgIdStr, msgIdStr)\n      if (collision) {\n        this.metrics?.fastMsgIdCacheCollision.inc()\n      }\n    }\n\n    if (this.seenCache.has(msgIdStr)) {\n      return { code: MessageStatus.duplicate, msgIdStr }\n    } else {\n      this.seenCache.put(msgIdStr)\n    }\n\n    // (Optional) Provide custom validation here with dynamic validators per topic\n    // NOTE: This custom topicValidator() must resolve fast (< 100ms) to allow scores\n    // to not penalize peers for long validation times.\n    const topicValidator = this.topicValidators.get(rpcMsg.topic)\n    if (topicValidator != null) {\n      let acceptance: TopicValidatorResult\n      // Use try {} catch {} in case topicValidator() is synchronous\n      try {\n        acceptance = await topicValidator(propagationSource, msg)\n      } catch (e) {\n        const errCode = (e as { code: string }).code\n        if (errCode === constants.ERR_TOPIC_VALIDATOR_IGNORE) acceptance = TopicValidatorResult.Ignore\n        if (errCode === constants.ERR_TOPIC_VALIDATOR_REJECT) acceptance = TopicValidatorResult.Reject\n        else acceptance = TopicValidatorResult.Ignore\n      }\n\n      if (acceptance !== TopicValidatorResult.Accept) {\n        return { code: MessageStatus.invalid, reason: rejectReasonFromAcceptance(acceptance), msgIdStr }\n      }\n    }\n\n    return { code: MessageStatus.valid, messageId, msg }\n  }\n\n  /**\n   * Return score of a peer.\n   */\n  getScore (peerId: PeerIdStr): number {\n    return this.score.score(peerId)\n  }\n\n  /**\n   * Send an rpc object to a peer with subscriptions\n   */\n  private sendSubscriptions (toPeer: PeerIdStr, topics: string[], subscribe: boolean): void {\n    this.sendRpc(toPeer, {\n      subscriptions: topics.map((topic) => ({ topic, subscribe }))\n    })\n  }\n\n  /**\n   * Handles an rpc control message from a peer\n   */\n  private async handleControlMessage (id: PeerIdStr, controlMsg: RPC.IControlMessage): Promise<void> {\n    if (controlMsg === undefined) {\n      return\n    }\n\n    const iwant = (controlMsg.ihave != null) ? this.handleIHave(id, controlMsg.ihave) : []\n    const ihave = (controlMsg.iwant != null) ? this.handleIWant(id, controlMsg.iwant) : []\n    const prune = (controlMsg.graft != null) ? await this.handleGraft(id, controlMsg.graft) : []\n    ;(controlMsg.prune != null) && (await this.handlePrune(id, controlMsg.prune))\n\n    if ((iwant.length === 0) && (ihave.length === 0) && (prune.length === 0)) {\n      return\n    }\n\n    const sent = this.sendRpc(id, { messages: ihave, control: { iwant, prune } })\n    const iwantMessageIds = iwant[0]?.messageIDs\n    if (iwantMessageIds != null) {\n      if (sent) {\n        this.gossipTracer.addPromise(id, iwantMessageIds)\n      } else {\n        this.metrics?.iwantPromiseUntracked.inc(1)\n      }\n    }\n  }\n\n  /**\n   * Whether to accept a message from a peer\n   */\n  public acceptFrom (id: PeerIdStr): boolean {\n    if (this.direct.has(id)) {\n      return true\n    }\n\n    const now = Date.now()\n    const entry = this.acceptFromWhitelist.get(id)\n\n    if ((entry != null) && entry.messagesAccepted < ACCEPT_FROM_WHITELIST_MAX_MESSAGES && entry.acceptUntil >= now) {\n      entry.messagesAccepted += 1\n      return true\n    }\n\n    const score = this.score.score(id)\n    if (score >= ACCEPT_FROM_WHITELIST_THRESHOLD_SCORE) {\n      // peer is unlikely to be able to drop its score to `graylistThreshold`\n      // after 128 messages or 1s\n      this.acceptFromWhitelist.set(id, {\n        messagesAccepted: 0,\n        acceptUntil: now + ACCEPT_FROM_WHITELIST_DURATION_MS\n      })\n    } else {\n      this.acceptFromWhitelist.delete(id)\n    }\n\n    return score >= this.opts.scoreThresholds.graylistThreshold\n  }\n\n  /**\n   * Handles IHAVE messages\n   */\n  private handleIHave (id: PeerIdStr, ihave: RPC.IControlIHave[]): RPC.IControlIWant[] {\n    if (ihave.length === 0) {\n      return []\n    }\n\n    // we ignore IHAVE gossip from any peer whose score is below the gossips threshold\n    const score = this.score.score(id)\n    if (score < this.opts.scoreThresholds.gossipThreshold) {\n      this.log('IHAVE: ignoring peer %s with score below threshold [ score = %d ]', id, score)\n      this.metrics?.ihaveRcvIgnored.inc({ reason: IHaveIgnoreReason.LowScore })\n      return []\n    }\n\n    // IHAVE flood protection\n    const peerhave = (this.peerhave.get(id) ?? 0) + 1\n    this.peerhave.set(id, peerhave)\n    if (peerhave > constants.GossipsubMaxIHaveMessages) {\n      this.log(\n        'IHAVE: peer %s has advertised too many times (%d) within this heartbeat interval; ignoring',\n        id,\n        peerhave\n      )\n      this.metrics?.ihaveRcvIgnored.inc({ reason: IHaveIgnoreReason.MaxIhave })\n      return []\n    }\n\n    const iasked = this.iasked.get(id) ?? 0\n    if (iasked >= constants.GossipsubMaxIHaveLength) {\n      this.log('IHAVE: peer %s has already advertised too many messages (%d); ignoring', id, iasked)\n      this.metrics?.ihaveRcvIgnored.inc({ reason: IHaveIgnoreReason.MaxIasked })\n      return []\n    }\n\n    // string msgId => msgId\n    const iwant = new Map<MsgIdStr, Uint8Array>()\n\n    ihave.forEach(({ topicID, messageIDs }) => {\n      if (topicID == null || (messageIDs == null) || !this.mesh.has(topicID)) {\n        return\n      }\n\n      let idonthave = 0\n\n      messageIDs.forEach((msgId) => {\n        const msgIdStr = this.msgIdToStrFn(msgId)\n        if (!this.seenCache.has(msgIdStr)) {\n          iwant.set(msgIdStr, msgId)\n          idonthave++\n        }\n      })\n\n      this.metrics?.onIhaveRcv(topicID, messageIDs.length, idonthave)\n    })\n\n    if (iwant.size === 0) {\n      return []\n    }\n\n    let iask = iwant.size\n    if (iask + iasked > constants.GossipsubMaxIHaveLength) {\n      iask = constants.GossipsubMaxIHaveLength - iasked\n    }\n\n    this.log('IHAVE: Asking for %d out of %d messages from %s', iask, iwant.size, id)\n\n    let iwantList = Array.from(iwant.values())\n    // ask in random order\n    shuffle(iwantList)\n\n    // truncate to the messages we are actually asking for and update the iasked counter\n    iwantList = iwantList.slice(0, iask)\n    this.iasked.set(id, iasked + iask)\n\n    // do not add gossipTracer promise here until a successful sendRpc()\n\n    return [\n      {\n        messageIDs: iwantList\n      }\n    ]\n  }\n\n  /**\n   * Handles IWANT messages\n   * Returns messages to send back to peer\n   */\n  private handleIWant (id: PeerIdStr, iwant: RPC.IControlIWant[]): RPC.IMessage[] {\n    if (iwant.length === 0) {\n      return []\n    }\n\n    // we don't respond to IWANT requests from any per whose score is below the gossip threshold\n    const score = this.score.score(id)\n    if (score < this.opts.scoreThresholds.gossipThreshold) {\n      this.log('IWANT: ignoring peer %s with score below threshold [score = %d]', id, score)\n      return []\n    }\n\n    const ihave = new Map<MsgIdStr, RPC.IMessage>()\n    const iwantByTopic = new Map<TopicStr, number>()\n    let iwantDonthave = 0\n\n    iwant.forEach(({ messageIDs }) => {\n      messageIDs?.forEach((msgId) => {\n        const msgIdStr = this.msgIdToStrFn(msgId)\n        const entry = this.mcache.getWithIWantCount(msgIdStr, id)\n        if (entry == null) {\n          iwantDonthave++\n          return\n        }\n\n        iwantByTopic.set(entry.msg.topic, 1 + (iwantByTopic.get(entry.msg.topic) ?? 0))\n\n        if (entry.count > constants.GossipsubGossipRetransmission) {\n          this.log('IWANT: Peer %s has asked for message %s too many times: ignoring request', id, msgId)\n          return\n        }\n\n        ihave.set(msgIdStr, entry.msg)\n      })\n    })\n\n    this.metrics?.onIwantRcv(iwantByTopic, iwantDonthave)\n\n    if (ihave.size === 0) {\n      this.log('IWANT: Could not provide any wanted messages to %s', id)\n      return []\n    }\n\n    this.log('IWANT: Sending %d messages to %s', ihave.size, id)\n\n    return Array.from(ihave.values())\n  }\n\n  /**\n   * Handles Graft messages\n   */\n  private async handleGraft (id: PeerIdStr, graft: RPC.IControlGraft[]): Promise<RPC.IControlPrune[]> {\n    const prune: TopicStr[] = []\n    const score = this.score.score(id)\n    const now = Date.now()\n    let doPX = this.opts.doPX\n\n    graft.forEach(({ topicID }) => {\n      if (topicID == null) {\n        return\n      }\n      const peersInMesh = this.mesh.get(topicID)\n      if (peersInMesh == null) {\n        // don't do PX when there is an unknown topic to avoid leaking our peers\n        doPX = false\n        // spam hardening: ignore GRAFTs for unknown topics\n        return\n      }\n\n      // check if peer is already in the mesh; if so do nothing\n      if (peersInMesh.has(id)) {\n        return\n      }\n\n      // we don't GRAFT to/from direct peers; complain loudly if this happens\n      if (this.direct.has(id)) {\n        this.log('GRAFT: ignoring request from direct peer %s', id)\n        // this is possibly a bug from a non-reciprical configuration; send a PRUNE\n        prune.push(topicID)\n        // but don't px\n        doPX = false\n        return\n      }\n\n      // make sure we are not backing off that peer\n      const expire = this.backoff.get(topicID)?.get(id)\n      if (typeof expire === 'number' && now < expire) {\n        this.log('GRAFT: ignoring backed off peer %s', id)\n        // add behavioral penalty\n        this.score.addPenalty(id, 1, ScorePenalty.GraftBackoff)\n        // no PX\n        doPX = false\n        // check the flood cutoff -- is the GRAFT coming too fast?\n        const floodCutoff = expire + this.opts.graftFloodThreshold - this.opts.pruneBackoff\n        if (now < floodCutoff) {\n          // extra penalty\n          this.score.addPenalty(id, 1, ScorePenalty.GraftBackoff)\n        }\n        // refresh the backoff\n        this.addBackoff(id, topicID)\n        prune.push(topicID)\n        return\n      }\n\n      // check the score\n      if (score < 0) {\n        // we don't GRAFT peers with negative score\n        this.log('GRAFT: ignoring peer %s with negative score: score=%d, topic=%s', id, score, topicID)\n        // we do send them PRUNE however, because it's a matter of protocol correctness\n        prune.push(topicID)\n        // but we won't PX to them\n        doPX = false\n        // add/refresh backoff so that we don't reGRAFT too early even if the score decays\n        this.addBackoff(id, topicID)\n        return\n      }\n\n      // check the number of mesh peers; if it is at (or over) Dhi, we only accept grafts\n      // from peers with outbound connections; this is a defensive check to restrict potential\n      // mesh takeover attacks combined with love bombing\n      if (peersInMesh.size >= this.opts.Dhi && !(this.outbound.get(id) ?? false)) {\n        prune.push(topicID)\n        this.addBackoff(id, topicID)\n        return\n      }\n\n      this.log('GRAFT: Add mesh link from %s in %s', id, topicID)\n      this.score.graft(id, topicID)\n      peersInMesh.add(id)\n\n      this.metrics?.onAddToMesh(topicID, InclusionReason.Subscribed, 1)\n    })\n\n    if (prune.length === 0) {\n      return []\n    }\n\n    const onUnsubscribe = false\n    return Promise.all(prune.map(async (topic) => this.makePrune(id, topic, doPX, onUnsubscribe)))\n  }\n\n  /**\n   * Handles Prune messages\n   */\n  private async handlePrune (id: PeerIdStr, prune: RPC.IControlPrune[]): Promise<void> {\n    const score = this.score.score(id)\n\n    for (const { topicID, backoff, peers } of prune) {\n      if (topicID == null) {\n        continue\n      }\n\n      const peersInMesh = this.mesh.get(topicID)\n      if (peersInMesh == null) {\n        return\n      }\n\n      this.log('PRUNE: Remove mesh link to %s in %s', id, topicID)\n      this.score.prune(id, topicID)\n      if (peersInMesh.has(id)) {\n        peersInMesh.delete(id)\n        this.metrics?.onRemoveFromMesh(topicID, ChurnReason.Prune, 1)\n      }\n\n      // is there a backoff specified by the peer? if so obey it\n      if (typeof backoff === 'number' && backoff > 0) {\n        this.doAddBackoff(id, topicID, backoff * 1000)\n      } else {\n        this.addBackoff(id, topicID)\n      }\n\n      // PX\n      if ((peers != null) && (peers.length > 0)) {\n        // we ignore PX from peers with insufficient scores\n        if (score < this.opts.scoreThresholds.acceptPXThreshold) {\n          this.log(\n            'PRUNE: ignoring PX from peer %s with insufficient score [score = %d, topic = %s]',\n            id,\n            score,\n            topicID\n          )\n          continue\n        }\n        await this.pxConnect(peers)\n      }\n    }\n  }\n\n  /**\n   * Add standard backoff log for a peer in a topic\n   */\n  private addBackoff (id: PeerIdStr, topic: TopicStr): void {\n    this.doAddBackoff(id, topic, this.opts.pruneBackoff)\n  }\n\n  /**\n   * Add backoff expiry interval for a peer in a topic\n   *\n   * @param id\n   * @param topic\n   * @param intervalMs - backoff duration in milliseconds\n   */\n  private doAddBackoff (id: PeerIdStr, topic: TopicStr, intervalMs: number): void {\n    let backoff = this.backoff.get(topic)\n    if (backoff == null) {\n      backoff = new Map()\n      this.backoff.set(topic, backoff)\n    }\n    const expire = Date.now() + intervalMs\n    const existingExpire = backoff.get(id) ?? 0\n    if (existingExpire < expire) {\n      backoff.set(id, expire)\n    }\n  }\n\n  /**\n   * Apply penalties from broken IHAVE/IWANT promises\n   */\n  private applyIwantPenalties (): void {\n    this.gossipTracer.getBrokenPromises().forEach((count, p) => {\n      this.log(\"peer %s didn't follow up in %d IWANT requests; adding penalty\", p, count)\n      this.score.addPenalty(p, count, ScorePenalty.BrokenPromise)\n    })\n  }\n\n  /**\n   * Clear expired backoff expiries\n   */\n  private clearBackoff (): void {\n    // we only clear once every GossipsubPruneBackoffTicks ticks to avoid iterating over the maps too much\n    if (this.heartbeatTicks % constants.GossipsubPruneBackoffTicks !== 0) {\n      return\n    }\n\n    const now = Date.now()\n    this.backoff.forEach((backoff, topic) => {\n      backoff.forEach((expire, id) => {\n        // add some slack time to the expiration, see https://github.com/libp2p/specs/pull/289\n        if (expire + BACKOFF_SLACK * this.opts.heartbeatInterval < now) {\n          backoff.delete(id)\n        }\n      })\n      if (backoff.size === 0) {\n        this.backoff.delete(topic)\n      }\n    })\n  }\n\n  /**\n   * Maybe reconnect to direct peers\n   */\n  private async directConnect (): Promise<void> {\n    const toconnect: string[] = []\n    this.direct.forEach((id) => {\n      if (!this.streamsOutbound.has(id)) {\n        toconnect.push(id)\n      }\n    })\n\n    await Promise.all(toconnect.map(async (id) => this.connect(id)))\n  }\n\n  /**\n   * Maybe attempt connection given signed peer records\n   */\n  private async pxConnect (peers: RPC.IPeerInfo[]): Promise<void> {\n    if (peers.length > this.opts.prunePeers) {\n      shuffle(peers)\n      peers = peers.slice(0, this.opts.prunePeers)\n    }\n    const toconnect: string[] = []\n\n    await Promise.all(\n      peers.map(async (pi) => {\n        if (pi.peerID == null) {\n          return\n        }\n\n        const peer = peerIdFromBytes(pi.peerID)\n        const p = peer.toString()\n\n        if (this.peers.has(p)) {\n          return\n        }\n\n        if (pi.signedPeerRecord == null) {\n          toconnect.push(p)\n          return\n        }\n\n        // The peer sent us a signed record\n        // This is not a record from the peer who sent the record, but another peer who is connected with it\n        // Ensure that it is valid\n        try {\n          if (!(await this.components.peerStore.consumePeerRecord(pi.signedPeerRecord, peer))) {\n            this.log('bogus peer record obtained through px: could not add peer record to address book')\n            return\n          }\n          toconnect.push(p)\n        } catch (e) {\n          this.log('bogus peer record obtained through px: invalid signature or not a peer record')\n        }\n      })\n    )\n\n    if (toconnect.length === 0) {\n      return\n    }\n\n    await Promise.all(toconnect.map(async (id) => this.connect(id)))\n  }\n\n  /**\n   * Connect to a peer using the gossipsub protocol\n   */\n  private async connect (id: PeerIdStr): Promise<void> {\n    this.log('Initiating connection with %s', id)\n    const peerId = peerIdFromString(id)\n    const connection = await this.components.connectionManager.openConnection(peerId)\n    for (const multicodec of this.multicodecs) {\n      for (const topology of this.components.registrar.getTopologies(multicodec)) {\n        topology.onConnect?.(peerId, connection)\n      }\n    }\n  }\n\n  /**\n   * Subscribes to a topic\n   */\n  subscribe (topic: TopicStr): void {\n    if (this.status.code !== GossipStatusCode.started) {\n      throw new Error('Pubsub has not started')\n    }\n\n    if (!this.subscriptions.has(topic)) {\n      this.subscriptions.add(topic)\n\n      for (const peerId of this.peers.keys()) {\n        this.sendSubscriptions(peerId, [topic], true)\n      }\n    }\n\n    this.join(topic)\n  }\n\n  /**\n   * Unsubscribe to a topic\n   */\n  unsubscribe (topic: TopicStr): void {\n    if (this.status.code !== GossipStatusCode.started) {\n      throw new Error('Pubsub is not started')\n    }\n\n    const wasSubscribed = this.subscriptions.delete(topic)\n\n    this.log('unsubscribe from %s - am subscribed %s', topic, wasSubscribed)\n\n    if (wasSubscribed) {\n      for (const peerId of this.peers.keys()) {\n        this.sendSubscriptions(peerId, [topic], false)\n      }\n    }\n\n    this.leave(topic)\n  }\n\n  /**\n   * Join topic\n   */\n  private join (topic: TopicStr): void {\n    if (this.status.code !== GossipStatusCode.started) {\n      throw new Error('Gossipsub has not started')\n    }\n\n    // if we are already in the mesh, return\n    if (this.mesh.has(topic)) {\n      return\n    }\n\n    this.log('JOIN %s', topic)\n    this.metrics?.onJoin(topic)\n\n    const toAdd = new Set<PeerIdStr>()\n    const backoff = this.backoff.get(topic)\n\n    // check if we have mesh_n peers in fanout[topic] and add them to the mesh if we do,\n    // removing the fanout entry.\n    const fanoutPeers = this.fanout.get(topic)\n    if (fanoutPeers != null) {\n      // Remove fanout entry and the last published time\n      this.fanout.delete(topic)\n      this.fanoutLastpub.delete(topic)\n\n      // remove explicit peers, peers with negative scores, and backoffed peers\n      fanoutPeers.forEach((id) => {\n        if (!this.direct.has(id) && this.score.score(id) >= 0 && ((backoff == null) || !backoff.has(id))) {\n          toAdd.add(id)\n        }\n      })\n\n      this.metrics?.onAddToMesh(topic, InclusionReason.Fanout, toAdd.size)\n    }\n\n    // check if we need to get more peers, which we randomly select\n    if (toAdd.size < this.opts.D) {\n      const fanoutCount = toAdd.size\n      const newPeers = this.getRandomGossipPeers(\n        topic,\n        this.opts.D,\n        (id: PeerIdStr): boolean =>\n          // filter direct peers and peers with negative score\n          !toAdd.has(id) && !this.direct.has(id) && this.score.score(id) >= 0 && ((backoff == null) || !backoff.has(id))\n      )\n\n      newPeers.forEach((peer) => {\n        toAdd.add(peer)\n      })\n\n      this.metrics?.onAddToMesh(topic, InclusionReason.Random, toAdd.size - fanoutCount)\n    }\n\n    this.mesh.set(topic, toAdd)\n\n    toAdd.forEach((id) => {\n      this.log('JOIN: Add mesh link to %s in %s', id, topic)\n      this.sendGraft(id, topic)\n\n      // rust-libp2p\n      // - peer_score.graft()\n      // - Self::control_pool_add()\n      // - peer_added_to_mesh()\n    })\n  }\n\n  /**\n   * Leave topic\n   */\n  private leave (topic: TopicStr): void {\n    if (this.status.code !== GossipStatusCode.started) {\n      throw new Error('Gossipsub has not started')\n    }\n\n    this.log('LEAVE %s', topic)\n    this.metrics?.onLeave(topic)\n\n    // Send PRUNE to mesh peers\n    const meshPeers = this.mesh.get(topic)\n    if (meshPeers != null) {\n      Promise.all(\n        Array.from(meshPeers).map(async (id) => {\n          this.log('LEAVE: Remove mesh link to %s in %s', id, topic)\n          await this.sendPrune(id, topic)\n        })\n      ).catch((err) => {\n        this.log('Error sending prunes to mesh peers', err)\n      })\n      this.mesh.delete(topic)\n    }\n  }\n\n  private selectPeersToForward (topic: TopicStr, propagationSource?: PeerIdStr, excludePeers?: Set<PeerIdStr>): Set<string> {\n    const tosend = new Set<PeerIdStr>()\n\n    // Add explicit peers\n    const peersInTopic = this.topics.get(topic)\n    if (peersInTopic != null) {\n      this.direct.forEach((peer) => {\n        if (peersInTopic.has(peer) && propagationSource !== peer && !(excludePeers?.has(peer) ?? false)) {\n          tosend.add(peer)\n        }\n      })\n\n      // As of Mar 2022, spec + golang-libp2p include this while rust-libp2p does not\n      // rust-libp2p: https://github.com/libp2p/rust-libp2p/blob/6cc3b4ec52c922bfcf562a29b5805c3150e37c75/protocols/gossipsub/src/behaviour.rs#L2693\n      // spec: https://github.com/libp2p/specs/blob/10712c55ab309086a52eec7d25f294df4fa96528/pubsub/gossipsub/gossipsub-v1.0.md?plain=1#L361\n      this.floodsubPeers.forEach((peer) => {\n        if (\n          peersInTopic.has(peer) &&\n          propagationSource !== peer &&\n          !(excludePeers?.has(peer) ?? false) &&\n          this.score.score(peer) >= this.opts.scoreThresholds.publishThreshold\n        ) {\n          tosend.add(peer)\n        }\n      })\n    }\n\n    // add mesh peers\n    const meshPeers = this.mesh.get(topic)\n    if ((meshPeers != null) && meshPeers.size > 0) {\n      meshPeers.forEach((peer) => {\n        if (propagationSource !== peer && !(excludePeers?.has(peer) ?? false)) {\n          tosend.add(peer)\n        }\n      })\n    }\n\n    return tosend\n  }\n\n  private selectPeersToPublish (topic: TopicStr): {\n    tosend: Set<PeerIdStr>\n    tosendCount: ToSendGroupCount\n  } {\n    const tosend = new Set<PeerIdStr>()\n    const tosendCount: ToSendGroupCount = {\n      direct: 0,\n      floodsub: 0,\n      mesh: 0,\n      fanout: 0\n    }\n\n    const peersInTopic = this.topics.get(topic)\n    if (peersInTopic != null) {\n      // flood-publish behavior\n      // send to direct peers and _all_ peers meeting the publishThreshold\n      if (this.opts.floodPublish) {\n        peersInTopic.forEach((id) => {\n          if (this.direct.has(id)) {\n            tosend.add(id)\n            tosendCount.direct++\n          } else if (this.score.score(id) >= this.opts.scoreThresholds.publishThreshold) {\n            tosend.add(id)\n            tosendCount.floodsub++\n          }\n        })\n      } else {\n        // non-flood-publish behavior\n        // send to direct peers, subscribed floodsub peers\n        // and some mesh peers above publishThreshold\n\n        // direct peers (if subscribed)\n        this.direct.forEach((id) => {\n          if (peersInTopic.has(id)) {\n            tosend.add(id)\n            tosendCount.direct++\n          }\n        })\n\n        // floodsub peers\n        // Note: if there are no floodsub peers, we save a loop through peersInTopic Map\n        this.floodsubPeers.forEach((id) => {\n          if (peersInTopic.has(id) && this.score.score(id) >= this.opts.scoreThresholds.publishThreshold) {\n            tosend.add(id)\n            tosendCount.floodsub++\n          }\n        })\n\n        // Gossipsub peers handling\n        const meshPeers = this.mesh.get(topic)\n        if ((meshPeers != null) && meshPeers.size > 0) {\n          meshPeers.forEach((peer) => {\n            tosend.add(peer)\n            tosendCount.mesh++\n          })\n        // eslint-disable-next-line @typescript-eslint/brace-style\n        }\n\n        // We are not in the mesh for topic, use fanout peers\n        else {\n          const fanoutPeers = this.fanout.get(topic)\n          if ((fanoutPeers != null) && fanoutPeers.size > 0) {\n            fanoutPeers.forEach((peer) => {\n              tosend.add(peer)\n              tosendCount.fanout++\n            })\n          // eslint-disable-next-line @typescript-eslint/brace-style\n          }\n\n          // We have no fanout peers, select mesh_n of them and add them to the fanout\n          else {\n            // If we are not in the fanout, then pick peers in topic above the publishThreshold\n            const newFanoutPeers = this.getRandomGossipPeers(topic, this.opts.D, (id) => {\n              return this.score.score(id) >= this.opts.scoreThresholds.publishThreshold\n            })\n\n            // eslint-disable-next-line max-depth\n            if (newFanoutPeers.size > 0) {\n              this.fanout.set(topic, newFanoutPeers)\n\n              newFanoutPeers.forEach((peer) => {\n                tosend.add(peer)\n                tosendCount.fanout++\n              })\n            }\n          }\n\n          // We are publishing to fanout peers - update the time we published\n          this.fanoutLastpub.set(topic, Date.now())\n        }\n      }\n    }\n\n    return { tosend, tosendCount }\n  }\n\n  /**\n   * Forwards a message from our peers.\n   *\n   * For messages published by us (the app layer), this class uses `publish`\n   */\n  private forwardMessage (\n    msgIdStr: string,\n    rawMsg: RPC.IMessage,\n    propagationSource?: PeerIdStr,\n    excludePeers?: Set<PeerIdStr>\n  ): void {\n    // message is fully validated inform peer_score\n    if (propagationSource != null) {\n      this.score.deliverMessage(propagationSource, msgIdStr, rawMsg.topic)\n    }\n\n    const tosend = this.selectPeersToForward(rawMsg.topic, propagationSource, excludePeers)\n\n    // Note: Don't throw if tosend is empty, we can have a mesh with a single peer\n\n    // forward the message to peers\n    tosend.forEach((id) => {\n      // sendRpc may mutate RPC message on piggyback, create a new message for each peer\n      this.sendRpc(id, { messages: [rawMsg] })\n    })\n\n    this.metrics?.onForwardMsg(rawMsg.topic, tosend.size)\n  }\n\n  /**\n   * App layer publishes a message to peers, return number of peers this message is published to\n   * Note: `async` due to crypto only if `StrictSign`, otherwise it's a sync fn.\n   *\n   * For messages not from us, this class uses `forwardMessage`.\n   */\n  async publish (topic: TopicStr, data: Uint8Array, opts?: PublishOpts): Promise<PublishResult> {\n    const startMs = Date.now()\n    const transformedData = (this.dataTransform != null) ? this.dataTransform.outboundTransform(topic, data) : data\n\n    if (this.publishConfig == null) {\n      throw Error('PublishError.Uninitialized')\n    }\n\n    // Prepare raw message with user's publishConfig\n    const { raw: rawMsg, msg } = await buildRawMessage(this.publishConfig, topic, data, transformedData)\n\n    // calculate the message id from the un-transformed data\n    const msgId = await this.msgIdFn(msg)\n    const msgIdStr = this.msgIdToStrFn(msgId)\n\n    // Current publish opt takes precedence global opts, while preserving false value\n    const ignoreDuplicatePublishError = opts?.ignoreDuplicatePublishError ?? this.opts.ignoreDuplicatePublishError\n\n    if (this.seenCache.has(msgIdStr)) {\n      // This message has already been seen. We don't re-publish messages that have already\n      // been published on the network.\n      if (ignoreDuplicatePublishError) {\n        this.metrics?.onPublishDuplicateMsg(topic)\n        return { recipients: [] }\n      }\n      throw Error('PublishError.Duplicate')\n    }\n\n    const { tosend, tosendCount } = this.selectPeersToPublish(topic)\n    const willSendToSelf = this.opts.emitSelf && this.subscriptions.has(topic)\n\n    // Current publish opt takes precedence global opts, while preserving false value\n    const allowPublishToZeroPeers = opts?.allowPublishToZeroPeers ?? this.opts.allowPublishToZeroPeers\n\n    if (tosend.size === 0 && !allowPublishToZeroPeers && !willSendToSelf) {\n      throw Error('PublishError.InsufficientPeers')\n    }\n\n    // If the message isn't a duplicate and we have sent it to some peers add it to the\n    // duplicate cache and memcache.\n    this.seenCache.put(msgIdStr)\n    // all published messages are valid\n    this.mcache.put({ msgId, msgIdStr }, rawMsg, true)\n\n    // If the message is anonymous or has a random author add it to the published message ids cache.\n    this.publishedMessageIds.put(msgIdStr)\n\n    const batchPublish = opts?.batchPublish ?? this.opts.batchPublish\n    const rpc = { messages: [rawMsg] }\n    if (batchPublish) {\n      this.sendRpcInBatch(tosend, rpc)\n    } else {\n      // Send to set of peers aggregated from direct, mesh, fanout\n      for (const id of tosend) {\n        // sendRpc may mutate RPC message on piggyback, create a new message for each peer\n        const sent = this.sendRpc(id, rpc)\n\n        // did not actually send the message\n        if (!sent) {\n          tosend.delete(id)\n        }\n      }\n    }\n\n    const durationMs = Date.now() - startMs\n    this.metrics?.onPublishMsg(\n      topic,\n      tosendCount,\n      tosend.size,\n      rawMsg.data != null ? rawMsg.data.length : 0,\n      durationMs\n    )\n\n    // Dispatch the message to the user if we are subscribed to the topic\n    if (willSendToSelf) {\n      tosend.add(this.components.peerId.toString())\n\n      super.dispatchEvent(\n        new CustomEvent<GossipsubMessage>('gossipsub:message', {\n          detail: {\n            propagationSource: this.components.peerId,\n            msgId: msgIdStr,\n            msg\n          }\n        })\n      )\n      // TODO: Add option to switch between emit per topic or all messages in one\n      super.dispatchEvent(new CustomEvent<Message>('message', { detail: msg }))\n    }\n\n    return {\n      recipients: Array.from(tosend.values()).map((str) => peerIdFromString(str))\n    }\n  }\n\n  /**\n   * Send the same data in batch to tosend list without considering cached control messages\n   * This is not only faster but also avoid allocating memory for each peer\n   * see https://github.com/ChainSafe/js-libp2p-gossipsub/issues/344\n   */\n  private sendRpcInBatch (tosend: Set<PeerIdStr>, rpc: IRPC): void {\n    const rpcBytes = RPC.encode(rpc).finish()\n    const prefixedData = encode.single(rpcBytes)\n    for (const id of tosend) {\n      const outboundStream = this.streamsOutbound.get(id)\n      if (outboundStream == null) {\n        this.log(`Cannot send RPC to ${id} as there is no open stream to it available`)\n        tosend.delete(id)\n        continue\n      }\n      try {\n        outboundStream.pushPrefixed(prefixedData)\n      } catch (e) {\n        tosend.delete(id)\n        this.log.error(`Cannot send rpc to ${id}`, e)\n      }\n\n      this.metrics?.onRpcSent(rpc, rpcBytes.length)\n    }\n  }\n\n  /**\n   * This function should be called when `asyncValidation` is `true` after\n   * the message got validated by the caller. Messages are stored in the `mcache` and\n   * validation is expected to be fast enough that the messages should still exist in the cache.\n   * There are three possible validation outcomes and the outcome is given in acceptance.\n   *\n   * If acceptance = `MessageAcceptance.Accept` the message will get propagated to the\n   * network. The `propagation_source` parameter indicates who the message was received by and\n   * will not be forwarded back to that peer.\n   *\n   * If acceptance = `MessageAcceptance.Reject` the message will be deleted from the memcache\n   * and the P₄ penalty will be applied to the `propagationSource`.\n   *\n   * If acceptance = `MessageAcceptance.Ignore` the message will be deleted from the memcache\n   * but no P₄ penalty will be applied.\n   *\n   * This function will return true if the message was found in the cache and false if was not\n   * in the cache anymore.\n   *\n   * This should only be called once per message.\n   */\n  reportMessageValidationResult (msgId: MsgIdStr, propagationSource: PeerIdStr, acceptance: TopicValidatorResult): void {\n    let cacheEntry: MessageCacheRecord | null\n\n    if (acceptance === TopicValidatorResult.Accept) {\n      cacheEntry = this.mcache.validate(msgId)\n\n      if (cacheEntry != null) {\n        const { message: rawMsg, originatingPeers } = cacheEntry\n        // message is fully validated inform peer_score\n        this.score.deliverMessage(propagationSource, msgId, rawMsg.topic)\n\n        this.forwardMessage(msgId, cacheEntry.message, propagationSource, originatingPeers)\n      }\n      // else, Message not in cache. Ignoring forwarding\n    // eslint-disable-next-line @typescript-eslint/brace-style\n    }\n\n    // Not valid\n    else {\n      cacheEntry = this.mcache.remove(msgId)\n\n      if (cacheEntry != null) {\n        const rejectReason = rejectReasonFromAcceptance(acceptance)\n        const { message: rawMsg, originatingPeers } = cacheEntry\n\n        // Tell peer_score about reject\n        // Reject the original source, and any duplicates we've seen from other peers.\n        this.score.rejectMessage(propagationSource, msgId, rawMsg.topic, rejectReason)\n        for (const peer of originatingPeers) {\n          this.score.rejectMessage(peer, msgId, rawMsg.topic, rejectReason)\n        }\n      }\n      // else, Message not in cache. Ignoring forwarding\n    }\n\n    const firstSeenTimestampMs = this.score.messageFirstSeenTimestampMs(msgId)\n    this.metrics?.onReportValidation(cacheEntry, acceptance, firstSeenTimestampMs)\n  }\n\n  /**\n   * Sends a GRAFT message to a peer\n   */\n  private sendGraft (id: PeerIdStr, topic: string): void {\n    const graft = [\n      {\n        topicID: topic\n      }\n    ]\n\n    this.sendRpc(id, { control: { graft } })\n  }\n\n  /**\n   * Sends a PRUNE message to a peer\n   */\n  private async sendPrune (id: PeerIdStr, topic: string): Promise<void> {\n    // this is only called from leave() function\n    const onUnsubscribe = true\n    const prune = [await this.makePrune(id, topic, this.opts.doPX, onUnsubscribe)]\n\n    this.sendRpc(id, { control: { prune } })\n  }\n\n  /**\n   * Send an rpc object to a peer\n   */\n  private sendRpc (id: PeerIdStr, rpc: IRPC): boolean {\n    const outboundStream = this.streamsOutbound.get(id)\n    if (outboundStream == null) {\n      this.log(`Cannot send RPC to ${id} as there is no open stream to it available`)\n      return false\n    }\n\n    // piggyback control message retries\n    const ctrl = this.control.get(id)\n    if (ctrl != null) {\n      this.piggybackControl(id, rpc, ctrl)\n      this.control.delete(id)\n    }\n\n    // piggyback gossip\n    const ihave = this.gossip.get(id)\n    if (ihave != null) {\n      this.piggybackGossip(id, rpc, ihave)\n      this.gossip.delete(id)\n    }\n\n    const rpcBytes = RPC.encode(rpc).finish()\n    try {\n      outboundStream.push(rpcBytes)\n    } catch (e) {\n      this.log.error(`Cannot send rpc to ${id}`, e)\n\n      // if the peer had control messages or gossip, re-attach\n      if (ctrl != null) {\n        this.control.set(id, ctrl)\n      }\n      if (ihave != null) {\n        this.gossip.set(id, ihave)\n      }\n\n      return false\n    }\n\n    this.metrics?.onRpcSent(rpc, rpcBytes.length)\n\n    return true\n  }\n\n  /** Mutates `outRpc` adding graft and prune control messages */\n  public piggybackControl (id: PeerIdStr, outRpc: IRPC, ctrl: RPC.IControlMessage): void {\n    if (ctrl.graft != null) {\n      if (outRpc.control == null) outRpc.control = {}\n      if (outRpc.control.graft == null) outRpc.control.graft = []\n      for (const graft of ctrl.graft) {\n        if (graft.topicID != null && (this.mesh.get(graft.topicID)?.has(id) ?? false)) {\n          outRpc.control.graft.push(graft)\n        }\n      }\n    }\n\n    if (ctrl.prune != null) {\n      if (outRpc.control == null) outRpc.control = {}\n      if (outRpc.control.prune == null) outRpc.control.prune = []\n      for (const prune of ctrl.prune) {\n        if (prune.topicID != null && !(this.mesh.get(prune.topicID)?.has(id) ?? false)) {\n          outRpc.control.prune.push(prune)\n        }\n      }\n    }\n  }\n\n  /** Mutates `outRpc` adding ihave control messages */\n  private piggybackGossip (id: PeerIdStr, outRpc: IRPC, ihave: RPC.IControlIHave[]): void {\n    if (outRpc.control == null) outRpc.control = {}\n    outRpc.control.ihave = ihave\n  }\n\n  /**\n   * Send graft and prune messages\n   *\n   * @param tograft - peer id => topic[]\n   * @param toprune - peer id => topic[]\n   */\n  private async sendGraftPrune (\n    tograft: Map<string, string[]>,\n    toprune: Map<string, string[]>,\n    noPX: Map<string, boolean>\n  ): Promise<void> {\n    const doPX = this.opts.doPX\n    const onUnsubscribe = false\n    for (const [id, topics] of tograft) {\n      const graft = topics.map((topicID) => ({ topicID }))\n      let prune: RPC.IControlPrune[] = []\n      // If a peer also has prunes, process them now\n      const pruning = toprune.get(id)\n      if (pruning != null) {\n        prune = await Promise.all(\n          pruning.map(\n            async (topicID) => this.makePrune(id, topicID, doPX && !(noPX.get(id) ?? false), onUnsubscribe)\n          )\n        )\n        toprune.delete(id)\n      }\n\n      this.sendRpc(id, { control: { graft, prune } })\n    }\n    for (const [id, topics] of toprune) {\n      const prune = await Promise.all(\n        topics.map(\n          async (topicID) => this.makePrune(id, topicID, doPX && !(noPX.get(id) ?? false), onUnsubscribe)\n        )\n      )\n      this.sendRpc(id, { control: { prune } })\n    }\n  }\n\n  /**\n   * Emits gossip - Send IHAVE messages to a random set of gossip peers\n   */\n  private emitGossip (peersToGossipByTopic: Map<string, Set<PeerIdStr>>): void {\n    const gossipIDsByTopic = this.mcache.getGossipIDs(new Set(peersToGossipByTopic.keys()))\n    for (const [topic, peersToGossip] of peersToGossipByTopic) {\n      this.doEmitGossip(topic, peersToGossip, gossipIDsByTopic.get(topic) ?? [])\n    }\n  }\n\n  /**\n   * Send gossip messages to GossipFactor peers above threshold with a minimum of D_lazy\n   * Peers are randomly selected from the heartbeat which exclude mesh + fanout peers\n   * We also exclude direct peers, as there is no reason to emit gossip to them\n   *\n   * @param topic\n   * @param candidateToGossip - peers to gossip\n   * @param messageIDs - message ids to gossip\n   */\n  private doEmitGossip (topic: string, candidateToGossip: Set<PeerIdStr>, messageIDs: Uint8Array[]): void {\n    if (messageIDs.length === 0) {\n      return\n    }\n\n    // shuffle to emit in random order\n    shuffle(messageIDs)\n\n    // if we are emitting more than GossipsubMaxIHaveLength ids, truncate the list\n    if (messageIDs.length > constants.GossipsubMaxIHaveLength) {\n      // we do the truncation (with shuffling) per peer below\n      this.log('too many messages for gossip; will truncate IHAVE list (%d messages)', messageIDs.length)\n    }\n\n    if (candidateToGossip.size === 0) return\n    let target = this.opts.Dlazy\n    const factor = constants.GossipsubGossipFactor * candidateToGossip.size\n    let peersToGossip: Set<PeerIdStr> | PeerIdStr[] = candidateToGossip\n    if (factor > target) {\n      target = factor\n    }\n    if (target > peersToGossip.size) {\n      target = peersToGossip.size\n    } else {\n      // only shuffle if needed\n      peersToGossip = shuffle(Array.from(peersToGossip)).slice(0, target)\n    }\n\n    // Emit the IHAVE gossip to the selected peers up to the target\n    peersToGossip.forEach((id) => {\n      let peerMessageIDs = messageIDs\n      if (messageIDs.length > constants.GossipsubMaxIHaveLength) {\n        // shuffle and slice message IDs per peer so that we emit a different set for each peer\n        // we have enough reduncancy in the system that this will significantly increase the message\n        // coverage when we do truncate\n        peerMessageIDs = shuffle(peerMessageIDs.slice()).slice(0, constants.GossipsubMaxIHaveLength)\n      }\n      this.pushGossip(id, {\n        topicID: topic,\n        messageIDs: peerMessageIDs\n      })\n    })\n  }\n\n  /**\n   * Flush gossip and control messages\n   */\n  private flush (): void {\n    // send gossip first, which will also piggyback control\n    for (const [peer, ihave] of this.gossip.entries()) {\n      this.gossip.delete(peer)\n      this.sendRpc(peer, { control: { ihave } })\n    }\n    // send the remaining control messages\n    for (const [peer, control] of this.control.entries()) {\n      this.control.delete(peer)\n      this.sendRpc(peer, { control: { graft: control.graft, prune: control.prune } })\n    }\n  }\n\n  /**\n   * Adds new IHAVE messages to pending gossip\n   */\n  private pushGossip (id: PeerIdStr, controlIHaveMsgs: RPC.IControlIHave): void {\n    this.log('Add gossip to %s', id)\n    const gossip = this.gossip.get(id) ?? []\n    this.gossip.set(id, gossip.concat(controlIHaveMsgs))\n  }\n\n  /**\n   * Make a PRUNE control message for a peer in a topic\n   */\n  private async makePrune (\n    id: PeerIdStr,\n    topic: string,\n    doPX: boolean,\n    onUnsubscribe: boolean\n  ): Promise<RPC.IControlPrune> {\n    this.score.prune(id, topic)\n    if (this.streamsOutbound.get(id)?.protocol === constants.GossipsubIDv10) {\n      // Gossipsub v1.0 -- no backoff, the peer won't be able to parse it anyway\n      return {\n        topicID: topic,\n        peers: []\n      }\n    }\n    // backoff is measured in seconds\n    // GossipsubPruneBackoff and GossipsubUnsubscribeBackoff are measured in milliseconds\n    // The protobuf has it as a uint64\n    const backoffMs = onUnsubscribe ? this.opts.unsubcribeBackoff : this.opts.pruneBackoff\n    const backoff = backoffMs / 1000\n    this.doAddBackoff(id, topic, backoffMs)\n\n    if (!doPX) {\n      return {\n        topicID: topic,\n        peers: [],\n        backoff\n      }\n    }\n\n    // select peers for Peer eXchange\n    const peers = this.getRandomGossipPeers(topic, this.opts.prunePeers, (xid) => {\n      return xid !== id && this.score.score(xid) >= 0\n    })\n    const px = await Promise.all(\n      Array.from(peers).map(async (peerId) => {\n        // see if we have a signed record to send back; if we don't, just send\n        // the peer ID and let the pruned peer find them in the DHT -- we can't trust\n        // unsigned address records through PX anyways\n        // Finding signed records in the DHT is not supported at the time of writing in js-libp2p\n        const id = peerIdFromString(peerId)\n        let peerInfo: Peer | undefined\n\n        try {\n          peerInfo = await this.components.peerStore.get(id)\n        } catch (err: any) {\n          if (err.code !== 'ERR_NOT_FOUND') {\n            throw err\n          }\n        }\n\n        return {\n          peerID: id.toBytes(),\n          signedPeerRecord: peerInfo?.peerRecordEnvelope\n        }\n      })\n    )\n    return {\n      topicID: topic,\n      peers: px,\n      backoff\n    }\n  }\n\n  private readonly runHeartbeat = (): void => {\n    const timer = this.metrics?.heartbeatDuration.startTimer()\n\n    this.heartbeat()\n      .catch((err) => {\n        this.log('Error running heartbeat', err)\n      })\n      .finally(() => {\n        if (timer != null) {\n          timer()\n        }\n\n        // Schedule the next run if still in started status\n        if (this.status.code === GossipStatusCode.started) {\n          // Clear previous timeout before overwriting `status.heartbeatTimeout`, it should be completed tho.\n          clearTimeout(this.status.heartbeatTimeout)\n\n          // NodeJS setInterval function is innexact, calls drift by a few miliseconds on each call.\n          // To run the heartbeat precisely setTimeout() must be used recomputing the delay on every loop.\n          let msToNextHeartbeat =\n            this.opts.heartbeatInterval - ((Date.now() - this.status.hearbeatStartMs) % this.opts.heartbeatInterval)\n\n          // If too close to next heartbeat, skip one\n          if (msToNextHeartbeat < this.opts.heartbeatInterval * 0.25) {\n            msToNextHeartbeat += this.opts.heartbeatInterval\n            this.metrics?.heartbeatSkipped.inc()\n          }\n\n          this.status.heartbeatTimeout = setTimeout(this.runHeartbeat, msToNextHeartbeat)\n        }\n      })\n  }\n\n  /**\n   * Maintains the mesh and fanout maps in gossipsub.\n   */\n  public async heartbeat (): Promise<void> {\n    const { D, Dlo, Dhi, Dscore, Dout, fanoutTTL } = this.opts\n\n    this.heartbeatTicks++\n\n    // cache scores throught the heartbeat\n    const scores = new Map<string, number>()\n    const getScore = (id: string): number => {\n      let s = scores.get(id)\n      if (s === undefined) {\n        s = this.score.score(id)\n        scores.set(id, s)\n      }\n      return s\n    }\n\n    // peer id => topic[]\n    const tograft = new Map<string, string[]>()\n    // peer id => topic[]\n    const toprune = new Map<string, string[]>()\n    // peer id => don't px\n    const noPX = new Map<string, boolean>()\n\n    // clean up expired backoffs\n    this.clearBackoff()\n\n    // clean up peerhave/iasked counters\n    this.peerhave.clear()\n    this.metrics?.cacheSize.set({ cache: 'iasked' }, this.iasked.size)\n    this.iasked.clear()\n\n    // apply IWANT request penalties\n    this.applyIwantPenalties()\n\n    // ensure direct peers are connected\n    if (this.heartbeatTicks % this.opts.directConnectTicks === 0) {\n      // we only do this every few ticks to allow pending connections to complete and account for restarts/downtime\n      await this.directConnect()\n    }\n\n    // EXTRA: Prune caches\n    this.fastMsgIdCache?.prune()\n    this.seenCache.prune()\n    this.gossipTracer.prune()\n    this.publishedMessageIds.prune()\n\n    /**\n     * Instead of calling getRandomGossipPeers multiple times to:\n     * + get more mesh peers\n     * + more outbound peers\n     * + oppportunistic grafting\n     * + emitGossip\n     *\n     * We want to loop through the topic peers only a single time and prepare gossip peers for all topics to improve the performance\n     */\n\n    const peersToGossipByTopic = new Map<string, Set<PeerIdStr>>()\n    // maintain the mesh for topics we have joined\n    // eslint-disable-next-line complexity\n    this.mesh.forEach((peers, topic) => {\n      const peersInTopic = this.topics.get(topic)\n      const candidateMeshPeers = new Set<PeerIdStr>()\n      const peersToGossip = new Set<PeerIdStr>()\n      peersToGossipByTopic.set(topic, peersToGossip)\n\n      if (peersInTopic != null) {\n        const shuffledPeers = shuffle(Array.from(peersInTopic))\n        const backoff = this.backoff.get(topic)\n        for (const id of shuffledPeers) {\n          const peerStreams = this.streamsOutbound.get(id)\n          if (\n            (peerStreams != null) &&\n            this.multicodecs.includes(peerStreams.protocol) &&\n            !peers.has(id) &&\n            !this.direct.has(id)\n          ) {\n            const score = getScore(id)\n            if (((backoff == null) || !backoff.has(id)) && score >= 0) candidateMeshPeers.add(id)\n            // instead of having to find gossip peers after heartbeat which require another loop\n            // we prepare peers to gossip in a topic within heartbeat to improve performance\n            if (score >= this.opts.scoreThresholds.gossipThreshold) peersToGossip.add(id)\n          }\n        }\n      }\n\n      // prune/graft helper functions (defined per topic)\n      const prunePeer = (id: PeerIdStr, reason: ChurnReason): void => {\n        this.log('HEARTBEAT: Remove mesh link to %s in %s', id, topic)\n        // no need to update peer score here as we do it in makePrune\n        // add prune backoff record\n        this.addBackoff(id, topic)\n        // remove peer from mesh\n        peers.delete(id)\n        // after pruning a peer from mesh, we want to gossip topic to it if its score meet the gossip threshold\n        if (getScore(id) >= this.opts.scoreThresholds.gossipThreshold) peersToGossip.add(id)\n        this.metrics?.onRemoveFromMesh(topic, reason, 1)\n        // add to toprune\n        const topics = toprune.get(id)\n        if (topics == null) {\n          toprune.set(id, [topic])\n        } else {\n          topics.push(topic)\n        }\n      }\n\n      const graftPeer = (id: PeerIdStr, reason: InclusionReason): void => {\n        this.log('HEARTBEAT: Add mesh link to %s in %s', id, topic)\n        // update peer score\n        this.score.graft(id, topic)\n        // add peer to mesh\n        peers.add(id)\n        // when we add a new mesh peer, we don't want to gossip messages to it\n        peersToGossip.delete(id)\n        this.metrics?.onAddToMesh(topic, reason, 1)\n        // add to tograft\n        const topics = tograft.get(id)\n        if (topics == null) {\n          tograft.set(id, [topic])\n        } else {\n          topics.push(topic)\n        }\n      }\n\n      // drop all peers with negative score, without PX\n      peers.forEach((id) => {\n        const score = getScore(id)\n\n        // Record the score\n\n        if (score < 0) {\n          this.log('HEARTBEAT: Prune peer %s with negative score: score=%d, topic=%s', id, score, topic)\n          prunePeer(id, ChurnReason.BadScore)\n          noPX.set(id, true)\n        }\n      })\n\n      // do we have enough peers?\n      if (peers.size < Dlo) {\n        const ineed = D - peers.size\n        // slice up to first `ineed` items and remove them from candidateMeshPeers\n        // same to `const newMeshPeers = candidateMeshPeers.slice(0, ineed)`\n        const newMeshPeers = removeFirstNItemsFromSet(candidateMeshPeers, ineed)\n\n        newMeshPeers.forEach((p) => {\n          graftPeer(p, InclusionReason.NotEnough)\n        })\n      }\n\n      // do we have to many peers?\n      if (peers.size > Dhi) {\n        let peersArray = Array.from(peers)\n        // sort by score\n        peersArray.sort((a, b) => getScore(b) - getScore(a))\n        // We keep the first D_score peers by score and the remaining up to D randomly\n        // under the constraint that we keep D_out peers in the mesh (if we have that many)\n        peersArray = peersArray.slice(0, Dscore).concat(shuffle(peersArray.slice(Dscore)))\n\n        // count the outbound peers we are keeping\n        let outbound = 0\n        peersArray.slice(0, D).forEach((p) => {\n          if (this.outbound.get(p) ?? false) {\n            outbound++\n          }\n        })\n\n        // if it's less than D_out, bubble up some outbound peers from the random selection\n        if (outbound < Dout) {\n          const rotate = (i: number): void => {\n            // rotate the peersArray to the right and put the ith peer in the front\n            const p = peersArray[i]\n            for (let j = i; j > 0; j--) {\n              peersArray[j] = peersArray[j - 1]\n            }\n            peersArray[0] = p\n          }\n\n          // first bubble up all outbound peers already in the selection to the front\n          if (outbound > 0) {\n            let ihave = outbound\n            for (let i = 1; i < D && ihave > 0; i++) {\n              // eslint-disable-next-line max-depth\n              if (this.outbound.get(peersArray[i]) ?? false) {\n                rotate(i)\n                ihave--\n              }\n            }\n          }\n\n          // now bubble up enough outbound peers outside the selection to the front\n          let ineed = D - outbound\n          for (let i = D; i < peersArray.length && ineed > 0; i++) {\n            if (this.outbound.get(peersArray[i]) ?? false) {\n              rotate(i)\n              ineed--\n            }\n          }\n        }\n\n        // prune the excess peers\n        peersArray.slice(D).forEach((p) => {\n          prunePeer(p, ChurnReason.Excess)\n        })\n      }\n\n      // do we have enough outbound peers?\n      if (peers.size >= Dlo) {\n        // count the outbound peers we have\n        let outbound = 0\n        peers.forEach((p) => {\n          if (this.outbound.get(p) ?? false) {\n            outbound++\n          }\n        })\n\n        // if it's less than D_out, select some peers with outbound connections and graft them\n        if (outbound < Dout) {\n          const ineed = Dout - outbound\n          const newMeshPeers = removeItemsFromSet(candidateMeshPeers, ineed, (id) => this.outbound.get(id) === true)\n\n          newMeshPeers.forEach((p) => {\n            graftPeer(p, InclusionReason.Outbound)\n          })\n        }\n      }\n\n      // should we try to improve the mesh with opportunistic grafting?\n      if (this.heartbeatTicks % this.opts.opportunisticGraftTicks === 0 && peers.size > 1) {\n        // Opportunistic grafting works as follows: we check the median score of peers in the\n        // mesh; if this score is below the opportunisticGraftThreshold, we select a few peers at\n        // random with score over the median.\n        // The intention is to (slowly) improve an underperforming mesh by introducing good\n        // scoring peers that may have been gossiping at us. This allows us to get out of sticky\n        // situations where we are stuck with poor peers and also recover from churn of good peers.\n\n        // now compute the median peer score in the mesh\n        const peersList = Array.from(peers).sort((a, b) => getScore(a) - getScore(b))\n        const medianIndex = Math.floor(peers.size / 2)\n        const medianScore = getScore(peersList[medianIndex])\n\n        // if the median score is below the threshold, select a better peer (if any) and GRAFT\n        if (medianScore < this.opts.scoreThresholds.opportunisticGraftThreshold) {\n          const ineed = this.opts.opportunisticGraftPeers\n          const newMeshPeers = removeItemsFromSet(candidateMeshPeers, ineed, (id) => getScore(id) > medianScore)\n          for (const id of newMeshPeers) {\n            this.log('HEARTBEAT: Opportunistically graft peer %s on topic %s', id, topic)\n            graftPeer(id, InclusionReason.Opportunistic)\n          }\n        }\n      }\n    })\n\n    // expire fanout for topics we haven't published to in a while\n    const now = Date.now()\n    this.fanoutLastpub.forEach((lastpb, topic) => {\n      if (lastpb + fanoutTTL < now) {\n        this.fanout.delete(topic)\n        this.fanoutLastpub.delete(topic)\n      }\n    })\n\n    // maintain our fanout for topics we are publishing but we have not joined\n    this.fanout.forEach((fanoutPeers, topic) => {\n      // checks whether our peers are still in the topic and have a score above the publish threshold\n      const topicPeers = this.topics.get(topic)\n      fanoutPeers.forEach((id) => {\n        if (!(topicPeers?.has(id) ?? false) || getScore(id) < this.opts.scoreThresholds.publishThreshold) {\n          fanoutPeers.delete(id)\n        }\n      })\n\n      const peersInTopic = this.topics.get(topic)\n      const candidateFanoutPeers = []\n      // the fanout map contains topics to which we are not subscribed.\n      const peersToGossip = new Set<PeerIdStr>()\n      peersToGossipByTopic.set(topic, peersToGossip)\n\n      if (peersInTopic != null) {\n        const shuffledPeers = shuffle(Array.from(peersInTopic))\n        for (const id of shuffledPeers) {\n          const peerStreams = this.streamsOutbound.get(id)\n          if (\n            (peerStreams != null) &&\n            this.multicodecs.includes(peerStreams.protocol) &&\n            !fanoutPeers.has(id) &&\n            !this.direct.has(id)\n          ) {\n            const score = getScore(id)\n            if (score >= this.opts.scoreThresholds.publishThreshold) candidateFanoutPeers.push(id)\n            // instead of having to find gossip peers after heartbeat which require another loop\n            // we prepare peers to gossip in a topic within heartbeat to improve performance\n            if (score >= this.opts.scoreThresholds.gossipThreshold) peersToGossip.add(id)\n          }\n        }\n      }\n\n      // do we need more peers?\n      if (fanoutPeers.size < D) {\n        const ineed = D - fanoutPeers.size\n        candidateFanoutPeers.slice(0, ineed).forEach((id) => {\n          fanoutPeers.add(id)\n          peersToGossip?.delete(id)\n        })\n      }\n    })\n\n    this.emitGossip(peersToGossipByTopic)\n\n    // send coalesced GRAFT/PRUNE messages (will piggyback gossip)\n    await this.sendGraftPrune(tograft, toprune, noPX)\n\n    // flush pending gossip that wasn't piggybacked above\n    this.flush()\n\n    // advance the message history window\n    this.mcache.shift()\n\n    this.dispatchEvent(new CustomEvent('gossipsub:heartbeat'))\n  }\n\n  /**\n   * Given a topic, returns up to count peers subscribed to that topic\n   * that pass an optional filter function\n   *\n   * @param topic\n   * @param count\n   * @param filter - a function to filter acceptable peers\n   */\n  private getRandomGossipPeers (\n    topic: string,\n    count: number,\n    filter: (id: string) => boolean = () => true\n  ): Set<string> {\n    const peersInTopic = this.topics.get(topic)\n\n    if (peersInTopic == null) {\n      return new Set()\n    }\n\n    // Adds all peers using our protocol\n    // that also pass the filter function\n    let peers: string[] = []\n    peersInTopic.forEach((id) => {\n      const peerStreams = this.streamsOutbound.get(id)\n      if (peerStreams == null) {\n        return\n      }\n      if (this.multicodecs.includes(peerStreams.protocol) && filter(id)) {\n        peers.push(id)\n      }\n    })\n\n    // Pseudo-randomly shuffles peers\n    peers = shuffle(peers)\n    if (count > 0 && peers.length > count) {\n      peers = peers.slice(0, count)\n    }\n\n    return new Set(peers)\n  }\n\n  private onScrapeMetrics (metrics: Metrics): void {\n    /* Data structure sizes */\n    metrics.mcacheSize.set(this.mcache.size)\n    metrics.mcacheNotValidatedCount.set(this.mcache.notValidatedCount)\n    // Arbitrary size\n    metrics.cacheSize.set({ cache: 'direct' }, this.direct.size)\n    metrics.cacheSize.set({ cache: 'seenCache' }, this.seenCache.size)\n    metrics.cacheSize.set({ cache: 'fastMsgIdCache' }, this.fastMsgIdCache?.size ?? 0)\n    metrics.cacheSize.set({ cache: 'publishedMessageIds' }, this.publishedMessageIds.size)\n    metrics.cacheSize.set({ cache: 'mcache' }, this.mcache.size)\n    metrics.cacheSize.set({ cache: 'score' }, this.score.size)\n    metrics.cacheSize.set({ cache: 'gossipTracer.promises' }, this.gossipTracer.size)\n    metrics.cacheSize.set({ cache: 'gossipTracer.requests' }, this.gossipTracer.requestMsByMsgSize)\n    // Bounded by topic\n    metrics.cacheSize.set({ cache: 'topics' }, this.topics.size)\n    metrics.cacheSize.set({ cache: 'subscriptions' }, this.subscriptions.size)\n    metrics.cacheSize.set({ cache: 'mesh' }, this.mesh.size)\n    metrics.cacheSize.set({ cache: 'fanout' }, this.fanout.size)\n    // Bounded by peer\n    metrics.cacheSize.set({ cache: 'peers' }, this.peers.size)\n    metrics.cacheSize.set({ cache: 'streamsOutbound' }, this.streamsOutbound.size)\n    metrics.cacheSize.set({ cache: 'streamsInbound' }, this.streamsInbound.size)\n    metrics.cacheSize.set({ cache: 'acceptFromWhitelist' }, this.acceptFromWhitelist.size)\n    metrics.cacheSize.set({ cache: 'gossip' }, this.gossip.size)\n    metrics.cacheSize.set({ cache: 'control' }, this.control.size)\n    metrics.cacheSize.set({ cache: 'peerhave' }, this.peerhave.size)\n    metrics.cacheSize.set({ cache: 'outbound' }, this.outbound.size)\n\n    // 2D nested data structure\n    let backoffSize = 0\n    const now = Date.now()\n    metrics.connectedPeersBackoffSec.reset()\n    for (const backoff of this.backoff.values()) {\n      backoffSize += backoff.size\n      for (const [peer, expiredMs] of backoff.entries()) {\n        if (this.peers.has(peer)) {\n          metrics.connectedPeersBackoffSec.observe(Math.max(0, expiredMs - now) / 1000)\n        }\n      }\n    }\n    metrics.cacheSize.set({ cache: 'backoff' }, backoffSize)\n\n    // Peer counts\n\n    for (const [topicStr, peers] of this.topics) {\n      metrics.topicPeersCount.set({ topicStr }, peers.size)\n    }\n\n    for (const [topicStr, peers] of this.mesh) {\n      metrics.meshPeerCounts.set({ topicStr }, peers.size)\n    }\n\n    // Peer scores\n\n    const scores: number[] = []\n    const scoreByPeer = new Map<PeerIdStr, number>()\n    metrics.behaviourPenalty.reset()\n\n    for (const peerIdStr of this.peers.keys()) {\n      const score = this.score.score(peerIdStr)\n      scores.push(score)\n      scoreByPeer.set(peerIdStr, score)\n      metrics.behaviourPenalty.observe(this.score.peerStats.get(peerIdStr)?.behaviourPenalty ?? 0)\n    }\n\n    metrics.registerScores(scores, this.opts.scoreThresholds)\n\n    // Breakdown score per mesh topicLabel\n\n    metrics.registerScorePerMesh(this.mesh, scoreByPeer)\n\n    // Breakdown on each score weight\n\n    const sw = computeAllPeersScoreWeights(\n      this.peers.keys(),\n      this.score.peerStats,\n      this.score.params,\n      this.score.peerIPs,\n      metrics.topicStrToLabel\n    )\n\n    metrics.registerScoreWeights(sw)\n  }\n}\n\nexport function gossipsub (\n  init: Partial<GossipsubOpts> = {}\n): (components: GossipSubComponents) => PubSub<GossipsubEvents> {\n  return (components: GossipSubComponents) => new GossipSub(components, init)\n}\n"],
  "mappings": "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",
  "names": ["exports", "module", "params", "offset", "exports", "encode", "i", "decode", "exports", "module", "exports", "module", "exports", "exports", "module", "size", "exports", "module", "exports", "i", "exports", "module", "create", "exports", "module", "exports", "module", "create_array", "create", "buffer", "exports", "module", "exports", "module", "self", "err", "exports", "exports", "module", "exports", "protobuf", "require_minimal", "exports", "module", "require_rpc", "exports", "module", "global", "RPC", "encode", "decode", "$oneOfFields", "exports", "module", "Denque", "protobuf", "cjs", "msgId", "SignaturePolicy", "PublishConfigType", "RejectReason", "ValidateError", "MessageStatus", "MessageSource", "InclusionReason", "ChurnReason", "ScorePenalty", "IHaveIgnoreReason", "ScoreThreshold", "DeliveryRecordStatus", "Denque", "msgId", "msgId", "msgId", "Protocol", "GossipStatusCode", "multicodec", "subscriptions", "msgId", "id"]
}
