{
  "version": 3,
  "sources": ["../../@libp2p/identify/src/consts.ts", "../../@libp2p/identify/src/pb/message.ts", "../../@libp2p/identify/src/identify.ts", "../../@libp2p/identify/src/index.ts"],
  "sourcesContent": ["export const PROTOCOL_VERSION = 'ipfs/0.1.0' // deprecated\nexport const MULTICODEC_IDENTIFY = '/ipfs/id/1.0.0' // deprecated\nexport const MULTICODEC_IDENTIFY_PUSH = '/ipfs/id/push/1.0.0' // deprecated\n\nexport const IDENTIFY_PROTOCOL_VERSION = '0.1.0'\nexport const MULTICODEC_IDENTIFY_PROTOCOL_NAME = 'id'\nexport const MULTICODEC_IDENTIFY_PUSH_PROTOCOL_NAME = 'id/push'\nexport const MULTICODEC_IDENTIFY_PROTOCOL_VERSION = '1.0.0'\nexport const MULTICODEC_IDENTIFY_PUSH_PROTOCOL_VERSION = '1.0.0'\n", "/* eslint-disable import/export */\n/* eslint-disable complexity */\n/* eslint-disable @typescript-eslint/no-namespace */\n/* eslint-disable @typescript-eslint/no-unnecessary-boolean-literal-compare */\n/* eslint-disable @typescript-eslint/no-empty-interface */\n\nimport { encodeMessage, decodeMessage, message } from 'protons-runtime'\nimport type { Codec } from 'protons-runtime'\nimport type { Uint8ArrayList } from 'uint8arraylist'\n\nexport interface Identify {\n  protocolVersion?: string\n  agentVersion?: string\n  publicKey?: Uint8Array\n  listenAddrs: Uint8Array[]\n  observedAddr?: Uint8Array\n  protocols: string[]\n  signedPeerRecord?: Uint8Array\n}\n\nexport namespace Identify {\n  let _codec: Codec<Identify>\n\n  export const codec = (): Codec<Identify> => {\n    if (_codec == null) {\n      _codec = message<Identify>((obj, w, opts = {}) => {\n        if (opts.lengthDelimited !== false) {\n          w.fork()\n        }\n\n        if (obj.protocolVersion != null) {\n          w.uint32(42)\n          w.string(obj.protocolVersion)\n        }\n\n        if (obj.agentVersion != null) {\n          w.uint32(50)\n          w.string(obj.agentVersion)\n        }\n\n        if (obj.publicKey != null) {\n          w.uint32(10)\n          w.bytes(obj.publicKey)\n        }\n\n        if (obj.listenAddrs != null) {\n          for (const value of obj.listenAddrs) {\n            w.uint32(18)\n            w.bytes(value)\n          }\n        }\n\n        if (obj.observedAddr != null) {\n          w.uint32(34)\n          w.bytes(obj.observedAddr)\n        }\n\n        if (obj.protocols != null) {\n          for (const value of obj.protocols) {\n            w.uint32(26)\n            w.string(value)\n          }\n        }\n\n        if (obj.signedPeerRecord != null) {\n          w.uint32(66)\n          w.bytes(obj.signedPeerRecord)\n        }\n\n        if (opts.lengthDelimited !== false) {\n          w.ldelim()\n        }\n      }, (reader, length) => {\n        const obj: any = {\n          listenAddrs: [],\n          protocols: []\n        }\n\n        const end = length == null ? reader.len : reader.pos + length\n\n        while (reader.pos < end) {\n          const tag = reader.uint32()\n\n          switch (tag >>> 3) {\n            case 5:\n              obj.protocolVersion = reader.string()\n              break\n            case 6:\n              obj.agentVersion = reader.string()\n              break\n            case 1:\n              obj.publicKey = reader.bytes()\n              break\n            case 2:\n              obj.listenAddrs.push(reader.bytes())\n              break\n            case 4:\n              obj.observedAddr = reader.bytes()\n              break\n            case 3:\n              obj.protocols.push(reader.string())\n              break\n            case 8:\n              obj.signedPeerRecord = reader.bytes()\n              break\n            default:\n              reader.skipType(tag & 7)\n              break\n          }\n        }\n\n        return obj\n      })\n    }\n\n    return _codec\n  }\n\n  export const encode = (obj: Partial<Identify>): Uint8Array => {\n    return encodeMessage(obj, Identify.codec())\n  }\n\n  export const decode = (buf: Uint8Array | Uint8ArrayList): Identify => {\n    return decodeMessage(buf, Identify.codec())\n  }\n}\n", "/* eslint-disable complexity */\n\nimport { CodeError, ERR_NOT_FOUND, setMaxListeners } from '@libp2p/interface'\nimport { peerIdFromKeys } from '@libp2p/peer-id'\nimport { RecordEnvelope, PeerRecord } from '@libp2p/peer-record'\nimport { type Multiaddr, multiaddr, protocols } from '@multiformats/multiaddr'\nimport { IP_OR_DOMAIN } from '@multiformats/multiaddr-matcher'\nimport { pbStream } from 'it-protobuf-stream'\nimport { fromString as uint8ArrayFromString } from 'uint8arrays/from-string'\nimport { toString as uint8ArrayToString } from 'uint8arrays/to-string'\nimport { isNode, isBrowser, isWebWorker, isElectronMain, isElectronRenderer, isReactNative } from 'wherearewe'\nimport {\n  IDENTIFY_PROTOCOL_VERSION,\n  MULTICODEC_IDENTIFY_PROTOCOL_NAME,\n  MULTICODEC_IDENTIFY_PUSH_PROTOCOL_NAME,\n  MULTICODEC_IDENTIFY_PROTOCOL_VERSION,\n  MULTICODEC_IDENTIFY_PUSH_PROTOCOL_VERSION\n} from './consts.js'\nimport { Identify as IdentifyMessage } from './pb/message.js'\nimport type { Identify as IdentifyInterface, IdentifyComponents, IdentifyInit } from './index.js'\nimport type { Libp2pEvents, IdentifyResult, SignedPeerRecord, AbortOptions, Logger, Connection, Stream, TypedEventTarget, PeerId, Peer, PeerData, PeerStore, Startable } from '@libp2p/interface'\nimport type { AddressManager, ConnectionManager, IncomingStreamData, Registrar } from '@libp2p/interface-internal'\n\n// https://github.com/libp2p/go-libp2p/blob/8d2e54e1637041d5cf4fac1e531287560bd1f4ac/p2p/protocol/identify/id.go#L52\nconst MAX_IDENTIFY_MESSAGE_SIZE = 1024 * 8\n\nconst defaultValues = {\n  protocolPrefix: 'ipfs',\n  // https://github.com/libp2p/go-libp2p/blob/8d2e54e1637041d5cf4fac1e531287560bd1f4ac/p2p/protocol/identify/id.go#L48\n  timeout: 60000,\n  maxInboundStreams: 1,\n  maxOutboundStreams: 1,\n  maxPushIncomingStreams: 1,\n  maxPushOutgoingStreams: 1,\n  maxObservedAddresses: 10,\n  maxIdentifyMessageSize: 8192,\n  runOnConnectionOpen: true,\n  runOnTransientConnection: true\n}\n\nexport class Identify implements Startable, IdentifyInterface {\n  private readonly identifyProtocolStr: string\n  private readonly identifyPushProtocolStr: string\n  public readonly host: {\n    protocolVersion: string\n    agentVersion: string\n  }\n\n  private started: boolean\n  private readonly timeout: number\n  private readonly peerId: PeerId\n  private readonly peerStore: PeerStore\n  private readonly registrar: Registrar\n  private readonly connectionManager: ConnectionManager\n  private readonly addressManager: AddressManager\n  private readonly maxInboundStreams: number\n  private readonly maxOutboundStreams: number\n  private readonly maxPushIncomingStreams: number\n  private readonly maxPushOutgoingStreams: number\n  private readonly maxIdentifyMessageSize: number\n  private readonly maxObservedAddresses: number\n  private readonly events: TypedEventTarget<Libp2pEvents>\n  private readonly runOnTransientConnection: boolean\n  private readonly log: Logger\n\n  constructor (components: IdentifyComponents, init: IdentifyInit = {}) {\n    this.started = false\n    this.peerId = components.peerId\n    this.peerStore = components.peerStore\n    this.registrar = components.registrar\n    this.addressManager = components.addressManager\n    this.connectionManager = components.connectionManager\n    this.events = components.events\n    this.log = components.logger.forComponent('libp2p:identify')\n\n    this.identifyProtocolStr = `/${init.protocolPrefix ?? defaultValues.protocolPrefix}/${MULTICODEC_IDENTIFY_PROTOCOL_NAME}/${MULTICODEC_IDENTIFY_PROTOCOL_VERSION}`\n    this.identifyPushProtocolStr = `/${init.protocolPrefix ?? defaultValues.protocolPrefix}/${MULTICODEC_IDENTIFY_PUSH_PROTOCOL_NAME}/${MULTICODEC_IDENTIFY_PUSH_PROTOCOL_VERSION}`\n    this.timeout = init.timeout ?? defaultValues.timeout\n    this.maxInboundStreams = init.maxInboundStreams ?? defaultValues.maxInboundStreams\n    this.maxOutboundStreams = init.maxOutboundStreams ?? defaultValues.maxOutboundStreams\n    this.maxPushIncomingStreams = init.maxPushIncomingStreams ?? defaultValues.maxPushIncomingStreams\n    this.maxPushOutgoingStreams = init.maxPushOutgoingStreams ?? defaultValues.maxPushOutgoingStreams\n    this.maxIdentifyMessageSize = init.maxIdentifyMessageSize ?? defaultValues.maxIdentifyMessageSize\n    this.maxObservedAddresses = init.maxObservedAddresses ?? defaultValues.maxObservedAddresses\n    this.runOnTransientConnection = init.runOnTransientConnection ?? defaultValues.runOnTransientConnection\n\n    // Store self host metadata\n    this.host = {\n      protocolVersion: `${init.protocolPrefix ?? defaultValues.protocolPrefix}/${IDENTIFY_PROTOCOL_VERSION}`,\n      agentVersion: init.agentVersion ?? `${components.nodeInfo.name}/${components.nodeInfo.version}`\n    }\n\n    if (init.runOnConnectionOpen ?? defaultValues.runOnConnectionOpen) {\n      // When a new connection happens, trigger identify\n      components.events.addEventListener('connection:open', (evt) => {\n        const connection = evt.detail\n        this.identify(connection).catch(err => { this.log.error('error during identify trigged by connection:open', err) })\n      })\n    }\n\n    // When self peer record changes, trigger identify-push\n    components.events.addEventListener('self:peer:update', (evt) => {\n      void this.push().catch(err => { this.log.error(err) })\n    })\n\n    // Append user agent version to default AGENT_VERSION depending on the environment\n    if (this.host.agentVersion === `${components.nodeInfo.name}/${components.nodeInfo.version}`) {\n      if (isNode || isElectronMain) {\n        this.host.agentVersion += ` UserAgent=${globalThis.process.version}`\n      } else if (isBrowser || isWebWorker || isElectronRenderer || isReactNative) {\n        this.host.agentVersion += ` UserAgent=${globalThis.navigator.userAgent}`\n      }\n    }\n  }\n\n  isStarted (): boolean {\n    return this.started\n  }\n\n  async start (): Promise<void> {\n    if (this.started) {\n      return\n    }\n\n    await this.peerStore.merge(this.peerId, {\n      metadata: {\n        AgentVersion: uint8ArrayFromString(this.host.agentVersion),\n        ProtocolVersion: uint8ArrayFromString(this.host.protocolVersion)\n      }\n    })\n\n    await this.registrar.handle(this.identifyProtocolStr, (data) => {\n      void this._handleIdentify(data).catch(err => {\n        this.log.error(err)\n      })\n    }, {\n      maxInboundStreams: this.maxInboundStreams,\n      maxOutboundStreams: this.maxOutboundStreams,\n      runOnTransientConnection: this.runOnTransientConnection\n    })\n    await this.registrar.handle(this.identifyPushProtocolStr, (data) => {\n      void this._handlePush(data).catch(err => {\n        this.log.error(err)\n      })\n    }, {\n      maxInboundStreams: this.maxPushIncomingStreams,\n      maxOutboundStreams: this.maxPushOutgoingStreams,\n      runOnTransientConnection: this.runOnTransientConnection\n    })\n\n    this.started = true\n  }\n\n  async stop (): Promise<void> {\n    await this.registrar.unhandle(this.identifyProtocolStr)\n    await this.registrar.unhandle(this.identifyPushProtocolStr)\n\n    this.started = false\n  }\n\n  /**\n   * Send an Identify Push update to the list of connections\n   */\n  async pushToConnections (connections: Connection[]): Promise<void> {\n    const listenAddresses = this.addressManager.getAddresses().map(ma => ma.decapsulateCode(protocols('p2p').code))\n    const peerRecord = new PeerRecord({\n      peerId: this.peerId,\n      multiaddrs: listenAddresses\n    })\n    const signedPeerRecord = await RecordEnvelope.seal(peerRecord, this.peerId)\n    const supportedProtocols = this.registrar.getProtocols()\n    const peer = await this.peerStore.get(this.peerId)\n    const agentVersion = uint8ArrayToString(peer.metadata.get('AgentVersion') ?? uint8ArrayFromString(this.host.agentVersion))\n    const protocolVersion = uint8ArrayToString(peer.metadata.get('ProtocolVersion') ?? uint8ArrayFromString(this.host.protocolVersion))\n\n    const pushes = connections.map(async connection => {\n      let stream: Stream | undefined\n      const signal = AbortSignal.timeout(this.timeout)\n\n      setMaxListeners(Infinity, signal)\n\n      try {\n        stream = await connection.newStream(this.identifyPushProtocolStr, {\n          signal,\n          runOnTransientConnection: this.runOnTransientConnection\n        })\n\n        const pb = pbStream(stream, {\n          maxDataLength: this.maxIdentifyMessageSize ?? MAX_IDENTIFY_MESSAGE_SIZE\n        }).pb(IdentifyMessage)\n\n        await pb.write({\n          listenAddrs: listenAddresses.map(ma => ma.bytes),\n          signedPeerRecord: signedPeerRecord.marshal(),\n          protocols: supportedProtocols,\n          agentVersion,\n          protocolVersion\n        }, {\n          signal\n        })\n\n        await stream.close({\n          signal\n        })\n      } catch (err: any) {\n        // Just log errors\n        this.log.error('could not push identify update to peer', err)\n        stream?.abort(err)\n      }\n    })\n\n    await Promise.all(pushes)\n  }\n\n  /**\n   * Calls `push` on all peer connections\n   */\n  async push (): Promise<void> {\n    // Do not try to push if we are not running\n    if (!this.isStarted()) {\n      return\n    }\n\n    const connections: Connection[] = []\n\n    await Promise.all(\n      this.connectionManager.getConnections().map(async conn => {\n        try {\n          const peer = await this.peerStore.get(conn.remotePeer)\n\n          if (!peer.protocols.includes(this.identifyPushProtocolStr)) {\n            return\n          }\n\n          connections.push(conn)\n        } catch (err: any) {\n          if (err.code !== ERR_NOT_FOUND) {\n            throw err\n          }\n        }\n      })\n    )\n\n    await this.pushToConnections(connections)\n  }\n\n  async _identify (connection: Connection, options: AbortOptions = {}): Promise<IdentifyMessage> {\n    let stream: Stream | undefined\n\n    if (options.signal == null) {\n      const signal = AbortSignal.timeout(this.timeout)\n      setMaxListeners(Infinity, signal)\n\n      options = {\n        ...options,\n        signal\n      }\n    }\n\n    try {\n      stream = await connection.newStream(this.identifyProtocolStr, {\n        ...options,\n        runOnTransientConnection: this.runOnTransientConnection\n      })\n\n      const pb = pbStream(stream, {\n        maxDataLength: this.maxIdentifyMessageSize ?? MAX_IDENTIFY_MESSAGE_SIZE\n      }).pb(IdentifyMessage)\n\n      const message = await pb.read(options)\n\n      await stream.close(options)\n\n      return message\n    } catch (err: any) {\n      this.log.error('error while reading identify message', err)\n      stream?.abort(err)\n      throw err\n    }\n  }\n\n  async identify (connection: Connection, options: AbortOptions = {}): Promise<IdentifyResult> {\n    const message = await this._identify(connection, options)\n    const {\n      publicKey,\n      protocols,\n      observedAddr\n    } = message\n\n    if (publicKey == null) {\n      throw new CodeError('public key was missing from identify message', 'ERR_MISSING_PUBLIC_KEY')\n    }\n\n    const id = await peerIdFromKeys(publicKey)\n\n    if (!connection.remotePeer.equals(id)) {\n      throw new CodeError('identified peer does not match the expected peer', 'ERR_INVALID_PEER')\n    }\n\n    if (this.peerId.equals(id)) {\n      throw new CodeError('identified peer is our own peer id?', 'ERR_INVALID_PEER')\n    }\n\n    // Get the observedAddr if there is one\n    const cleanObservedAddr = getCleanMultiaddr(observedAddr)\n\n    this.log('identify completed for peer %p and protocols %o', id, protocols)\n    this.log('our observed address is %a', cleanObservedAddr)\n\n    if (cleanObservedAddr != null &&\n        this.addressManager.getObservedAddrs().length < (this.maxObservedAddresses ?? Infinity)) {\n      this.log('storing our observed address %a', cleanObservedAddr)\n      this.addressManager.addObservedAddr(cleanObservedAddr)\n    }\n\n    return this.#consumeIdentifyMessage(connection, message)\n  }\n\n  /**\n   * Sends the `Identify` response with the Signed Peer Record\n   * to the requesting peer over the given `connection`\n   */\n  async _handleIdentify (data: IncomingStreamData): Promise<void> {\n    const { connection, stream } = data\n\n    const signal = AbortSignal.timeout(this.timeout)\n\n    setMaxListeners(Infinity, signal)\n\n    try {\n      const publicKey = this.peerId.publicKey ?? new Uint8Array(0)\n      const peerData = await this.peerStore.get(this.peerId)\n      const multiaddrs = this.addressManager.getAddresses().map(ma => ma.decapsulateCode(protocols('p2p').code))\n      let signedPeerRecord = peerData.peerRecordEnvelope\n\n      if (multiaddrs.length > 0 && signedPeerRecord == null) {\n        const peerRecord = new PeerRecord({\n          peerId: this.peerId,\n          multiaddrs\n        })\n\n        const envelope = await RecordEnvelope.seal(peerRecord, this.peerId)\n        signedPeerRecord = envelope.marshal().subarray()\n      }\n\n      let observedAddr: Uint8Array | undefined = connection.remoteAddr.bytes\n\n      if (!IP_OR_DOMAIN.matches(connection.remoteAddr)) {\n        observedAddr = undefined\n      }\n\n      const pb = pbStream(stream).pb(IdentifyMessage)\n\n      await pb.write({\n        protocolVersion: this.host.protocolVersion,\n        agentVersion: this.host.agentVersion,\n        publicKey,\n        listenAddrs: multiaddrs.map(addr => addr.bytes),\n        signedPeerRecord,\n        observedAddr,\n        protocols: peerData.protocols\n      }, {\n        signal\n      })\n\n      await stream.close({\n        signal\n      })\n    } catch (err: any) {\n      this.log.error('could not respond to identify request', err)\n      stream.abort(err)\n    }\n  }\n\n  /**\n   * Reads the Identify Push message from the given `connection`\n   */\n  async _handlePush (data: IncomingStreamData): Promise<void> {\n    const { connection, stream } = data\n\n    try {\n      if (this.peerId.equals(connection.remotePeer)) {\n        throw new Error('received push from ourselves?')\n      }\n\n      const options = {\n        signal: AbortSignal.timeout(this.timeout)\n      }\n\n      const pb = pbStream(stream, {\n        maxDataLength: this.maxIdentifyMessageSize ?? MAX_IDENTIFY_MESSAGE_SIZE\n      }).pb(IdentifyMessage)\n\n      const message = await pb.read(options)\n      await stream.close(options)\n\n      await this.#consumeIdentifyMessage(connection, message)\n    } catch (err: any) {\n      this.log.error('received invalid message', err)\n      stream.abort(err)\n      return\n    }\n\n    this.log('handled push from %p', connection.remotePeer)\n  }\n\n  async #consumeIdentifyMessage (connection: Connection, message: IdentifyMessage): Promise<IdentifyResult> {\n    this.log('received identify from %p', connection.remotePeer)\n\n    if (message == null) {\n      throw new CodeError('message was null or undefined', 'ERR_INVALID_MESSAGE')\n    }\n\n    const peer: PeerData = {}\n\n    if (message.listenAddrs.length > 0) {\n      peer.addresses = message.listenAddrs.map(buf => ({\n        isCertified: false,\n        multiaddr: multiaddr(buf)\n      }))\n    }\n\n    if (message.protocols.length > 0) {\n      peer.protocols = message.protocols\n    }\n\n    if (message.publicKey != null) {\n      peer.publicKey = message.publicKey\n\n      const peerId = await peerIdFromKeys(message.publicKey)\n\n      if (!peerId.equals(connection.remotePeer)) {\n        throw new CodeError('public key did not match remote PeerId', 'ERR_INVALID_PUBLIC_KEY')\n      }\n    }\n\n    let output: SignedPeerRecord | undefined\n\n    // if the peer record has been sent, prefer the addresses in the record as they are signed by the remote peer\n    if (message.signedPeerRecord != null) {\n      this.log('received signedPeerRecord from %p', connection.remotePeer)\n\n      let peerRecordEnvelope = message.signedPeerRecord\n      const envelope = await RecordEnvelope.openAndCertify(peerRecordEnvelope, PeerRecord.DOMAIN)\n      let peerRecord = PeerRecord.createFromProtobuf(envelope.payload)\n\n      // Verify peerId\n      if (!peerRecord.peerId.equals(envelope.peerId)) {\n        throw new CodeError('signing key does not match PeerId in the PeerRecord', 'ERR_INVALID_SIGNING_KEY')\n      }\n\n      // Make sure remote peer is the one sending the record\n      if (!connection.remotePeer.equals(peerRecord.peerId)) {\n        throw new CodeError('signing key does not match remote PeerId', 'ERR_INVALID_PEER_RECORD_KEY')\n      }\n\n      let existingPeer: Peer | undefined\n\n      try {\n        existingPeer = await this.peerStore.get(peerRecord.peerId)\n      } catch (err: any) {\n        if (err.code !== 'ERR_NOT_FOUND') {\n          throw err\n        }\n      }\n\n      if (existingPeer != null) {\n        // don't lose any existing metadata\n        peer.metadata = existingPeer.metadata\n\n        // if we have previously received a signed record for this peer, compare it to the incoming one\n        if (existingPeer.peerRecordEnvelope != null) {\n          const storedEnvelope = await RecordEnvelope.createFromProtobuf(existingPeer.peerRecordEnvelope)\n          const storedRecord = PeerRecord.createFromProtobuf(storedEnvelope.payload)\n\n          // ensure seq is greater than, or equal to, the last received\n          if (storedRecord.seqNumber >= peerRecord.seqNumber) {\n            this.log('sequence number was lower or equal to existing sequence number - stored: %d received: %d', storedRecord.seqNumber, peerRecord.seqNumber)\n            peerRecord = storedRecord\n            peerRecordEnvelope = existingPeer.peerRecordEnvelope\n          }\n        }\n      }\n\n      // store the signed record for next time\n      peer.peerRecordEnvelope = peerRecordEnvelope\n\n      // override the stored addresses with the signed multiaddrs\n      peer.addresses = peerRecord.multiaddrs.map(multiaddr => ({\n        isCertified: true,\n        multiaddr\n      }))\n\n      output = {\n        seq: peerRecord.seqNumber,\n        addresses: peerRecord.multiaddrs\n      }\n    } else {\n      this.log('%p did not send a signed peer record', connection.remotePeer)\n    }\n\n    this.log('patching %p with', connection.remotePeer, peer)\n    await this.peerStore.patch(connection.remotePeer, peer)\n\n    if (message.agentVersion != null || message.protocolVersion != null) {\n      const metadata: Record<string, Uint8Array> = {}\n\n      if (message.agentVersion != null) {\n        metadata.AgentVersion = uint8ArrayFromString(message.agentVersion)\n      }\n\n      if (message.protocolVersion != null) {\n        metadata.ProtocolVersion = uint8ArrayFromString(message.protocolVersion)\n      }\n\n      this.log('merging %p metadata', connection.remotePeer, metadata)\n      await this.peerStore.merge(connection.remotePeer, {\n        metadata\n      })\n    }\n\n    const result: IdentifyResult = {\n      peerId: connection.remotePeer,\n      protocolVersion: message.protocolVersion,\n      agentVersion: message.agentVersion,\n      publicKey: message.publicKey,\n      listenAddrs: message.listenAddrs.map(buf => multiaddr(buf)),\n      observedAddr: message.observedAddr == null ? undefined : multiaddr(message.observedAddr),\n      protocols: message.protocols,\n      signedPeerRecord: output,\n      connection\n    }\n\n    this.events.safeDispatchEvent('peer:identify', { detail: result })\n\n    return result\n  }\n}\n\n/**\n * Takes the `addr` and converts it to a Multiaddr if possible\n */\nfunction getCleanMultiaddr (addr: Uint8Array | string | null | undefined): Multiaddr | undefined {\n  if (addr != null && addr.length > 0) {\n    try {\n      return multiaddr(addr)\n    } catch {\n\n    }\n  }\n}\n", "/**\n * @packageDocumentation\n *\n * Use the `identify` function to add support for the [Identify protocol](https://github.com/libp2p/specs/blob/master/identify/README.md) to libp2p.\n *\n * @example\n *\n * ```typescript\n * import { createLibp2p } from 'libp2p'\n * import { identify } from '@libp2p/identify'\n *\n * const node = await createLibp2p({\n *   // ...other options\n *   services: {\n *     identify: identify()\n *   }\n * })\n * ```\n */\n\nimport {\n  MULTICODEC_IDENTIFY,\n  MULTICODEC_IDENTIFY_PUSH\n} from './consts.js'\nimport { Identify as IdentifyClass } from './identify.js'\nimport type { AbortOptions, IdentifyResult, Libp2pEvents, ComponentLogger, NodeInfo, TypedEventTarget, PeerId, PeerStore, Connection } from '@libp2p/interface'\nimport type { AddressManager, ConnectionManager, Registrar } from '@libp2p/interface-internal'\n\nexport interface IdentifyInit {\n  /**\n   * The prefix to use for the protocol (default: 'ipfs')\n   */\n  protocolPrefix?: string\n\n  /**\n   * What details we should send as part of an identify message\n   */\n  agentVersion?: string\n\n  /**\n   * How long we should wait for a remote peer to send their identify response\n   */\n  timeout?: number\n\n  /**\n   * Identify responses larger than this in bytes will be rejected (default: 8192)\n   */\n  maxIdentifyMessageSize?: number\n\n  maxInboundStreams?: number\n  maxOutboundStreams?: number\n\n  maxPushIncomingStreams?: number\n  maxPushOutgoingStreams?: number\n  maxObservedAddresses?: number\n\n  /**\n   * Whether to automatically dial identify on newly opened connections (default: true)\n   */\n  runOnConnectionOpen?: boolean\n\n  /**\n   * Whether to run on connections with data or duration limits (default: true)\n   */\n  runOnTransientConnection?: boolean\n}\n\nexport interface IdentifyComponents {\n  peerId: PeerId\n  peerStore: PeerStore\n  connectionManager: ConnectionManager\n  registrar: Registrar\n  addressManager: AddressManager\n  events: TypedEventTarget<Libp2pEvents>\n  logger: ComponentLogger\n  nodeInfo: NodeInfo\n}\n\n/**\n * The protocols the Identify service supports\n */\nexport const multicodecs = {\n  IDENTIFY: MULTICODEC_IDENTIFY,\n  IDENTIFY_PUSH: MULTICODEC_IDENTIFY_PUSH\n}\n\nexport interface Identify {\n  /**\n   * due to the default limits on inbound/outbound streams for this protocol,\n   * invoking this method when runOnConnectionOpen is true can lead to unpredictable results\n   * as streams may be closed by the local or the remote node.\n   * Please use with caution. If you find yourself needing to call this method to discover other peers that support your protocol,\n   * you may be better off configuring a topology to be notified instead.\n   */\n  identify(connection: Connection, options?: AbortOptions): Promise<IdentifyResult>\n\n  push(): Promise<void>\n}\n\nexport function identify (init: IdentifyInit = {}): (components: IdentifyComponents) => Identify {\n  return (components) => new IdentifyClass(components, init)\n}\n"],
  "mappings": "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",
  "names": ["Identify", "Identify", "message", "multiaddr", "Identify"]
}
