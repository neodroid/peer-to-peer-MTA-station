import {
  isIPv4,
  isIPv6
} from "./chunk-5LRH4A7Q.js";
import {
  base58btc,
  base64url
} from "./chunk-P6Z4FGVE.js";

// node_modules/@multiformats/multiaddr-matcher/dist/src/index.js
var toParts = (ma) => {
  return ma.toString().split("/").slice(1);
};
var func = (fn) => {
  return {
    match: (vals) => {
      if (vals.length < 1) {
        return false;
      }
      if (fn(vals[0])) {
        return vals.slice(1);
      }
      return false;
    },
    pattern: "fn"
  };
};
var literal = (str) => {
  return {
    match: (vals) => func((val) => val === str).match(vals),
    pattern: str
  };
};
var string = () => {
  return {
    match: (vals) => func((val) => typeof val === "string").match(vals),
    pattern: "{string}"
  };
};
var number = () => {
  return {
    match: (vals) => func((val) => !isNaN(parseInt(val))).match(vals),
    pattern: "{number}"
  };
};
var peerId = () => {
  return {
    match: (vals) => {
      if (vals.length < 2) {
        return false;
      }
      if (vals[0] !== "p2p" && vals[0] !== "ipfs") {
        return false;
      }
      if (vals[1].startsWith("Q") || vals[1].startsWith("1")) {
        try {
          base58btc.decode(`z${vals[1]}`);
        } catch (err) {
          return false;
        }
      } else {
        return false;
      }
      return vals.slice(2);
    },
    pattern: "/p2p/{peerid}"
  };
};
var certhash = () => {
  return {
    match: (vals) => {
      if (vals.length < 2) {
        return false;
      }
      if (vals[0] !== "certhash") {
        return false;
      }
      try {
        base64url.decode(vals[1]);
      } catch {
        return false;
      }
      return vals.slice(2);
    },
    pattern: "/certhash/{certhash}"
  };
};
var optional = (matcher) => {
  return {
    match: (vals) => {
      const result = matcher.match(vals);
      if (result === false) {
        return vals;
      }
      return result;
    },
    pattern: `optional(${matcher.pattern})`
  };
};
var or = (...matchers) => {
  return {
    match: (vals) => {
      let matches;
      for (const matcher of matchers) {
        const result = matcher.match(vals);
        if (result === false) {
          continue;
        }
        if (matches == null || result.length < matches.length) {
          matches = result;
        }
      }
      if (matches == null) {
        return false;
      }
      return matches;
    },
    pattern: `or(${matchers.map((m) => m.pattern).join(", ")})`
  };
};
var and = (...matchers) => {
  return {
    match: (vals) => {
      for (const matcher of matchers) {
        const result = matcher.match(vals);
        if (result === false) {
          return false;
        }
        vals = result;
      }
      return vals;
    },
    pattern: `and(${matchers.map((m) => m.pattern).join(", ")})`
  };
};
function fmt(...matchers) {
  function match(ma) {
    let parts = toParts(ma);
    for (const matcher of matchers) {
      const result = matcher.match(parts);
      if (result === false) {
        return false;
      }
      parts = result;
    }
    return parts;
  }
  function matches(ma) {
    const result = match(ma);
    return result !== false;
  }
  function exactMatch(ma) {
    const result = match(ma);
    if (result === false) {
      return false;
    }
    return result.length === 0;
  }
  return {
    matches,
    exactMatch
  };
}
var _DNS4 = and(literal("dns4"), string());
var _DNS6 = and(literal("dns6"), string());
var _DNSADDR = and(literal("dnsaddr"), string());
var _DNS = and(literal("dns"), string());
var DNS4 = fmt(_DNS4);
var DNS6 = fmt(_DNS6);
var DNSADDR = fmt(_DNSADDR);
var DNS = fmt(or(_DNS, _DNSADDR, _DNS4, _DNS6));
var _IP4 = and(literal("ip4"), func(isIPv4));
var _IP6 = and(literal("ip6"), func(isIPv6));
var _IP = or(_IP4, _IP6);
var _IP_OR_DOMAIN = or(_IP, _DNS, _DNS4, _DNS6, _DNSADDR);
var IP_OR_DOMAIN = fmt(_IP_OR_DOMAIN);
var IP4 = fmt(_IP4);
var IP6 = fmt(_IP6);
var IP = fmt(_IP);
var _TCP = and(_IP_OR_DOMAIN, literal("tcp"), number());
var _UDP = and(_IP_OR_DOMAIN, literal("udp"), number());
var TCP_OR_UDP = or(_TCP, _UDP);
var TCP = fmt(_TCP);
var UDP = fmt(_UDP);
var _QUIC = and(_UDP, literal("quic"));
var _QUICV1 = and(_UDP, literal("quic-v1"));
var QUIC_V0_OR_V1 = or(_QUIC, _QUICV1);
var QUIC = fmt(_QUIC);
var QUICV1 = fmt(_QUICV1);
var _WEB = or(_IP_OR_DOMAIN, _TCP, _UDP, _QUIC, _QUICV1);
var _WebSockets = or(and(_WEB, literal("ws"), optional(peerId())));
var WebSockets = fmt(_WebSockets);
var _WebSocketsSecure = or(and(_WEB, literal("wss"), optional(peerId())), and(_WEB, literal("tls"), literal("ws"), optional(peerId())));
var WebSocketsSecure = fmt(_WebSocketsSecure);
var _WebRTCDirect = and(TCP_OR_UDP, literal("webrtc-direct"), certhash(), optional(certhash()), optional(peerId()));
var WebRTCDirect = fmt(_WebRTCDirect);
var _WebTransport = and(_QUICV1, literal("webtransport"), optional(certhash()), optional(certhash()), optional(peerId()));
var WebTransport = fmt(_WebTransport);
var _P2P = or(_WebSockets, _WebSocketsSecure, and(_TCP, optional(peerId())), and(QUIC_V0_OR_V1, optional(peerId())), and(_IP_OR_DOMAIN, optional(peerId())), _WebRTCDirect, _WebTransport, peerId());
var P2P = fmt(_P2P);
var _Circuit = and(_P2P, literal("p2p-circuit"), peerId());
var Circuit = fmt(_Circuit);
var _WebRTC = or(and(_P2P, literal("p2p-circuit"), literal("webrtc"), peerId()), and(_P2P, literal("webrtc"), optional(peerId())), literal("webrtc"));
var WebRTC = fmt(_WebRTC);
var _HTTP = or(and(_IP_OR_DOMAIN, literal("tcp"), number(), literal("http"), optional(peerId())), and(_IP_OR_DOMAIN, literal("http"), optional(peerId())));
var HTTP = fmt(_HTTP);
var _HTTPS = or(and(_IP_OR_DOMAIN, literal("tcp"), or(and(literal("443"), literal("http")), and(number(), literal("https"))), optional(peerId())), and(_IP_OR_DOMAIN, literal("tls"), literal("http"), optional(peerId())), and(_IP_OR_DOMAIN, literal("https"), optional(peerId())));
var HTTPS = fmt(_HTTPS);

export {
  DNS,
  IP_OR_DOMAIN,
  IP,
  WebRTCDirect,
  Circuit,
  WebRTC
};
//# sourceMappingURL=chunk-A27LQ35F.js.map
