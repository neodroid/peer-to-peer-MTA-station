{
  "version": 3,
  "sources": ["../../get-iterator/src/index.ts", "../../@libp2p/utils/src/is-promise.ts", "../../@libp2p/utils/src/close-source.ts", "../../@libp2p/utils/src/abstract-stream.ts"],
  "sourcesContent": ["\n// If the passed object is an (async) iterable, then get the iterator\n// If it's probably an iterator already (i.e. has next function) return it\n// else throw\nexport function getIterator <T> (obj: AsyncIterable<T>): AsyncIterator<T>\nexport function getIterator <T> (obj: AsyncIterator<T>): AsyncIterator<T>\nexport function getIterator <T> (obj: Iterable<T>): Iterator<T>\nexport function getIterator <T> (obj: Iterator<T>): Iterator<T>\nexport function getIterator <T> (obj: any): AsyncIterator<T> | Iterator <T>\nexport function getIterator <T> (obj: any): AsyncIterator<T> | Iterator <T> {\n  if (obj != null) {\n    if (typeof obj[Symbol.iterator] === 'function') {\n      return obj[Symbol.iterator]()\n    }\n    if (typeof obj[Symbol.asyncIterator] === 'function') {\n      return obj[Symbol.asyncIterator]()\n    }\n    if (typeof obj.next === 'function') {\n      return obj // probably an iterator\n    }\n  }\n  throw new Error('argument is not an iterator or iterable')\n}\n", "export function isPromise <T = unknown> (thing: any): thing is Promise<T> {\n  if (thing == null) {\n    return false\n  }\n\n  return typeof thing.then === 'function' &&\n    typeof thing.catch === 'function' &&\n    typeof thing.finally === 'function'\n}\n", "import { getIterator } from 'get-iterator'\nimport { isPromise } from './is-promise.js'\nimport type { Logger } from '@libp2p/logger'\nimport type { Source } from 'it-stream-types'\n\nexport function closeSource (source: Source<unknown>, log: Logger): void {\n  const res = getIterator(source).return?.()\n\n  if (isPromise(res)) {\n    res.catch(err => {\n      log.error('could not cause iterator to return', err)\n    })\n  }\n}\n", "import { CodeError } from '@libp2p/interface'\nimport { type Pushable, pushable } from 'it-pushable'\nimport defer, { type DeferredPromise } from 'p-defer'\nimport pDefer from 'p-defer'\nimport { raceSignal } from 'race-signal'\nimport { Uint8ArrayList } from 'uint8arraylist'\nimport { closeSource } from './close-source.js'\nimport type { AbortOptions, Direction, ReadStatus, Stream, StreamStatus, StreamTimeline, WriteStatus } from '@libp2p/interface'\nimport type { Logger } from '@libp2p/logger'\nimport type { Source } from 'it-stream-types'\n\nconst ERR_STREAM_RESET = 'ERR_STREAM_RESET'\nconst ERR_SINK_INVALID_STATE = 'ERR_SINK_INVALID_STATE'\nconst DEFAULT_SEND_CLOSE_WRITE_TIMEOUT = 5000\n\nexport interface AbstractStreamInit {\n  /**\n   * A unique identifier for this stream\n   */\n  id: string\n\n  /**\n   * The stream direction\n   */\n  direction: Direction\n\n  /**\n   * A Logger implementation used to log stream-specific information\n   */\n  log: Logger\n\n  /**\n   * User specific stream metadata\n   */\n  metadata?: Record<string, unknown>\n\n  /**\n   * Invoked when the stream ends\n   */\n  onEnd?(err?: Error | undefined): void\n\n  /**\n   * Invoked when the readable end of the stream is closed\n   */\n  onCloseRead?(): void\n\n  /**\n   * Invoked when the writable end of the stream is closed\n   */\n  onCloseWrite?(): void\n\n  /**\n   * Invoked when the stream has been reset by the remote\n   */\n  onReset?(): void\n\n  /**\n   * Invoked when the stream has errored\n   */\n  onAbort?(err: Error): void\n\n  /**\n   * How long to wait in ms for stream data to be written to the underlying\n   * connection when closing the writable end of the stream. (default: 500)\n   */\n  closeTimeout?: number\n\n  /**\n   * After the stream sink has closed, a limit on how long it takes to send\n   * a close-write message to the remote peer.\n   */\n  sendCloseWriteTimeout?: number\n}\n\nfunction isPromise <T = unknown> (thing: any): thing is Promise<T> {\n  if (thing == null) {\n    return false\n  }\n\n  return typeof thing.then === 'function' &&\n    typeof thing.catch === 'function' &&\n    typeof thing.finally === 'function'\n}\n\nexport abstract class AbstractStream implements Stream {\n  public id: string\n  public direction: Direction\n  public timeline: StreamTimeline\n  public protocol?: string\n  public metadata: Record<string, unknown>\n  public source: AsyncGenerator<Uint8ArrayList, void, unknown>\n  public status: StreamStatus\n  public readStatus: ReadStatus\n  public writeStatus: WriteStatus\n  public readonly log: Logger\n\n  private readonly sinkController: AbortController\n  private readonly sinkEnd: DeferredPromise<void>\n  private readonly closed: DeferredPromise<void>\n  private endErr: Error | undefined\n  private readonly streamSource: Pushable<Uint8ArrayList>\n  private readonly onEnd?: (err?: Error | undefined) => void\n  private readonly onCloseRead?: () => void\n  private readonly onCloseWrite?: () => void\n  private readonly onReset?: () => void\n  private readonly onAbort?: (err: Error) => void\n  private readonly sendCloseWriteTimeout: number\n  private sendingData?: DeferredPromise<void>\n\n  constructor (init: AbstractStreamInit) {\n    this.sinkController = new AbortController()\n    this.sinkEnd = defer()\n    this.closed = defer()\n    this.log = init.log\n\n    // stream status\n    this.status = 'open'\n    this.readStatus = 'ready'\n    this.writeStatus = 'ready'\n\n    this.id = init.id\n    this.metadata = init.metadata ?? {}\n    this.direction = init.direction\n    this.timeline = {\n      open: Date.now()\n    }\n    this.sendCloseWriteTimeout = init.sendCloseWriteTimeout ?? DEFAULT_SEND_CLOSE_WRITE_TIMEOUT\n\n    this.onEnd = init.onEnd\n    this.onCloseRead = init?.onCloseRead\n    this.onCloseWrite = init?.onCloseWrite\n    this.onReset = init?.onReset\n    this.onAbort = init?.onAbort\n\n    this.source = this.streamSource = pushable<Uint8ArrayList>({\n      onEnd: (err) => {\n        if (err != null) {\n          this.log.trace('source ended with error', err)\n        } else {\n          this.log.trace('source ended')\n        }\n\n        this.onSourceEnd(err)\n      }\n    })\n\n    // necessary because the libp2p upgrader wraps the sink function\n    this.sink = this.sink.bind(this)\n  }\n\n  async sink (source: Source<Uint8ArrayList | Uint8Array>): Promise<void> {\n    if (this.writeStatus !== 'ready') {\n      throw new CodeError(`writable end state is \"${this.writeStatus}\" not \"ready\"`, ERR_SINK_INVALID_STATE)\n    }\n\n    try {\n      this.writeStatus = 'writing'\n\n      const options: AbortOptions = {\n        signal: this.sinkController.signal\n      }\n\n      if (this.direction === 'outbound') { // If initiator, open a new stream\n        const res = this.sendNewStream(options)\n\n        if (isPromise(res)) {\n          await res\n        }\n      }\n\n      const abortListener = (): void => {\n        closeSource(source, this.log)\n      }\n\n      try {\n        this.sinkController.signal.addEventListener('abort', abortListener)\n\n        this.log.trace('sink reading from source')\n\n        for await (let data of source) {\n          data = data instanceof Uint8Array ? new Uint8ArrayList(data) : data\n\n          const res = this.sendData(data, options)\n\n          if (isPromise(res)) {\n            this.sendingData = pDefer()\n            await res\n            this.sendingData.resolve()\n            this.sendingData = undefined\n          }\n        }\n      } finally {\n        this.sinkController.signal.removeEventListener('abort', abortListener)\n      }\n\n      this.log.trace('sink finished reading from source, write status is \"%s\"', this.writeStatus)\n\n      if (this.writeStatus === 'writing') {\n        this.writeStatus = 'closing'\n\n        this.log.trace('send close write to remote')\n        await this.sendCloseWrite({\n          signal: AbortSignal.timeout(this.sendCloseWriteTimeout)\n        })\n\n        this.writeStatus = 'closed'\n      }\n\n      this.onSinkEnd()\n    } catch (err: any) {\n      this.log.trace('sink ended with error, calling abort with error', err)\n      this.abort(err)\n\n      throw err\n    } finally {\n      this.log.trace('resolve sink end')\n      this.sinkEnd.resolve()\n    }\n  }\n\n  protected onSourceEnd (err?: Error): void {\n    if (this.timeline.closeRead != null) {\n      return\n    }\n\n    this.timeline.closeRead = Date.now()\n    this.readStatus = 'closed'\n\n    if (err != null && this.endErr == null) {\n      this.endErr = err\n    }\n\n    this.onCloseRead?.()\n\n    if (this.timeline.closeWrite != null) {\n      this.log.trace('source and sink ended')\n      this.timeline.close = Date.now()\n\n      if (this.status !== 'aborted' && this.status !== 'reset') {\n        this.status = 'closed'\n      }\n\n      if (this.onEnd != null) {\n        this.onEnd(this.endErr)\n      }\n\n      this.closed.resolve()\n    } else {\n      this.log.trace('source ended, waiting for sink to end')\n    }\n  }\n\n  protected onSinkEnd (err?: Error): void {\n    if (this.timeline.closeWrite != null) {\n      return\n    }\n\n    this.timeline.closeWrite = Date.now()\n    this.writeStatus = 'closed'\n\n    if (err != null && this.endErr == null) {\n      this.endErr = err\n    }\n\n    this.onCloseWrite?.()\n\n    if (this.timeline.closeRead != null) {\n      this.log.trace('sink and source ended')\n      this.timeline.close = Date.now()\n\n      if (this.status !== 'aborted' && this.status !== 'reset') {\n        this.status = 'closed'\n      }\n\n      if (this.onEnd != null) {\n        this.onEnd(this.endErr)\n      }\n\n      this.closed.resolve()\n    } else {\n      this.log.trace('sink ended, waiting for source to end')\n    }\n  }\n\n  // Close for both Reading and Writing\n  async close (options?: AbortOptions): Promise<void> {\n    this.log.trace('closing gracefully')\n\n    this.status = 'closing'\n\n    // wait for read and write ends to close\n    await raceSignal(Promise.all([\n      this.closeWrite(options),\n      this.closeRead(options),\n      this.closed.promise\n    ]), options?.signal)\n\n    this.status = 'closed'\n\n    this.log.trace('closed gracefully')\n  }\n\n  async closeRead (options: AbortOptions = {}): Promise<void> {\n    if (this.readStatus === 'closing' || this.readStatus === 'closed') {\n      return\n    }\n\n    this.log.trace('closing readable end of stream with starting read status \"%s\"', this.readStatus)\n\n    const readStatus = this.readStatus\n    this.readStatus = 'closing'\n\n    if (this.status !== 'reset' && this.status !== 'aborted' && this.timeline.closeRead == null) {\n      this.log.trace('send close read to remote')\n      await this.sendCloseRead(options)\n    }\n\n    if (readStatus === 'ready') {\n      this.log.trace('ending internal source queue with %d queued bytes', this.streamSource.readableLength)\n      this.streamSource.end()\n    }\n\n    this.log.trace('closed readable end of stream')\n  }\n\n  async closeWrite (options: AbortOptions = {}): Promise<void> {\n    if (this.writeStatus === 'closing' || this.writeStatus === 'closed') {\n      return\n    }\n\n    this.log.trace('closing writable end of stream with starting write status \"%s\"', this.writeStatus)\n\n    if (this.writeStatus === 'ready') {\n      this.log.trace('sink was never sunk, sink an empty array')\n\n      await raceSignal(this.sink([]), options.signal)\n    }\n\n    if (this.writeStatus === 'writing') {\n      // try to let sending outgoing data succeed\n      if (this.sendingData != null) {\n        await raceSignal(this.sendingData.promise, options.signal)\n      }\n\n      // stop reading from the source passed to `.sink`\n      this.log.trace('aborting source passed to .sink')\n      this.sinkController.abort()\n      await raceSignal(this.sinkEnd.promise, options.signal)\n    }\n\n    this.writeStatus = 'closed'\n\n    this.log.trace('closed writable end of stream')\n  }\n\n  /**\n   * Close immediately for reading and writing and send a reset message (local\n   * error)\n   */\n  abort (err: Error): void {\n    if (this.status === 'closed' || this.status === 'aborted' || this.status === 'reset') {\n      return\n    }\n\n    this.log('abort with error', err)\n\n    // try to send a reset message\n    this.log('try to send reset to remote')\n    const res = this.sendReset()\n\n    if (isPromise(res)) {\n      res.catch((err) => {\n        this.log.error('error sending reset message', err)\n      })\n    }\n\n    this.status = 'aborted'\n    this.timeline.abort = Date.now()\n    this._closeSinkAndSource(err)\n    this.onAbort?.(err)\n  }\n\n  /**\n   * Receive a reset message - close immediately for reading and writing (remote\n   * error)\n   */\n  reset (): void {\n    if (this.status === 'closed' || this.status === 'aborted' || this.status === 'reset') {\n      return\n    }\n\n    const err = new CodeError('stream reset', ERR_STREAM_RESET)\n\n    this.status = 'reset'\n    this.timeline.reset = Date.now()\n    this._closeSinkAndSource(err)\n    this.onReset?.()\n  }\n\n  _closeSinkAndSource (err?: Error): void {\n    this._closeSink(err)\n    this._closeSource(err)\n  }\n\n  _closeSink (err?: Error): void {\n    // if the sink function is running, cause it to end\n    if (this.writeStatus === 'writing') {\n      this.log.trace('end sink source')\n      this.sinkController.abort()\n    }\n\n    this.onSinkEnd(err)\n  }\n\n  _closeSource (err?: Error): void {\n    // if the source is not ending, end it\n    if (this.readStatus !== 'closing' && this.readStatus !== 'closed') {\n      this.log.trace('ending source with %d bytes to be read by consumer', this.streamSource.readableLength)\n      this.readStatus = 'closing'\n      this.streamSource.end(err)\n    }\n  }\n\n  /**\n   * The remote closed for writing so we should expect to receive no more\n   * messages\n   */\n  remoteCloseWrite (): void {\n    if (this.readStatus === 'closing' || this.readStatus === 'closed') {\n      this.log('received remote close write but local source is already closed')\n      return\n    }\n\n    this.log.trace('remote close write')\n    this._closeSource()\n  }\n\n  /**\n   * The remote closed for reading so we should not send any more\n   * messages\n   */\n  remoteCloseRead (): void {\n    if (this.writeStatus === 'closing' || this.writeStatus === 'closed') {\n      this.log('received remote close read but local sink is already closed')\n      return\n    }\n\n    this.log.trace('remote close read')\n    this._closeSink()\n  }\n\n  /**\n   * The underlying muxer has closed, no more messages can be sent or will\n   * be received, close immediately to free up resources\n   */\n  destroy (): void {\n    if (this.status === 'closed' || this.status === 'aborted' || this.status === 'reset') {\n      this.log('received destroy but we are already closed')\n      return\n    }\n\n    this.log.trace('stream destroyed')\n\n    this._closeSinkAndSource()\n  }\n\n  /**\n   * When an extending class reads data from it's implementation-specific source,\n   * call this method to allow the stream consumer to read the data.\n   */\n  sourcePush (data: Uint8ArrayList): void {\n    this.streamSource.push(data)\n  }\n\n  /**\n   * Returns the amount of unread data - can be used to prevent large amounts of\n   * data building up when the stream consumer is too slow.\n   */\n  sourceReadableLength (): number {\n    return this.streamSource.readableLength\n  }\n\n  /**\n   * Send a message to the remote muxer informing them a new stream is being\n   * opened\n   */\n  abstract sendNewStream (options?: AbortOptions): void | Promise<void>\n\n  /**\n   * Send a data message to the remote muxer\n   */\n  abstract sendData (buf: Uint8ArrayList, options?: AbortOptions): void | Promise<void>\n\n  /**\n   * Send a reset message to the remote muxer\n   */\n  abstract sendReset (options?: AbortOptions): void | Promise<void>\n\n  /**\n   * Send a message to the remote muxer, informing them no more data messages\n   * will be sent by this end of the stream\n   */\n  abstract sendCloseWrite (options?: AbortOptions): void | Promise<void>\n\n  /**\n   * Send a message to the remote muxer, informing them no more data messages\n   * will be read by this end of the stream\n   */\n  abstract sendCloseRead (options?: AbortOptions): void | Promise<void>\n}\n"],
  "mappings": "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",
  "names": ["isPromise", "err"]
}
