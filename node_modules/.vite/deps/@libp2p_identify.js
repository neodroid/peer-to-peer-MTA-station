import {
  PeerRecord,
  RecordEnvelope
} from "./chunk-ML4RWVAO.js";
import {
  isBrowser,
  isElectronMain,
  isElectronRenderer,
  isNode,
  isReactNative,
  isWebWorker
} from "./chunk-FY7Q5C6G.js";
import {
  IP_OR_DOMAIN
} from "./chunk-A27LQ35F.js";
import {
  pbStream
} from "./chunk-Z2JWY6QB.js";
import "./chunk-WI4NAQ2P.js";
import "./chunk-3W5ODUXV.js";
import "./chunk-HCKUFEZV.js";
import {
  peerIdFromKeys
} from "./chunk-MUJBFYE2.js";
import {
  decodeMessage,
  encodeMessage,
  message
} from "./chunk-TAPWQVFO.js";
import "./chunk-SHVKZIHG.js";
import "./chunk-GYD5GS2D.js";
import {
  multiaddr
} from "./chunk-YDXGPUQ5.js";
import {
  getProtocol
} from "./chunk-5LRH4A7Q.js";
import "./chunk-JLOXJLWY.js";
import {
  fromString,
  toString
} from "./chunk-P6Z4FGVE.js";
import {
  CodeError,
  ERR_NOT_FOUND,
  setMaxListeners
} from "./chunk-Q7O7U65G.js";
import "./chunk-NNBXUUFX.js";

// node_modules/@libp2p/identify/dist/src/consts.js
var MULTICODEC_IDENTIFY = "/ipfs/id/1.0.0";
var MULTICODEC_IDENTIFY_PUSH = "/ipfs/id/push/1.0.0";
var IDENTIFY_PROTOCOL_VERSION = "0.1.0";
var MULTICODEC_IDENTIFY_PROTOCOL_NAME = "id";
var MULTICODEC_IDENTIFY_PUSH_PROTOCOL_NAME = "id/push";
var MULTICODEC_IDENTIFY_PROTOCOL_VERSION = "1.0.0";
var MULTICODEC_IDENTIFY_PUSH_PROTOCOL_VERSION = "1.0.0";

// node_modules/@libp2p/identify/dist/src/pb/message.js
var Identify;
(function(Identify3) {
  let _codec;
  Identify3.codec = () => {
    if (_codec == null) {
      _codec = message((obj, w, opts = {}) => {
        if (opts.lengthDelimited !== false) {
          w.fork();
        }
        if (obj.protocolVersion != null) {
          w.uint32(42);
          w.string(obj.protocolVersion);
        }
        if (obj.agentVersion != null) {
          w.uint32(50);
          w.string(obj.agentVersion);
        }
        if (obj.publicKey != null) {
          w.uint32(10);
          w.bytes(obj.publicKey);
        }
        if (obj.listenAddrs != null) {
          for (const value of obj.listenAddrs) {
            w.uint32(18);
            w.bytes(value);
          }
        }
        if (obj.observedAddr != null) {
          w.uint32(34);
          w.bytes(obj.observedAddr);
        }
        if (obj.protocols != null) {
          for (const value of obj.protocols) {
            w.uint32(26);
            w.string(value);
          }
        }
        if (obj.signedPeerRecord != null) {
          w.uint32(66);
          w.bytes(obj.signedPeerRecord);
        }
        if (opts.lengthDelimited !== false) {
          w.ldelim();
        }
      }, (reader, length) => {
        const obj = {
          listenAddrs: [],
          protocols: []
        };
        const end = length == null ? reader.len : reader.pos + length;
        while (reader.pos < end) {
          const tag = reader.uint32();
          switch (tag >>> 3) {
            case 5:
              obj.protocolVersion = reader.string();
              break;
            case 6:
              obj.agentVersion = reader.string();
              break;
            case 1:
              obj.publicKey = reader.bytes();
              break;
            case 2:
              obj.listenAddrs.push(reader.bytes());
              break;
            case 4:
              obj.observedAddr = reader.bytes();
              break;
            case 3:
              obj.protocols.push(reader.string());
              break;
            case 8:
              obj.signedPeerRecord = reader.bytes();
              break;
            default:
              reader.skipType(tag & 7);
              break;
          }
        }
        return obj;
      });
    }
    return _codec;
  };
  Identify3.encode = (obj) => {
    return encodeMessage(obj, Identify3.codec());
  };
  Identify3.decode = (buf) => {
    return decodeMessage(buf, Identify3.codec());
  };
})(Identify || (Identify = {}));

// node_modules/@libp2p/identify/dist/src/identify.js
var MAX_IDENTIFY_MESSAGE_SIZE = 1024 * 8;
var defaultValues = {
  protocolPrefix: "ipfs",
  // https://github.com/libp2p/go-libp2p/blob/8d2e54e1637041d5cf4fac1e531287560bd1f4ac/p2p/protocol/identify/id.go#L48
  timeout: 6e4,
  maxInboundStreams: 1,
  maxOutboundStreams: 1,
  maxPushIncomingStreams: 1,
  maxPushOutgoingStreams: 1,
  maxObservedAddresses: 10,
  maxIdentifyMessageSize: 8192,
  runOnConnectionOpen: true,
  runOnTransientConnection: true
};
var Identify2 = class {
  identifyProtocolStr;
  identifyPushProtocolStr;
  host;
  started;
  timeout;
  peerId;
  peerStore;
  registrar;
  connectionManager;
  addressManager;
  maxInboundStreams;
  maxOutboundStreams;
  maxPushIncomingStreams;
  maxPushOutgoingStreams;
  maxIdentifyMessageSize;
  maxObservedAddresses;
  events;
  runOnTransientConnection;
  log;
  constructor(components, init = {}) {
    this.started = false;
    this.peerId = components.peerId;
    this.peerStore = components.peerStore;
    this.registrar = components.registrar;
    this.addressManager = components.addressManager;
    this.connectionManager = components.connectionManager;
    this.events = components.events;
    this.log = components.logger.forComponent("libp2p:identify");
    this.identifyProtocolStr = `/${init.protocolPrefix ?? defaultValues.protocolPrefix}/${MULTICODEC_IDENTIFY_PROTOCOL_NAME}/${MULTICODEC_IDENTIFY_PROTOCOL_VERSION}`;
    this.identifyPushProtocolStr = `/${init.protocolPrefix ?? defaultValues.protocolPrefix}/${MULTICODEC_IDENTIFY_PUSH_PROTOCOL_NAME}/${MULTICODEC_IDENTIFY_PUSH_PROTOCOL_VERSION}`;
    this.timeout = init.timeout ?? defaultValues.timeout;
    this.maxInboundStreams = init.maxInboundStreams ?? defaultValues.maxInboundStreams;
    this.maxOutboundStreams = init.maxOutboundStreams ?? defaultValues.maxOutboundStreams;
    this.maxPushIncomingStreams = init.maxPushIncomingStreams ?? defaultValues.maxPushIncomingStreams;
    this.maxPushOutgoingStreams = init.maxPushOutgoingStreams ?? defaultValues.maxPushOutgoingStreams;
    this.maxIdentifyMessageSize = init.maxIdentifyMessageSize ?? defaultValues.maxIdentifyMessageSize;
    this.maxObservedAddresses = init.maxObservedAddresses ?? defaultValues.maxObservedAddresses;
    this.runOnTransientConnection = init.runOnTransientConnection ?? defaultValues.runOnTransientConnection;
    this.host = {
      protocolVersion: `${init.protocolPrefix ?? defaultValues.protocolPrefix}/${IDENTIFY_PROTOCOL_VERSION}`,
      agentVersion: init.agentVersion ?? `${components.nodeInfo.name}/${components.nodeInfo.version}`
    };
    if (init.runOnConnectionOpen ?? defaultValues.runOnConnectionOpen) {
      components.events.addEventListener("connection:open", (evt) => {
        const connection = evt.detail;
        this.identify(connection).catch((err) => {
          this.log.error("error during identify trigged by connection:open", err);
        });
      });
    }
    components.events.addEventListener("self:peer:update", (evt) => {
      void this.push().catch((err) => {
        this.log.error(err);
      });
    });
    if (this.host.agentVersion === `${components.nodeInfo.name}/${components.nodeInfo.version}`) {
      if (isNode || isElectronMain) {
        this.host.agentVersion += ` UserAgent=${globalThis.process.version}`;
      } else if (isBrowser || isWebWorker || isElectronRenderer || isReactNative) {
        this.host.agentVersion += ` UserAgent=${globalThis.navigator.userAgent}`;
      }
    }
  }
  isStarted() {
    return this.started;
  }
  async start() {
    if (this.started) {
      return;
    }
    await this.peerStore.merge(this.peerId, {
      metadata: {
        AgentVersion: fromString(this.host.agentVersion),
        ProtocolVersion: fromString(this.host.protocolVersion)
      }
    });
    await this.registrar.handle(this.identifyProtocolStr, (data) => {
      void this._handleIdentify(data).catch((err) => {
        this.log.error(err);
      });
    }, {
      maxInboundStreams: this.maxInboundStreams,
      maxOutboundStreams: this.maxOutboundStreams,
      runOnTransientConnection: this.runOnTransientConnection
    });
    await this.registrar.handle(this.identifyPushProtocolStr, (data) => {
      void this._handlePush(data).catch((err) => {
        this.log.error(err);
      });
    }, {
      maxInboundStreams: this.maxPushIncomingStreams,
      maxOutboundStreams: this.maxPushOutgoingStreams,
      runOnTransientConnection: this.runOnTransientConnection
    });
    this.started = true;
  }
  async stop() {
    await this.registrar.unhandle(this.identifyProtocolStr);
    await this.registrar.unhandle(this.identifyPushProtocolStr);
    this.started = false;
  }
  /**
   * Send an Identify Push update to the list of connections
   */
  async pushToConnections(connections) {
    const listenAddresses = this.addressManager.getAddresses().map((ma) => ma.decapsulateCode(getProtocol("p2p").code));
    const peerRecord = new PeerRecord({
      peerId: this.peerId,
      multiaddrs: listenAddresses
    });
    const signedPeerRecord = await RecordEnvelope.seal(peerRecord, this.peerId);
    const supportedProtocols = this.registrar.getProtocols();
    const peer = await this.peerStore.get(this.peerId);
    const agentVersion = toString(peer.metadata.get("AgentVersion") ?? fromString(this.host.agentVersion));
    const protocolVersion = toString(peer.metadata.get("ProtocolVersion") ?? fromString(this.host.protocolVersion));
    const pushes = connections.map(async (connection) => {
      let stream;
      const signal = AbortSignal.timeout(this.timeout);
      setMaxListeners(Infinity, signal);
      try {
        stream = await connection.newStream(this.identifyPushProtocolStr, {
          signal,
          runOnTransientConnection: this.runOnTransientConnection
        });
        const pb = pbStream(stream, {
          maxDataLength: this.maxIdentifyMessageSize ?? MAX_IDENTIFY_MESSAGE_SIZE
        }).pb(Identify);
        await pb.write({
          listenAddrs: listenAddresses.map((ma) => ma.bytes),
          signedPeerRecord: signedPeerRecord.marshal(),
          protocols: supportedProtocols,
          agentVersion,
          protocolVersion
        }, {
          signal
        });
        await stream.close({
          signal
        });
      } catch (err) {
        this.log.error("could not push identify update to peer", err);
        stream?.abort(err);
      }
    });
    await Promise.all(pushes);
  }
  /**
   * Calls `push` on all peer connections
   */
  async push() {
    if (!this.isStarted()) {
      return;
    }
    const connections = [];
    await Promise.all(this.connectionManager.getConnections().map(async (conn) => {
      try {
        const peer = await this.peerStore.get(conn.remotePeer);
        if (!peer.protocols.includes(this.identifyPushProtocolStr)) {
          return;
        }
        connections.push(conn);
      } catch (err) {
        if (err.code !== ERR_NOT_FOUND) {
          throw err;
        }
      }
    }));
    await this.pushToConnections(connections);
  }
  async _identify(connection, options = {}) {
    let stream;
    if (options.signal == null) {
      const signal = AbortSignal.timeout(this.timeout);
      setMaxListeners(Infinity, signal);
      options = {
        ...options,
        signal
      };
    }
    try {
      stream = await connection.newStream(this.identifyProtocolStr, {
        ...options,
        runOnTransientConnection: this.runOnTransientConnection
      });
      const pb = pbStream(stream, {
        maxDataLength: this.maxIdentifyMessageSize ?? MAX_IDENTIFY_MESSAGE_SIZE
      }).pb(Identify);
      const message2 = await pb.read(options);
      await stream.close(options);
      return message2;
    } catch (err) {
      this.log.error("error while reading identify message", err);
      stream?.abort(err);
      throw err;
    }
  }
  async identify(connection, options = {}) {
    const message2 = await this._identify(connection, options);
    const { publicKey, protocols, observedAddr } = message2;
    if (publicKey == null) {
      throw new CodeError("public key was missing from identify message", "ERR_MISSING_PUBLIC_KEY");
    }
    const id = await peerIdFromKeys(publicKey);
    if (!connection.remotePeer.equals(id)) {
      throw new CodeError("identified peer does not match the expected peer", "ERR_INVALID_PEER");
    }
    if (this.peerId.equals(id)) {
      throw new CodeError("identified peer is our own peer id?", "ERR_INVALID_PEER");
    }
    const cleanObservedAddr = getCleanMultiaddr(observedAddr);
    this.log("identify completed for peer %p and protocols %o", id, protocols);
    this.log("our observed address is %a", cleanObservedAddr);
    if (cleanObservedAddr != null && this.addressManager.getObservedAddrs().length < (this.maxObservedAddresses ?? Infinity)) {
      this.log("storing our observed address %a", cleanObservedAddr);
      this.addressManager.addObservedAddr(cleanObservedAddr);
    }
    return this.#consumeIdentifyMessage(connection, message2);
  }
  /**
   * Sends the `Identify` response with the Signed Peer Record
   * to the requesting peer over the given `connection`
   */
  async _handleIdentify(data) {
    const { connection, stream } = data;
    const signal = AbortSignal.timeout(this.timeout);
    setMaxListeners(Infinity, signal);
    try {
      const publicKey = this.peerId.publicKey ?? new Uint8Array(0);
      const peerData = await this.peerStore.get(this.peerId);
      const multiaddrs = this.addressManager.getAddresses().map((ma) => ma.decapsulateCode(getProtocol("p2p").code));
      let signedPeerRecord = peerData.peerRecordEnvelope;
      if (multiaddrs.length > 0 && signedPeerRecord == null) {
        const peerRecord = new PeerRecord({
          peerId: this.peerId,
          multiaddrs
        });
        const envelope = await RecordEnvelope.seal(peerRecord, this.peerId);
        signedPeerRecord = envelope.marshal().subarray();
      }
      let observedAddr = connection.remoteAddr.bytes;
      if (!IP_OR_DOMAIN.matches(connection.remoteAddr)) {
        observedAddr = void 0;
      }
      const pb = pbStream(stream).pb(Identify);
      await pb.write({
        protocolVersion: this.host.protocolVersion,
        agentVersion: this.host.agentVersion,
        publicKey,
        listenAddrs: multiaddrs.map((addr) => addr.bytes),
        signedPeerRecord,
        observedAddr,
        protocols: peerData.protocols
      }, {
        signal
      });
      await stream.close({
        signal
      });
    } catch (err) {
      this.log.error("could not respond to identify request", err);
      stream.abort(err);
    }
  }
  /**
   * Reads the Identify Push message from the given `connection`
   */
  async _handlePush(data) {
    const { connection, stream } = data;
    try {
      if (this.peerId.equals(connection.remotePeer)) {
        throw new Error("received push from ourselves?");
      }
      const options = {
        signal: AbortSignal.timeout(this.timeout)
      };
      const pb = pbStream(stream, {
        maxDataLength: this.maxIdentifyMessageSize ?? MAX_IDENTIFY_MESSAGE_SIZE
      }).pb(Identify);
      const message2 = await pb.read(options);
      await stream.close(options);
      await this.#consumeIdentifyMessage(connection, message2);
    } catch (err) {
      this.log.error("received invalid message", err);
      stream.abort(err);
      return;
    }
    this.log("handled push from %p", connection.remotePeer);
  }
  async #consumeIdentifyMessage(connection, message2) {
    this.log("received identify from %p", connection.remotePeer);
    if (message2 == null) {
      throw new CodeError("message was null or undefined", "ERR_INVALID_MESSAGE");
    }
    const peer = {};
    if (message2.listenAddrs.length > 0) {
      peer.addresses = message2.listenAddrs.map((buf) => ({
        isCertified: false,
        multiaddr: multiaddr(buf)
      }));
    }
    if (message2.protocols.length > 0) {
      peer.protocols = message2.protocols;
    }
    if (message2.publicKey != null) {
      peer.publicKey = message2.publicKey;
      const peerId = await peerIdFromKeys(message2.publicKey);
      if (!peerId.equals(connection.remotePeer)) {
        throw new CodeError("public key did not match remote PeerId", "ERR_INVALID_PUBLIC_KEY");
      }
    }
    let output;
    if (message2.signedPeerRecord != null) {
      this.log("received signedPeerRecord from %p", connection.remotePeer);
      let peerRecordEnvelope = message2.signedPeerRecord;
      const envelope = await RecordEnvelope.openAndCertify(peerRecordEnvelope, PeerRecord.DOMAIN);
      let peerRecord = PeerRecord.createFromProtobuf(envelope.payload);
      if (!peerRecord.peerId.equals(envelope.peerId)) {
        throw new CodeError("signing key does not match PeerId in the PeerRecord", "ERR_INVALID_SIGNING_KEY");
      }
      if (!connection.remotePeer.equals(peerRecord.peerId)) {
        throw new CodeError("signing key does not match remote PeerId", "ERR_INVALID_PEER_RECORD_KEY");
      }
      let existingPeer;
      try {
        existingPeer = await this.peerStore.get(peerRecord.peerId);
      } catch (err) {
        if (err.code !== "ERR_NOT_FOUND") {
          throw err;
        }
      }
      if (existingPeer != null) {
        peer.metadata = existingPeer.metadata;
        if (existingPeer.peerRecordEnvelope != null) {
          const storedEnvelope = await RecordEnvelope.createFromProtobuf(existingPeer.peerRecordEnvelope);
          const storedRecord = PeerRecord.createFromProtobuf(storedEnvelope.payload);
          if (storedRecord.seqNumber >= peerRecord.seqNumber) {
            this.log("sequence number was lower or equal to existing sequence number - stored: %d received: %d", storedRecord.seqNumber, peerRecord.seqNumber);
            peerRecord = storedRecord;
            peerRecordEnvelope = existingPeer.peerRecordEnvelope;
          }
        }
      }
      peer.peerRecordEnvelope = peerRecordEnvelope;
      peer.addresses = peerRecord.multiaddrs.map((multiaddr2) => ({
        isCertified: true,
        multiaddr: multiaddr2
      }));
      output = {
        seq: peerRecord.seqNumber,
        addresses: peerRecord.multiaddrs
      };
    } else {
      this.log("%p did not send a signed peer record", connection.remotePeer);
    }
    this.log("patching %p with", connection.remotePeer, peer);
    await this.peerStore.patch(connection.remotePeer, peer);
    if (message2.agentVersion != null || message2.protocolVersion != null) {
      const metadata = {};
      if (message2.agentVersion != null) {
        metadata.AgentVersion = fromString(message2.agentVersion);
      }
      if (message2.protocolVersion != null) {
        metadata.ProtocolVersion = fromString(message2.protocolVersion);
      }
      this.log("merging %p metadata", connection.remotePeer, metadata);
      await this.peerStore.merge(connection.remotePeer, {
        metadata
      });
    }
    const result = {
      peerId: connection.remotePeer,
      protocolVersion: message2.protocolVersion,
      agentVersion: message2.agentVersion,
      publicKey: message2.publicKey,
      listenAddrs: message2.listenAddrs.map((buf) => multiaddr(buf)),
      observedAddr: message2.observedAddr == null ? void 0 : multiaddr(message2.observedAddr),
      protocols: message2.protocols,
      signedPeerRecord: output,
      connection
    };
    this.events.safeDispatchEvent("peer:identify", { detail: result });
    return result;
  }
};
function getCleanMultiaddr(addr) {
  if (addr != null && addr.length > 0) {
    try {
      return multiaddr(addr);
    } catch {
    }
  }
}

// node_modules/@libp2p/identify/dist/src/index.js
var multicodecs = {
  IDENTIFY: MULTICODEC_IDENTIFY,
  IDENTIFY_PUSH: MULTICODEC_IDENTIFY_PUSH
};
function identify(init = {}) {
  return (components) => new Identify2(components, init);
}
export {
  identify,
  multicodecs
};
//# sourceMappingURL=@libp2p_identify.js.map
